{
  "title": "When to Trust the Cheap Check: Weak and Strong Verification for Reasoning",
  "link": "https://arxiv.org/abs/2602.17633v1",
  "published": "2026-02-19T18:47:38Z",
  "updated": "2026-02-19T18:47:38Z",
  "summary": "Reasoning with LLMs increasingly unfolds inside a broader verification loop. Internally, systems use cheap checks, such as self-consistency or proxy rewards, which we call weak verification. Externally, users inspect outputs and steer the model through feedback until results are trustworthy, which we call strong verification. These signals differ sharply in cost and reliability: strong verification can establish trust but is resource-intensive, while weak verification is fast and scalable but noisy and imperfect. We formalize this tension through weak--strong verification policies, which decide when to accept or reject based on weak verification and when to defer to strong verification. We introduce metrics capturing incorrect acceptance, incorrect rejection, and strong-verification frequency. Over population, we show that optimal policies admit a two-threshold structure and that calibration and sharpness govern the value of weak verifiers. Building on this, we develop an online algorithm that provably controls acceptance and rejection errors without assumptions on the query stream, the language model, or the weak verifier.",
  "id": "http://arxiv.org/abs/2602.17633v1",
  "authors": [
    "Shayan Kiyani",
    "Sima Noorani",
    "George Pappas",
    "Hamed Hassani"
  ],
  "categories": [
    "cs.LG",
    "cs.AI",
    "stat.ML"
  ],
  "pdf_link": "https://arxiv.org/pdf/2602.17633v1"
}