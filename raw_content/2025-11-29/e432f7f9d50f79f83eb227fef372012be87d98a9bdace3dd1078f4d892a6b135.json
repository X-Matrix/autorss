{
  "title": "How good engineers write bad code at big companies",
  "link": "https://seangoedecke.com/bad-code-at-big-companies/",
  "published": "Sat, 29 Nov 2025 00:00:00 GMT",
  "summary": "<p>Every couple of years <a href=\"https://ziglang.org/news/migrating-from-github-to-codeberg/\">somebody</a> <a href=\"https://github.com/microsoft/terminal/issues/10362\">notices</a> that large tech companies sometimes produce surprisingly sloppy code. If you haven’t worked at a big company, it might be hard to understand how this happens. Big tech companies pay well enough to attract many competent engineers. They move slowly enough that it looks like they’re able to take their time and do solid work. How does bad code happen?</p>\n<h3>Most code changes are made by relative beginners</h3>\n<p>I think the main reason is that <strong>big companies are full of engineers working outside their area of expertise</strong>. The average big tech employee stays for only <a href=\"https://stackoverflow.blog/2022/04/19/whats-the-average-tenure-of-an-engineer-at-a-big-tech-company-ep-434/\">a year or two</a><sup id=\"fnref-1\"><a class=\"footnote-ref\" href=\"#fn-1\">1</a></sup>. In fact, big tech compensation packages are typically designed to put a four-year cap on engineer tenure: after four years, the initial share grant is fully vested, causing engineers to take what can be a 50% pay cut. Companies do extend temporary yearly refreshes, but it obviously incentivizes engineers to go find another job where they don’t have to wonder if they’re going to get the other half of their compensation each year.</p>\n<p>If you count internal mobility, it’s even worse. The longest I have ever stayed on a single team or codebase was three years, near the start of my career. I expect to be <a href=\"https://www.youtube.com/watch?v=yDcaRklX7q4\">re-orged</a> at least every year, and often much more frequently.</p>\n<p>However, the average tenure of a codebase in a big tech company is a lot longer than that. Many of the services I work on are a decade old or more, and have had many, many different owners over the years. That means many big tech engineers are constantly “figuring it out”. <strong>A pretty high percentage of code changes are made by “beginners”:</strong> people who have onboarded to the company, the codebase, or even the programming language in the past six months.</p>\n<h3>Old hands</h3>\n<p>To some extent, this problem is mitigated by “old hands”: engineers who happen to have been in the orbit of a particular system for long enough to develop real expertise. These engineers can give deep code reviews and reliably catch obvious problems. But relying on “old hands” has two problems. </p>\n<p>First, <strong>this process is entirely informal</strong>. Big tech companies make surprisingly little effort to develop long-term expertise in individual systems, and once they’ve got it they seem to barely care at all about retaining it. Often the engineers in question are moved to different services, and have to either keep up their “old hand” duties on an effectively volunteer basis, or abandon them and become a relative beginner on a brand new system.</p>\n<p>Second, <strong>experienced engineers are always overloaded</strong>. It is a <em>busy</em> job being one of the few engineers who has deep expertise on a particular service. You don’t have enough time to personally review every software change, or to be actively involved in every decision-making process. Remember that <em>you also have your own work to do</em>: if you spend all your time reviewing changes and being involved in discussions, you’ll likely be punished by the company for not having enough individual output.</p>\n<h3>The median productive engineer</h3>\n<p>Putting all this together, what does the median productive<sup id=\"fnref-2\"><a class=\"footnote-ref\" href=\"#fn-2\">2</a></sup> engineer at a big tech company look like? They are usually:</p>\n<ul>\n<li>competent enough to pass the hiring bar and be able to do the work, but either</li>\n<li>working on a codebase or language that is largely new to them, or</li>\n<li>trying to stay on top of a flood of code changes while also juggling their own work.</li>\n</ul>\n<p>They are almost certainly working to a deadline, or to a series of overlapping deadlines for different projects. In other words, <strong>they are trying to do their best in an environment that is not set up to produce quality code.</strong></p>\n<p>That’s how “obviously” bad code happens. For instance, a junior engineer picks up a ticket for an annoying bug in a codebase they’re barely familiar with. They spend a few days figuring it out and come up with a hacky solution. One of the more senior “old hands” (if they’re lucky) glances over it in a spare half-hour, vetoes it, and suggests something slightly better that would at least work. The junior engineer implements that as best they can, tests that it works, it gets briefly reviewed and shipped, and everyone involved immediately moves on to higher-priority work. Five years later somebody notices this<sup id=\"fnref-3\"><a class=\"footnote-ref\" href=\"#fn-3\">3</a></sup> and thinks “wow, that’s hacky - how did such bad code get written at such a big software company”?</p>\n<h3>Big tech companies are fine with this</h3>\n<p>I have written a lot about the internal tech company dynamics that contribute to this. Most directly, in <a href=\"/seeing-like-a-software-company\"><em>Seeing like a software company</em></a> I argue that big tech companies consistently prioritize internal <em>legibility</em> - the ability to see at a glance who’s working on what and to change it at will - over productivity. Big companies know that treating engineers as fungible and moving them around destroys their ability to develop long-term expertise in a single codebase. <strong>That’s a deliberate tradeoff.</strong> They’re giving up some amount of expertise and software quality in order to gain the ability to rapidly deploy skilled engineers onto whatever the problem-of-the-month is.</p>\n<p>I don’t know if this is a good idea or a bad idea. It certainly seems to be working for the big tech companies, particularly now that “how fast can you pivot to something AI-related” is so important. But if you’re doing this, then <em>of course</em> you’re going to produce some genuinely bad code. That’s what happens when you ask engineers to rush out work on systems they’re unfamiliar with.</p>\n<p><strong>Individual engineers are entirely powerless to alter this dynamic</strong>. This is particularly true in 2025, when <a href=\"/good-times-are-over\">the balance of power has tilted</a> away from engineers and towards tech company leadership. The most you can do as an individual engineer is to try and become an “old hand”: to develop expertise in at least one area, and to use it to block the worst changes and steer people towards at least minimally-sensible technical decisions. But even that is often swimming against the current of the organization, and if inexpertly done can cause you to get <a href=\"https://www.reddit.com/r/csMajors/comments/1et7miz/what_you_need_to_know_about_performance/\">PIP-ed</a> or worse.</p>\n<h3>Pure and impure engineering</h3>\n<p>I think a lot of this comes down to the distinction between <a href=\"/pure-and-impure-engineering\">pure and impure software engineering</a>. To pure engineers - engineers working on self-contained technical projects, like <a href=\"https://ziglang.org/\">a programming language</a> - the only explanation for bad code is incompetence. But impure engineers operate more like plumbers or electricians. They’re working to deadlines on projects that are relatively new to them, and even if their technical fundamentals are impeccable, there’s always <em>something</em> about the particular setup of this situation that’s awkward or surprising. To impure engineers, bad code is inevitable. As long as the overall system works well enough, the project is a success.</p>\n<p>At big tech companies, engineers don’t get to decide if they’re working on pure or impure engineering work. It’s <a href=\"/not-your-codebase\">not their codebase</a>! If the company wants to move you from working on database infrastructure to building the new payments system, they’re fully entitled to do that. The fact that you might make some mistakes in an unfamiliar system - or that your old colleagues on the database infra team might suffer without your expertise - is a deliberate tradeoff being made by <strong>the company, not the engineer</strong>.</p>\n<p>It’s fine to point out examples of bad code at big companies. If nothing else, it can be an effective way to get those specific examples fixed, since execs usually jump at the chance to turn bad PR into good PR. But I think it’s a mistake<sup id=\"fnref-4\"><a class=\"footnote-ref\" href=\"#fn-4\">4</a></sup> to attribute primary responsibility to the engineers at those companies. If you could wave a magic wand and make every engineer twice as strong, <em>you would still have bad code</em>, because almost nobody can come into a brand new codebase and quickly make changes with zero mistakes. The root cause is that <strong>most big company engineers are forced to do most of their work in unfamiliar codebases</strong>.</p>\n<p>edit: this post got lots of comments on both <a href=\"https://news.ycombinator.com/item?id=46082223\">Hacker News</a> and <a href=\"https://lobste.rs/s/jxppk7/how_good_engineers_write_bad_code_at_big\">lobste.rs</a>.</p>\n<p>It was surprising to me that <a href=\"https://lobste.rs/c/glawav\">many</a> <a href=\"https://news.ycombinator.com/item?id=46083941\">commenters</a> find this point of view unplesasantly nihilistic. I consider myself fairly optimistic about my work. In fact, I meant this post as a rousing defence of big tech software engineers from their <a href=\"https://ziglang.org/news/migrating-from-github-to-codeberg\">critics</a>! Still, I found this <a href=\"https://alexwennerberg.com/blog/2025-11-28-engineering.html\">response blog post</a> to be an excellent articulation of the “this is too cynical” position, and will likely write a followup post about it soon (edit: <a href=\"/a-little-bit-cynical\"><em>Software engineers should be a little bit cynical</em></a>).</p>\n<p>Some Hacker News commenters had alternate theories for why bad code happens: <a href=\"https://news.ycombinator.com/item?id=46083625\">lack of motivation</a>, deliberately <a href=\"https://news.ycombinator.com/item?id=46082989\">demoralizing engineers</a> so they won’t unionize, or just purely optimizing for speed. I don’t find these compelling, based on my own experience. Many of my colleagues are highly motivated, and I just don’t believe any tech company is deliberately trying to make its engineers demoralized and unhappy.</p>\n<p>A few readers <a href=\"https://lobste.rs/c/gq4ao9\">disagreed with me</a> about RSUs providing an incentive to leave, because their companies give stock refreshers. I don’t know about this. I get refreshers too, but if they’re not in the contract, then I don’t think it matters - the company can decide not to give you 50% of your comp at-will by just pausing the refreshers, which is an incentive to move jobs so it’s locked in for four more years.</p>\n<div class=\"footnotes\">\n<hr />\n<ol>\n<li id=\"fn-1\">\n<p>I struggled to find a good original source on this. There’s a 2013 PayScale <a href=\"https://www.payscale.com/data-packages/employee-loyalty/least-loyal-employees\">report</a> citing a 1.1 year median turnover at Google, which seems low.</p>\n<a class=\"footnote-backref\" href=\"#fnref-1\">↩</a>\n</li>\n<li id=\"fn-2\">\n<p>Many engineers at big tech companies are not productive, but that’s a post all to itself. I don’t want to get into it here for two reasons. First, I think competent engineers produce enough bad code that it’s fine to be a bit generous and just scope the discussion to them. Second, even if an incompetent engineer wrote the code, there’s almost always competent engineers who could have reviewed it, and the question of why that didn’t happen is still interesting.</p>\n<a class=\"footnote-backref\" href=\"#fnref-2\">↩</a>\n</li>\n<li id=\"fn-3\">\n<p>The example I’m thinking of here is not the <a href=\"https://ziglang.org/news/migrating-from-github-to-codeberg/\">recent GitHub Actions one</a>, which I have no first-hand experience of. I can think of at least ten separate instances of this happening to me.</p>\n<a class=\"footnote-backref\" href=\"#fnref-3\">↩</a>\n</li>\n<li id=\"fn-4\">\n<p>In my view, mainly a failure of <em>imagination</em>: thinking that your own work environment must be pretty similar to everyone else’s.</p>\n<a class=\"footnote-backref\" href=\"#fnref-4\">↩</a>\n</li>\n</ol>\n</div>",
  "id": "https://seangoedecke.com/bad-code-at-big-companies/"
}