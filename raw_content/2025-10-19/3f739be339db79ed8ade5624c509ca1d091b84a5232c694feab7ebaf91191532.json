{
  "title": "What have we learned about building agentic AI tools?",
  "link": "https://seangoedecke.com/ideas-in-agentic-ai-tooling/",
  "published": "Sun, 19 Oct 2025 00:00:00 GMT",
  "summary": "<p>In the middle of 2025, agentic coding finally became a thing: first with the release of Claude Sonnet 4, the first “smart enough to be useful” agentic model, and then with OpenAI’s GPT-5-Codex, which is for my money the best-in-class agentic model. “Agent mode” is now the main way to interact with your preferred AI coding tool (whether that’s Claude Code, Codex, Copilot, or Cursor)<sup id=\"fnref-1\"><a class=\"footnote-ref\" href=\"#fn-1\">1</a></sup>.</p>\n<p>Obviously, much of this improvement is the result of better models. Sonnet 4 and Codex simply get lost less often and make fewer mistakes than their predecessors. But we’ve also seen a ton of improvements to the agentic <em>harness</em>: the code that wraps the LLM in a loop with tools.</p>\n<p>For an interesting time capsule, you can read my 2023 post <a href=\"/llm-driven-agents\"><em>Building LLM-driven agents</em></a>, where I wrote about my attempts to build an agentic coding system on top of GPT-3 (!). This was before tool calls existed - I had to prompt the model to include structured tool call content in its output and then parse that out. In hindsight, I was right about a few important things:</p>\n<ul>\n<li>LLM agentic coding could actually work</li>\n<li>If you build a good agentic coding tool, it’s only going to get more useful as better models come out</li>\n<li>You should tune your tool to a specific model instead of expecting one tool to work well across all models</li>\n<li>Most importantly, building an agentic coding tool is <em>normal software engineering</em>: you can make it more useful by investing more time into polishing and improving it</li>\n</ul>\n<p>So what have we learned about building agentic coding tools since then?</p>\n<p><strong>Agents should plan, then act.</strong> Instead of just saying “here are your tools, go solve this problem”, you should set up your coding tool (via some combination of specific tools and prompting) to begin by making an explicit plan. In fact, your tool should check items off the plan as it goes. This goes a long way towards maintaining coherence and preventing the chain-of-thought from going off the rails. It’s often a good idea to have a more powerful model make the plan and then a cheaper-but-faster model handle the execution.</p>\n<p><strong>Users should be able to plug their own tools in.</strong> The canonical version of this is <a href=\"/model-context-protocol\">MCP</a>, but any kind of tools marketplace or plugin system will do. The point is that there’s a lot of mileage in letting users connect, say, their Slack or Jira instance to your coding agent. However:</p>\n<p><strong>Don’t give the agent too many tools.</strong> Agents work best when they’ve got a short-but-sweet set of tools to work with. Too many tools can use too much of the context window and end up confusing the model. In fact, the current trend is to go extremely minimal, with something like an “execute shell command” tool and a “make a patch edit to a file” tool<sup id=\"fnref-2\"><a class=\"footnote-ref\" href=\"#fn-2\">2</a></sup>. Any strong LLM can already use a command line to list and read files, make HTTP requests, and so on - if it’s in the training data, you don’t need to take up valuable context space for it.</p>\n<p><strong>Use nested per-chat rule files.</strong> One advantage of agentic tooling is that it’s <em>extremely</em> customizable via natural language instructions. All current AI coding tools take advantage of this, whether via a CLAUDE.md file or a more generic AGENTS.md file. In fact, tools now support nesting these files, so you can have a global AGENTS.md in your home directory with general rules, and one in your repo with repo-specific rules, and one in the <code class=\"language-text\">/auth</code> folder with rules that just pertain to your auth code, and so on. The tool will automatically handle loading the right combination of these files into the context as the agent navigates between folders.</p>\n<p><strong>Make it easy for the user to steer an agent mid-flight.</strong> If your agent is spinning away and you see it doing something wrong or surprising, the user should have a way to interrupt and point the agent in a new direction. Claude Code does this automatically when you send a message, while Codex makes you hit escape to pause the agent’s chain-of-thought first. I think either way works fine - the point is that agents need some way to recover from taking a wrong turn<sup id=\"fnref-3\"><a class=\"footnote-ref\" href=\"#fn-3\">3</a></sup>.</p>\n<p><strong>Make it possible for the user to queue up new commands.</strong> Codex does this when you send new messages. Claude Code doesn’t let you do this, and I think it’s a big mistake. Agents are now good enough to be trusted with small changes, so users should be able to say “when you’re finished, make this tweak” as many times as they want. Queued commands are also useful when you want to force the agent to run for a long time. For instance, when I was trying out Codex on my “five minute LLM” <a href=\"/ai-research-with-codex\">challenge</a>, sometimes I would just queue up ten “Good, please continue” messages if I had to step away for an hour<sup id=\"fnref-4\"><a class=\"footnote-ref\" href=\"#fn-4\">4</a></sup>.</p>\n<p><strong>Support slash commands.</strong> Users are going to interact with your agentic coding tool <em>by typing</em>: at first a description of what they want done, and then various “no, do it like this” or “yes, go on” messages. Agentic tools should thus expose extra functionality as slash commands that the user can type (e.g. to switch model, or to submit a PR, or whatever).</p>\n<p><strong>Use normal search tooling, not RAG.</strong> In the early days of agents, it looked like RAG - chunking a codebase and generating an embedding for each chunk, then using some kind of numerical similarity to identify relevant chunks of the codebase - was going to be the best solution for navigating large codebases<sup id=\"fnref-5\"><a class=\"footnote-ref\" href=\"#fn-5\">5</a></sup>. But that turned out to be dead wrong. Current AI coding tools just let the LLM do string search, which is much more effective (and much easier for the user, since it doesn’t require an slow “embed the entire codebase” step before the agent can start working).</p>\n<p>We are still really early to the world of agentic AI software. There are almost certainly other basic design elements yet to be discovered. Maybe we’ll end up with specialized codebase-searching models like Windsurf’s <a href=\"https://cognition.ai/blog/swe-grep\">SWE-grep</a>. Right now there’s a fairly even split between in-editor tooling and CLI tooling, but eventually one of those might win. I think sub-agents are mostly fluff, but I could be wrong. Better models might still change the game (for instance, by making it more appealing to run an agentic flow without supervision). I personally am missing a “dump your current goal and context into a prompt that I can then paste into a different tool” workflow.</p>\n<p>What other obvious-in-hindsight ideas are we missing?</p>\n<div class=\"footnotes\">\n<hr />\n<ol>\n<li id=\"fn-1\">\n<p>Or other tools that don’t start with “c”.</p>\n<a class=\"footnote-backref\" href=\"#fnref-1\">↩</a>\n</li>\n<li id=\"fn-2\">\n<p>I want to register a prediction that somebody will eventually build a for-LLMs CLI tool that makes sensible patch edits to files, and once that tool gets represented in the training data agents will just use bash commands only.</p>\n<a class=\"footnote-backref\" href=\"#fnref-2\">↩</a>\n</li>\n<li id=\"fn-3\">\n<p>In 2023, I thought that this would require deleting the wrong turn from the agent’s context. Today, I know I was wrong about that: smarter models actually perform better if you leave the mistake in.</p>\n<a class=\"footnote-backref\" href=\"#fnref-3\">↩</a>\n</li>\n<li id=\"fn-4\">\n<p>I wouldn’t do this on an actual codebase (even a hobby project) but it’s a good option for when you’re giving an agentic tool an easily-verifiable research task.</p>\n<a class=\"footnote-backref\" href=\"#fnref-4\">↩</a>\n</li>\n<li id=\"fn-5\">\n<p>In my 2023 experiments, embedding and chunking was way better than just letting the model search. I guess newer models are better at searching.</p>\n<a class=\"footnote-backref\" href=\"#fnref-5\">↩</a>\n</li>\n</ol>\n</div>",
  "id": "https://seangoedecke.com/ideas-in-agentic-ai-tooling/"
}