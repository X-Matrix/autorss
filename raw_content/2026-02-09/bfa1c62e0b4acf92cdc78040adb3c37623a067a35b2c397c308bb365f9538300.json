{
  "title": "Reverse engineering the 386 processor's prefetch queue circuitry",
  "link": "http://www.righto.com/2025/05/386-prefetch-circuitry-reverse-engineered.html",
  "published": "2025-05-09T19:55:00.000-07:00",
  "summary": "<p>In 1985, Intel introduced the groundbreaking 386 processor, the first 32-bit processor in the x86 architecture.\nTo improve performance, the 386 has a 16-byte instruction prefetch queue.\nThe purpose of the prefetch queue is to fetch instructions from memory before they are needed,\nso the processor usually doesn't need to wait on memory while executing instructions.\nInstruction prefetching takes advantage of times when the processor is \"thinking\" and the memory bus would otherwise be unused.</p>\n<p>In this article, I look at the 386's prefetch queue circuitry in detail.\nOne interesting circuit is the incrementer, which adds 1 to a pointer to step through memory.\nThis sounds easy enough, but the incrementer uses complicated circuitry for high performance.\nThe prefetch queue uses a large network\nto shift bytes around so they are properly aligned.\nIt also has a compact circuit to extend signed 8-bit and 16-bit\nnumbers to 32 bits.\nThere aren't any major discoveries in this post, but if you're interested in low-level circuits and dynamic logic, keep reading.</p>\n<p>The photo below shows the 386's shiny fingernail-sized silicon die under a microscope.\nAlthough it may look like an aerial view of a strangely-zoned city, the die photo reveals the functional blocks\nof the chip.\nThe Prefetch Unit in the upper left is the relevant block.\nIn this post, I'll discuss the\nprefetch queue circuitry (highlighted in red), skipping over the prefetch control circuitry to the right.\nThe Prefetch Unit receives data from the Bus Interface Unit (upper right) that communicates with memory.\nThe Instruction Decode Unit receives prefetched instructions from the Prefetch Unit, byte by byte, and decodes the\nopcodes for execution.</p>\n<p><a href=\"https://static.righto.com/images/386-prefetch/386-die-labeled.jpg\"><img alt=\"This die photo of the 386 shows the location of the registers. Click this image (or any other) for a larger version.\" class=\"hilite\" height=\"534\" src=\"https://static.righto.com/images/386-prefetch/386-die-labeled-w500.jpg\" title=\"This die photo of the 386 shows the location of the registers. Click this image (or any other) for a larger version.\" width=\"500\" /></a><div class=\"cite\">This die photo of the 386 shows the location of the registers. Click this image (or any other) for a larger version.</div></p>\n<p>The left quarter of the chip consists of stripes of circuitry that appears much more orderly than the rest of the chip.\nThis grid-like appearance arises because\neach functional block is constructed (for the most part) by repeating the same circuit 32 times, once for each bit, side by side.\nVertical data lines run up and down, in groups of 32 bits, connecting the functional blocks.\nTo make this work, each circuit must fit into the same width on the die; this layout constraint forces the circuit\ndesigners to develop a circuit that uses this width efficiently without exceeding the allowed width.\nThe circuitry for the prefetch queue uses the same approach: each circuit is 66 µm wide<span id=\"fnref:width\"><a class=\"ref\" href=\"#fn:width\">1</a></span> and repeated 32 times.\nAs will be seen, fitting the prefetch circuitry into this fixed width requires some layout tricks.</p>\n<h2>What the prefetcher does</h2>\n<p>The purpose of the prefetch unit is to speed up performance by reading instructions from memory before they are needed,\nso the processor won't need to wait to get instructions from memory.\nPrefetching takes advantage of times when the memory bus is otherwise idle, minimizing conflict with other instructions\nthat are reading or writing data.\nIn the 386, prefetched instructions are stored in a 16-byte queue, consisting of four 32-bit blocks.<span id=\"fnref:cache\"><a class=\"ref\" href=\"#fn:cache\">2</a></span></p>\n<p>The diagram below zooms in on the prefetcher and shows its main components.\nYou can see how the same circuit (in most cases) is repeated 32 times, forming vertical bands.\nAt the top are 32 bus lines from the Bus Interface Unit. These lines provide the connection between the datapath and\nexternal memory, via the Bus Interface Unit.\nThese lines form a triangular pattern as the 32 horizontal lines on the right branch off and form 32 vertical lines, one for each bit.\nNext are the fetch pointer and the limit register, with a circuit to check if the fetch pointer has\nreached the limit.\nNote that the two low-order bits (on the right) of the incrementer and limit check circuit are\nmissing.\nAt the bottom of the incrementer, you can see that some bit positions have a blob of circuitry missing from others,\nbreaking the pattern of repeated blocks.\nThe 16-byte prefetch queue is below the incrementer. Although this memory is the heart of the prefetcher, its\ncircuitry takes up a relatively small area.</p>\n<p><a href=\"https://static.righto.com/images/386-prefetch/prefetcher-labeled.jpg\"><img alt=\"A close-up of the prefetcher with the main blocks labeled. At the right, the prefetcher receives control signals.\" class=\"hilite\" height=\"387\" src=\"https://static.righto.com/images/386-prefetch/prefetcher-labeled-w600.jpg\" title=\"A close-up of the prefetcher with the main blocks labeled. At the right, the prefetcher receives control signals.\" width=\"600\" /></a><div class=\"cite\">A close-up of the prefetcher with the main blocks labeled. At the right, the prefetcher receives control signals.</div></p>\n<p>The bottom part of the prefetcher shifts data to align it as needed.\nA 32-bit value can be split across two 32-bit\nrows of the prefetch buffer.\nTo handle this, the prefetcher includes a data shift network to shift and align its data.\nThis network occupies a lot of space, but there is no active circuitry here: just a grid of horizontal and vertical wires.</p>\n<p>Finally, the sign extend circuitry converts a signed 8-bit or 16-bit value into a signed 16-bit or 32-bit value\nas needed.\nYou can see that the sign extend circuitry is highly irregular, especially in the middle.\nA latch stores the output of the prefetch queue for use by the rest of the datapath.</p>\n<h2>Limit check</h2>\n<p>If you've written x86 programs, you probably know about the processor's Instruction Pointer (EIP) that holds the\naddress of the next instruction to execute.\nAs a program executes, the Instruction Pointer moves from instruction to instruction.\nHowever, it turns out that the Instruction Pointer doesn't actually exist!\nInstead, the 386 has an \"Advance Instruction Fetch Pointer\", which holds the address of the next instruction to\nfetch into the prefetch queue.\nBut sometimes the processor needs to know the Instruction Pointer value, for instance, to determine the return\naddress when calling a subroutine or to compute the destination address of a relative jump.\nSo what happens?\nThe processor gets the Advance Instruction Fetch Pointer address from the prefetch queue circuitry and subtracts\nthe current length of the prefetch queue.\nThe result is the address of the next instruction to execute, the desired Instruction Pointer value.</p>\n<p>The Advance Instruction Fetch Pointer&mdash;the address of the next instruction to prefetch&mdash;is stored\nin a register at the\ntop of the prefetch queue circuitry.\nAs instructions are prefetched, this pointer is incremented by the prefetch circuitry. (Since instructions are fetched 32 bits at a time,\nthis pointer is incremented in steps of four and the bottom two bits are always 0.)</p>\n<p>But what keeps the prefetcher from prefetching too far and going outside the valid memory range?\nThe x86 architecture infamously uses segments to define valid regions of memory.\nA segment has a start and end address (known as the base and limit) and memory is protected by blocking accesses\noutside the segment.\nThe 386 has six active segments; the relevant one is the Code Segment that holds program instructions.\nThus, the limit address of the Code Segment controls when the prefetcher must stop prefetching.<span id=\"fnref:paging\"><a class=\"ref\" href=\"#fn:paging\">3</a></span>\nThe prefetch queue contains a circuit to stop prefetching when the fetch pointer reaches the limit of the Code Segment.\nIn this section, I'll describe that circuit.</p>\n<p>Comparing two values may seem trivial, but the 386 uses a few tricks to make this fast.\nThe basic idea is to use 30 XOR gates to compare the bits of the two registers.\n(Why 30 bits and not 32? Since 32 bits are fetched at a time, the bottom bits of the address are 00 and can be ignored.)\nIf the two registers match, all the XOR values will be 0, but if they don't match, an XOR value will be 1.\nConceptually, connecting the XORs to a 32-input OR gate will yield the desired result:\n0 if all bits match and 1 if there is a mismatch.\nUnfortunately, building a 32-input OR gate using standard CMOS logic is impractical for electrical reasons, as well as\ninconveniently large to fit into the circuit.\nInstead, the 386 uses dynamic logic to implement a spread-out NOR gate with one transistor in each column of the \nprefetcher.</p>\n<p>The schematic below shows the implementation of one bit of the equality comparison.\nThe mechanism is that if the two registers differ, the transistor on the right is turned on, pulling the equality bus low.\nThis circuit is replicated 30 times, comparing all the bits: if there is any mismatch, the equality bus will be pulled\nlow, but if all bits match, the bus remains high.\nThe three gates on the left implement XNOR; this circuit may seem overly complicated, but it is a standard way\nof implementing XNOR.\nThe NOR gate at the right blocks the comparison except during clock phase 2.\n(The importance of this will be explained below.)</p>\n<p><a href=\"https://static.righto.com/images/386-prefetch/equality-logic.jpg\"><img alt=\"This circuit is repeated 30 times to compare the registers.\" class=\"hilite\" height=\"120\" src=\"https://static.righto.com/images/386-prefetch/equality-logic-w500.jpg\" title=\"This circuit is repeated 30 times to compare the registers.\" width=\"500\" /></a><div class=\"cite\">This circuit is repeated 30 times to compare the registers.</div></p>\n<p>The equality bus travels horizontally through the prefetcher, pulled low if any bits don't match.\nBut what pulls the bus high?\nThat's the job of the dynamic circuit below.\nUnlike regular static gates, dynamic logic is controlled by the processor's clock signals and depends on capacitance in the circuit to hold data.\nThe 386 is controlled by a two-phase clock signal.<span id=\"fnref:clock\"><a class=\"ref\" href=\"#fn:clock\">4</a></span>\nIn the first clock phase, the precharge transistor below turns on, pulling the\nequality bus high.\nIn the second clock phase, the XOR circuits above are enabled, pulling the equality bus low if the two registers don't\nmatch.\nMeanwhile, the CMOS switch turns on in clock phase 2, passing the equality bus's value to the latch.\nThe \"keeper\" circuit keeps the equality bus held high unless it is explicitly pulled low, to avoid the risk of\nthe voltage on the equality bus slowly dissipating.\nThe keeper uses a weak transistor to keep the bus high while inactive. But if the bus is pulled low, the\nkeeper transistor is overpowered and turns off.</p>\n<p><a href=\"https://static.righto.com/images/386-prefetch/equality-out.jpg\"><img alt=\"This is the output circuit for the equality comparison.  This circuit is located to the right of the prefetcher.\" class=\"hilite\" height=\"171\" src=\"https://static.righto.com/images/386-prefetch/equality-out-w600.jpg\" title=\"This is the output circuit for the equality comparison.  This circuit is located to the right of the prefetcher.\" width=\"600\" /></a><div class=\"cite\">This is the output circuit for the equality comparison.  This circuit is located to the right of the prefetcher.</div></p>\n<p>This dynamic logic reduces power consumption and circuit size.\nSince the bus is charged and discharged during opposite\nclock phases, you avoid steady current through the transistors.\n(In contrast, an NMOS processor like the 8086 might use a pull-up on the bus.\nWhen the bus is pulled low, would you end up with current flowing through the pull-up and the pull-down transistors.\nThis would increase power consumption, make the chip run hotter, and limit your clock speed.)</p>\n<h2>The incrementer</h2>\n<p>After each prefetch, the Advance Instruction Fetch Pointer must be incremented to hold the address of the next\ninstruction to prefetch.\nIncrementing this pointer is the job of the incrementer.\n(Because each fetch is 32 bits, the pointer is incremented by 4 each time.\nBut in the die photo, you can see a notch in the incrementer and limit check circuit where the circuitry for the\nbottom two bits has been omitted.\nThus, the incrementer's circuitry increments its value by 1, so the pointer (with two zero bits appended)\nincreases in steps of 4.)</p>\n<p>Building an incrementer circuit is straightforward, for example, you can use a chain of 30 half-adders.\nThe problem is that incrementing a 30-bit value at high speed is difficult because of the carries from one position to the next.\nIt's similar to calculating 99999999 + 1 in decimal; you need to tediously carry the 1, carry the 1, carry the 1, and so forth,\nthrough all the digits, resulting in a slow, sequential process.</p>\n<p>The incrementer uses a faster approach. First, it computes all the carries at high speed, almost in parallel.\nThen it computes each output bit in parallel from the carries&mdash;if there is a carry into a position, it toggles that bit.</p>\n<p>Computing the carries is straightforward in concept: if there is a block of 1 bits at the end of the value,\nall those bits will\nproduce carries, but carrying is stopped by the rightmost 0 bit.\nFor instance, incrementing binary 11011 results in 11100; there are carries from the last two bits, but the zero\nstops the carries.\nA circuit to implement this was developed at the University of Manchester in England way back in 1959, and is known as the Manchester\ncarry chain.</p>\n<p>In the Manchester carry chain, you build a chain of switches, one for each data bit, as shown below.\nFor a 1 bit, you close the switch, but for a 0 bit you open the switch.\n(The switches are implemented by transistors.)\nTo compute the carries, you start by feeding in a carry signal at the right\nThe signal will go through the closed switches\nuntil it hits an open switch, and then it will be blocked.<span id=\"fnref:manchester\"><a class=\"ref\" href=\"#fn:manchester\">5</a></span>\nThe outputs along the chain give us the desired carry value at each position.</p>\n<p><a href=\"https://static.righto.com/images/386-prefetch/chain.jpg\"><img alt=\"Concept of the Manchester carry chain, 4 bits.\" class=\"hilite\" height=\"149\" src=\"https://static.righto.com/images/386-prefetch/chain-w500.jpg\" title=\"Concept of the Manchester carry chain, 4 bits.\" width=\"500\" /></a><div class=\"cite\">Concept of the Manchester carry chain, 4 bits.</div></p>\n<p>Since the switches in the Manchester carry chain can all be set in parallel and the carry signal blasts through\nthe switches at high speed, this circuit rapidly computes the carries we need.\nThe carries then flip the associated bits (in parallel), giving us the result much faster than a straightforward adder.</p>\n<p>There are complications, of course, in the actual implementation.\nThe carry signal in the carry chain is inverted, so a low signal propagates through the carry chain to indicate a carry.\n(It is faster to pull a signal low than high.)\nBut <em>something</em> needs to make the line go high when necessary.\nAs with the equality circuitry, the solution is dynamic logic.\nThat is, the carry line is precharged high during one clock phase and then processing happens in the\nsecond clock phase, potentially pulling the line low.</p>\n<p>The next problem is that the carry signal weakens as it passes through multiple transistors and long\nlengths of wire. \nThe solution is that each segment has a circuit to amplify the signal, using a clocked inverter and an asymmetrical\ninverter.\nImportantly, this amplifier is not in the carry chain path, so it doesn't slow down the signal through the chain.</p>\n<p><a href=\"https://static.righto.com/images/386-prefetch/chain-circuit.jpg\"><img alt=\"The Manchester carry chain circuit for a typical bit in the incrementer.\" class=\"hilite\" height=\"275\" src=\"https://static.righto.com/images/386-prefetch/chain-circuit-w500.jpg\" title=\"The Manchester carry chain circuit for a typical bit in the incrementer.\" width=\"500\" /></a><div class=\"cite\">The Manchester carry chain circuit for a typical bit in the incrementer.</div></p>\n<p>The schematic above shows the implementation of the Manchester carry chain for a typical bit.\nThe chain itself is at the bottom, with the transistor switch as before.\nDuring clock phase 1,\nthe precharge transistor pulls this segment of the carry chain high.\nDuring clock phase 2, the signal on the chain goes through the \"clocked inverter\" at the right to produce the local carry signal.\nIf there is a carry, the next bit is flipped by the XOR gate, producing the incremented output.<span id=\"fnref:xor\"><a class=\"ref\" href=\"#fn:xor\">6</a></span>\nThe \"keeper/amplifier\" is an asymmetrical inverter that produces a strong low output but a weak high output.\nWhen there is no carry, its weak output keeps the carry chain pulled high.\nBut as soon as a carry is detected, it strongly pulls the carry chain low to boost the carry signal.</p>\n<p>But this circuit still isn't enough for the desired performance. The incrementer uses a second carry technique in parallel:\ncarry skip.\nThe concept is to look at blocks of bits and allow the carry to jump over the entire block.\nThe diagram below shows a simplified implementation of the carry skip circuit. Each block consists of 3 to 6 bits.\nIf all the bits in a block are 1's, then the AND gate turns on the associated transistor in the carry skip line.\nThis allows the carry skip signal to propagate (from left to right), a block at a time. When it reaches a block with a\n0 bit, the corresponding transistor will be off, stopping the carry as in the Manchester carry chain.\nThe AND gates all operate in parallel, so the transistors are rapidly turned on or off in parallel.\nThen, the carry skip signal passes through a small number of transistors, without going through any logic.\n(The carry skip signal is like an express train that skips most stations, while the Manchester carry chain\nis the local train to all the stations.)\nLike the Manchester carry chain, the implementation of carry skip needs precharge\ncircuits on the lines, a keeper/amplifier, and clocked logic, but I'll skip the details.</p>\n<p><a href=\"https://static.righto.com/images/386-prefetch/carry-skip.jpg\"><img alt=\"An abstracted and simplified carry-skip circuit. The block sizes don't match the 386's circuit.\" class=\"hilite\" height=\"133\" src=\"https://static.righto.com/images/386-prefetch/carry-skip-w600.jpg\" title=\"An abstracted and simplified carry-skip circuit. The block sizes don't match the 386's circuit.\" width=\"600\" /></a><div class=\"cite\">An abstracted and simplified carry-skip circuit. The block sizes don't match the 386's circuit.</div></p>\n<p>One interesting feature is the layout of the large AND gates.\nA 6-input AND gate is a large device, difficult to fit into one cell of the incrementer.\nThe solution is that the gate is spread out across multiple cells.\nSpecifically, the gate uses a standard CMOS NAND gate circuit with NMOS transistors in series and PMOS transistors\nin parallel.\nEach cell has an NMOS transistor and a PMOS transistor, and the chains are connected at the end to form the desired\nNAND gate. (Inverting the output produces the desired AND function.)\nThis spread-out layout technique is unusual, but keeps each bit's circuitry approximately the same size.</p>\n<p>The incrementer circuitry was tricky to reverse engineer because of these techniques.\nIn particular, \nmost of the prefetcher consists of a single block of circuitry repeated 32 times, once for each bit.\nThe incrementer, on the other hand, consists of <em>four</em> different blocks of circuitry, repeating in an irregular pattern.\nSpecifically, one block starts a carry chain, a second block continues the carry chain, and a third block ends\na carry chain.\nThe block before the ending block is different (one large transistor to drive the last block), making four variants in\ntotal.\nThis irregular pattern is visible in the earlier photo of the prefetcher.</p>\n<h2>The alignment network</h2>\n<p>The bottom part of the prefetcher rotates data to align it as needed.\nUnlike some processors, the x86 does not enforce aligned memory accesses.\nThat is, a 32-bit value does not need to start on a 4-byte boundary in memory.\nAs a result, a 32-bit value may be split across two 32-bit rows of the prefetch queue.\nMoreover, when the instruction decoder fetches one byte of an instruction, that byte may be at any position in the prefetch queue.</p>\n<p>To deal with these problems, the prefetcher includes an alignment network that can rotate bytes to output a byte, word, or four bytes with the alignment required by the rest of the processor.</p>\n<p>The diagram below shows part of this alignment network.\nEach bit exiting the prefetch queue (top) has four wires, for rotates of 24, 16, 8, or 0 bits.\nEach rotate wire is connected to one of the 32 horizontal bit lines.\nFinally, each horizontal bit line has an output tap, going to the datapath below.\n(The vertical lines are in the chip's lower M1 metal layer, while the horizontal lines are in the upper M2 metal layer.\nFor this photo, I removed the M2 layer to show the underlying layer.\nShadows of the original horizontal lines are still visible.)</p>\n<p><a href=\"https://static.righto.com/images/386-prefetch/alignment-network.jpg\"><img alt=\"Part of the alignment network.\" class=\"hilite\" height=\"411\" src=\"https://static.righto.com/images/386-prefetch/alignment-network-w600.jpg\" title=\"Part of the alignment network.\" width=\"600\" /></a><div class=\"cite\">Part of the alignment network.</div></p>\n<p>The idea is that by selecting one set of vertical rotate lines, the 32-bit output from the prefetch queue will be\nrotated left by that amount.\nFor instance, to rotate by 8, bits are sent down the \"rotate 8\" lines. Bit 0 from the prefetch queue will energize\nhorizontal line 8, bit 1 will energize horizontal line 9, and so forth, with bit 31 wrapping around to horizontal line 7. Since horizontal bit line 8 is connected to\noutput 8, the result is that bit 0 is output as bit 8, bit 1 is output as bit 9, and so forth.</p>\n<p><a href=\"https://static.righto.com/images/386-prefetch/alignment-diagram.jpg\"><img alt=\"The four possibilities for aligning a 32-bit value. The four bytes above are shifted as specified to produce the desired output below.\" class=\"hilite\" height=\"115\" src=\"https://static.righto.com/images/386-prefetch/alignment-diagram-w500.jpg\" title=\"The four possibilities for aligning a 32-bit value. The four bytes above are shifted as specified to produce the desired output below.\" width=\"500\" /></a><div class=\"cite\">The four possibilities for aligning a 32-bit value. The four bytes above are shifted as specified to produce the desired output below.</div></p>\n<p>For the alignment process,\none 32-bit output may be split across two 32-bit entries in the prefetch queue in four different ways, as shown above.\nThese combinations are implemented by multiplexers and drivers.\nTwo 32-bit multiplexers select the two relevant rows in the prefetch queue (blue and green above).\nFour 32-bit drivers are connected to the four sets of vertical lines, with one set of drivers activated to\nproduce the desired shift.\nEach byte of each driver is wired to achieve the alignment shown above. For instance, the rotate-8 driver gets\nits top byte from the \"green\" multiplexer and the other three bytes from the \"blue\" multiplexer.\nThe result is that the four bytes, split across two queue rows, are rotated to form an aligned 32-bit value.</p>\n<h2>Sign extension</h2>\n<p>The final circuit is sign extension. Suppose you want to add an 8-bit value to a 32-bit value.\nAn unsigned 8-bit value can be extended to 32 bits by simply filling the upper bits with zeroes.\nBut for a signed value, it's trickier. For instance, -1 is the eight-bit value 0xFF, but the 32-bit value is\n0xFFFFFFFF.\nTo convert an 8-bit signed value to 32 bits, the top 24 bits must be filled in with the top bit of the original\nvalue (which indicates the sign).\nIn other words, for a positive value, the extra bits are filled with 0, but for a negative value, the extra bits are\nfilled with 1.\nThis process is called sign extension.<span id=\"fnref:sex\"><a class=\"ref\" href=\"#fn:sex\">9</a></span></p>\n<p>In the 386, a circuit at the bottom of the prefetcher performs sign extension for values in instructions.\nThis circuit supports extending an 8-bit value to 16 bits or 32 bits, as well as extending a 16-bit value to 32 bits.\nThis circuit will extend a value with zeros or with the sign, depending on the instruction.</p>\n<p>The schematic below shows one bit of this sign extension circuit. It consists of a latch on the left and right, with a\nmultiplexer in the middle.\nThe latches are constructed with a standard 386 circuit using a CMOS switch (see footnote).<span id=\"fnref:latch\"><a class=\"ref\" href=\"#fn:latch\">7</a></span>\nThe multiplexer selects one of three values: the bit value from the swap network, 0 for sign extension, or 1 for\nsign extension.\nThe multiplexer is constructed from a CMOS switch if the bit value is selected and two transistors for the 0 or 1 values.\nThis circuit is replicated 32 times, although the bottom byte only has the latches, not the multiplexer, as\nsign extension does not modify the bottom byte.</p>\n<p><a href=\"https://static.righto.com/images/386-prefetch/sign-extend-circuit.jpg\"><img alt=\"The sign extend circuit associated with bits 31-8 from the prefetcher.\" class=\"hilite\" height=\"195\" src=\"https://static.righto.com/images/386-prefetch/sign-extend-circuit-w600.jpg\" title=\"The sign extend circuit associated with bits 31-8 from the prefetcher.\" width=\"600\" /></a><div class=\"cite\">The sign extend circuit associated with bits 31-8 from the prefetcher.</div></p>\n<p>The second part of the sign extension circuitry determines if the bits should be filled with 0 or 1 and sends the control\nsignals to the circuit above.\nThe gates on the left determine if the sign extension bit should be a 0 or a 1. For a 16-bit sign extension, this\nbit comes from bit 15 of the data, while for an 8-bit sign extension, the bit comes from bit 7.\nThe four gates on the right generate the signals to sign extend each bit, producing separate signals for the\nbit range 31-16 and the range 15-8.</p>\n<p><a href=\"https://static.righto.com/images/386-prefetch/sign-extend-logic.jpg\"><img alt=\"This circuit determines which bits should be filled with 0 or 1.\" class=\"hilite\" height=\"165\" src=\"https://static.righto.com/images/386-prefetch/sign-extend-logic-w500.jpg\" title=\"This circuit determines which bits should be filled with 0 or 1.\" width=\"500\" /></a><div class=\"cite\">This circuit determines which bits should be filled with 0 or 1.</div></p>\n<p>The layout of this circuit on the die is somewhat unusual.\nMost of the prefetcher circuitry consists of 32 identical columns, one for each bit.<span id=\"fnref:extension\"><a class=\"ref\" href=\"#fn:extension\">8</a></span>\nThe circuitry above is implemented once, using about 16 gates (buffers and inverters are not shown above).\nDespite this, the circuitry above is crammed into bit positions 17 through 7, creating irregularities in the layout.\nMoreover, the implementation of the circuitry in silicon is unusual compared to the rest of the 386.\nMost of the 386's circuitry uses the two metal layers for interconnection, minimizing the use of polysilicon wiring.\nHowever, the circuit above also uses long stretches of polysilicon to connect the gates.</p>\n<p><a href=\"https://static.righto.com/images/386-prefetch/sign-extension-layout.jpg\"><img alt=\"Layout of the sign extension circuitry. This circuitry is at the bottom of the prefetch queue.\" class=\"hilite\" height=\"165\" src=\"https://static.righto.com/images/386-prefetch/sign-extension-layout-w600.jpg\" title=\"Layout of the sign extension circuitry. This circuitry is at the bottom of the prefetch queue.\" width=\"600\" /></a><div class=\"cite\">Layout of the sign extension circuitry. This circuitry is at the bottom of the prefetch queue.</div></p>\n<p>The diagram above shows the irregular layout of the sign extension circuitry amid the regular datapath circuitry that\nis 32 bits wide.\nThe sign extension circuitry is shown in green; this is the circuitry described at the top of this section, repeated\nfor each bit 31-8.\nThe circuitry for bits 15-8 has been shifted upward, perhaps to make room for the sign extension control circuitry,\nindicated in red.\nNote that the layout of the control circuitry is completely irregular, since there is one copy of the circuitry and\nit has no internal structure.\nOne consequence of this layout is the wasted space to the left and right of this circuitry block, the\ntan regions with no circuitry except vertical metal lines passing through.\nAt the far right, a block of circuitry to control the latches has been wedged under bit 0.\nIntel's designers go to great effort to minimize the size of the processor die since a smaller die saves substantial\nmoney.\nThis layout must have been the most efficient they could manage, but I find it aesthetically displeasing compared\nto the regularity of the rest of the datapath.</p>\n<h2>How instructions flow through the chip</h2>\n<p>Instructions follow a tortuous path through the 386 chip.\nFirst, \nthe Bus Interface Unit in the upper right\ncorner reads instructions from memory and sends them over a 32-bit bus (blue) to the prefetch unit.\nThe prefetch unit stores the instructions in the 16-byte prefetch queue.</p>\n<p><a href=\"https://static.righto.com/images/386-prefetch/386-instr-labeled.jpg\"><img alt=\"Instructions follow a twisting path to and from the prefetch queue.\" class=\"hilite\" height=\"641\" src=\"https://static.righto.com/images/386-prefetch/386-instr-labeled-w600.jpg\" title=\"Instructions follow a twisting path to and from the prefetch queue.\" width=\"600\" /></a><div class=\"cite\">Instructions follow a twisting path to and from the prefetch queue.</div></p>\n<p>How is an instruction executed from the prefetch queue? It turns out that there are two distinct paths.\nSuppose you're executing an instruction to add 12345678 to the EAX register.\nThe prefetch queue will hold the five bytes 05 (the opcode), 78, 56, 34, and 12.\nThe prefetch queue provides opcodes to the decoder one byte at a time over the 8-bit bus shown in red.\nThe bus takes the lowest 8 bits from the prefetch queue's alignment network and sends this byte to a buffer\n(the small square at the head of the red arrow).\nFrom there, the opcode travels to the instruction decoder.<span id=\"fnref:decoder\"><a class=\"ref\" href=\"#fn:decoder\">10</a></span>\nThe instruction decoder, in turn, uses large tables (PLAs) to convert the x86 instruction into a 111-bit internal format\nwith 19 different fields.<span id=\"fnref:slager\"><a class=\"ref\" href=\"#fn:slager\">11</a></span></p>\n<p>The data bytes of an instruction, on the other hand, go from the prefetch queue to the ALU (Arithmetic Logic Unit) through a 32-bit data bus (orange).\nUnlike the previous buses, this data bus is spread out, with one wire through each column of the datapath.\nThis bus extends through the entire datapath so values can also be stored into registers.\nFor instance,\nthe <code>MOV</code> (move) instruction can store a value from an instruction (an \"immediate\" value) into a register.</p>\n<h2>Conclusions</h2>\n<p>The 386's prefetch queue contains about 7400 transistors, more than an Intel 8080 processor.\n(And this is just the queue itself; I'm ignoring the prefetch control logic.)\nThis illustrates the rapid advance of processor technology: part of one functional unit in the 386 contains more\ntransistors than an entire 8080 processor from 11 years earlier.\nAnd this unit is less than 3% of the entire 386 processor.</p>\n<!-- about 230 transistors per column -->\n\n<p>Every time I look at an x86 circuit, I see the complexity required to support backward compatibility, and\nI gain more understanding of why RISC became popular.\nThe prefetcher is no exception.\nMuch of the complexity is due to the 386's support for unaligned memory accesses, requiring a byte shift network to\nmove bytes into 32-bit alignment.\nMoreover, at the other end of the instruction bus is the complicated instruction decoder that decodes\nintricate x86 instructions. Decoding RISC instructions is much easier.</p>\n<p>In any case, I hope you've found this look at the prefetch circuitry interesting.\nI plan to write more about the 386, so\nfollow me on Bluesky (<a href=\"https://bsky.app/profile/righto.com\">@righto.com</a>) or <a href=\"https://www.righto.com/feeds/posts/default\">RSS</a> for updates.\nI've written multiple articles on the 386 previously; a good place to start might be my <a href=\"https://www.righto.com/2023/10/intel-386-die-versions.html\">survey of the 368 dies</a>.</p>\n<h2>Footnotes and references</h2>\n<div class=\"footnote\">\n<ol>\n<li id=\"fn:width\">\n<p>The width of the circuitry for one bit changes a few times: while the prefetch queue and segment descriptor cache\nuse a circuit that is 66 µm wide, the datapath circuitry is a bit tighter at 60 µm. The barrel shifter is even\nnarrower at 54.5 µm per bit.\nConnecting circuits with different widths wastes space, since the wiring to connect the bits requires horizontal\nsegments to adjust the spacing.\nBut it also wastes space to use widths that are wider than needed.\nThus, changes in the spacing are rare, where the tradeoffs make it worthwhile.&#160;<a class=\"footnote-backref\" href=\"#fnref:width\" title=\"Jump back to footnote 1 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:cache\">\n<p>The Intel 8086 processor had a six-byte prefetch queue, while the Intel 8088 (used in the original IBM PC) had a\nprefetch queue of just four bytes.\nIn comparison, the 16-byte queue of the 386 seems luxurious.\n(Some 386 processors, however, are <a href=\"https://www.rcollins.org/secrets/PrefetchQueue.html\">said</a> to only use 12 bytes\ndue to a bug.)</p>\n<p>The prefetch queue assumes instructions are executed in linear order, so it doesn't help with branches or loops.\nIf the processor encounters a branch, the prefetch queue is discarded.\n(In contrast, a modern cache will work even if execution jumps around.)\nMoreover, the prefetch queue doesn't handle self-modifying code.\n(It used to be common for code to change itself while executing to squeeze out extra performance.)\nBy loading code into the prefetch queue and then modifying instructions,\nyou could determine the size of the prefetch queue: if the old instruction was executed, it must be in the\nprefetch queue, but if the modified instruction was executed, it must be outside the prefetch queue.\nStarting with the <a href=\"https://stackoverflow.com/questions/17395557/observing-stale-instruction-fetching-on-x86-with-self-modifying-code\">Pentium Pro</a>, x86 processors flush the prefetch queue if a write modifies a prefetched\ninstruction.&#160;<a class=\"footnote-backref\" href=\"#fnref:cache\" title=\"Jump back to footnote 2 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:paging\">\n<p>The prefetch unit generates \"linear\" addresses that must be translated to physical addresses by the paging unit\n(<a href=\"http://doi.org/10.1109/MM.1985.304507\">ref</a>).&#160;<a class=\"footnote-backref\" href=\"#fnref:paging\" title=\"Jump back to footnote 3 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:clock\">\n<p>I don't know which phase of the clock is phase 1 and which is phase 2, so I've assigned the numbers\narbitrarily.\nThe 386 creates four clock signals internally from a clock input <code>CLK2</code> that runs at twice the processor's clock\nspeed.\nThe 386 generates a two-phase clock with non-overlapping phases. \nThat is, there is a small gap between when the first phase is high and when the second phase is high.\nThe 386's circuitry is controlled by the clock, with alternate blocks controlled by alternate phases.\nSince the clock phases don't overlap, this ensures that logic blocks are activated in sequence, allowing the\norderly flow of data.\nBut because the 386 uses CMOS, it also needs active-low clocks for the PMOS transistors.\nYou might think that you could simply use the phase 1 clock as the active-low phase 2 clock and vice versa.\nThe problem is that these clock phases overlap when used as active-low; there are times when both clock signals are low.\nThus, the two clock phases must be explicitly inverted to produce the two active-low clock phases.\nI described the 386's clock generation circuitry in detail in <a href=\"https://www.righto.com/2023/11/intel-386-clock-circuit.html\">this article</a>.&#160;<a class=\"footnote-backref\" href=\"#fnref:clock\" title=\"Jump back to footnote 4 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:manchester\">\n<p>The Manchester carry chain is typically used in an adder, which makes it more complicated than shown here.\nIn particular,\na new carry can be generated when two 1 bits are added. Since we're looking at an incrementer, this case\ncan be ignored.</p>\n<p>The Manchester carry chain was first described in <a href=\"https://doi.org/10.1049/pi-b-2.1959.0316\">Parallel addition in digital computers: a new fast ‘carry’ circuit</a>.\nIt was developed at the University of Manchester in 1959 and used in the Atlas supercomputer.&#160;<a class=\"footnote-backref\" href=\"#fnref:manchester\" title=\"Jump back to footnote 5 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:xor\">\n<p>For some reason, the incrementer uses a completely different XOR circuit from the comparator, built from\na multiplexer instead of logic.\nIn the circuit below, the two CMOS switches form a multiplexer: if the first input is 1, the top switch turns on,\nwhile if the first input is a 0, the bottom switch turns on.\nThus, if the first input is a 1, the second input passes through and then is inverted to form the output.\nBut if the first input is a 0, the second input is inverted before the switch and then is inverted again to\nform the output.\nThus, the second input is inverted if the first input is 1, which is a description of XOR.</p>\n<p><a href=\"https://static.righto.com/images/386-prefetch/xor.jpg\"><img alt=\"The implementation of an XOR gate in the incrementer.\" class=\"hilite\" height=\"249\" src=\"https://static.righto.com/images/386-prefetch/xor-w400.jpg\" title=\"The implementation of an XOR gate in the incrementer.\" width=\"400\" /></a><div class=\"cite\">The implementation of an XOR gate in the incrementer.</div></p>\n<p>I don't see any clear reason why two different XOR circuits were used in different parts of the prefetcher.\nPerhaps the available space for the layout made a difference. Or maybe the different circuits have different\ntiming or output current characteristics. Or it could just be the personal preference of the designers.&#160;<a class=\"footnote-backref\" href=\"#fnref:xor\" title=\"Jump back to footnote 6 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:latch\">\n<p>The latch circuit is based on a CMOS switch (or transmission gate) and a weak inverter.\nNormally, the inverter loop holds the bit.\nHowever, if the CMOS switch is enabled, its output overpowers the signal from the weak inverter,\nforcing the inverter loop into the desired state.</p>\n<p>The CMOS switch consists of an NMOS transistor and a PMOS transistor in parallel.\nBy setting the top control input high and the bottom control input low, both transistors turn on, allowing the\nsignal to pass through the switch.\nConversely, by setting the top input low and the bottom input high, both transistors turn off, blocking the signal.\nCMOS switches are used extensively in the 386, to form multiplexers, create latches, and implement XOR.&#160;<a class=\"footnote-backref\" href=\"#fnref:latch\" title=\"Jump back to footnote 7 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:extension\">\n<p>Most of the 386's control circuitry is to the right of the datapath, rather than awkwardly wedged into the datapath.\nSo why is this circuit different?\nMy hypothesis is that since the circuit needs the values of bit 15 and bit 7, it made sense to put the circuitry next\nto bits 15 and 7; if this control circuitry were off to the right, long wires would need to run from bits 15 and 7\nto the circuitry.&#160;<a class=\"footnote-backref\" href=\"#fnref:extension\" title=\"Jump back to footnote 8 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:sex\">\n<p>In case this post is getting tedious, I'll provide a lighter footnote on sign extension.\nThe obvious mnemonic for a sign extension instruction is <code>SEX</code>, but that mnemonic was too risque for Intel.\nThe Motorola <a href=\"https://colorcomputerarchive.com/repo/Documents/Books/Motorola%206809%20and%20Hitachi%206309%20Programming%20Reference%20(Darren%20Atkinson).pdf\">6809</a> processor (1978) used this mnemonic, as did the related\n<a href=\"http://www.bitsavers.org/components/motorola/68HC12/Motorola_68HC12_Reference_Manual_1996.pdf#page=41\">68HC12</a> microcontroller (1996).\nHowever, Steve Morse, architect of the 8086, <a href=\"https://archive.org/details/80868088primerin0002mors/page/54/mode/1up\">stated</a> that the sign extension instructions on the 8086 were initially\nnamed <code>SEX</code> but were renamed before release to the more conservative <code>CBW</code> and <code>CWD</code> (Convert Byte to Word and Convert Word to Double word).</p>\n<p>The DEC PDP-11 was a bit contradictory. It has a sign extend instruction with the mnemonic <code>SXT</code>;\nthe <a href=\"http://www.catb.org/jargon/html/S/SEX.html\">Jargon File</a> claims that DEC engineers almost got <code>SEX</code> as the\nassembler mnemonic, but marketing forced the change.\nOn the other hand,\n<code>SEX</code> was the official abbreviation for Sign Extend\n(see <a href=\"http://www.bitsavers.org/pdf/dec/pdp11/handbooks/DEC-11-HR6A-D_PDP-11_Conventions_197009.pdf#page=36\">PDP-11 Conventions Manual</a>, <a href=\"http://www.bitsavers.org/www.computer.museum.uq.edu.au/pdf/DEC-11-XPTSA-B-D%20PDP-11%20Paper%20Tape%20Software%20Handbook.pdf#page=252\">PDP-11 Paper Tape Software Handbook</a>) and\n<code>SEX</code> was used in the <a href=\"http://www.bitsavers.org/www.computer.museum.uq.edu.au/pdf/DEC-11-H05AA-B-D%20PDP-11-05,%2011-10%20Computer%20Manual.pdf#page=139\">microcode</a> for sign extend.</p>\n<p>RCA's CDP1802 processor (1976) may have been the first with a <code>SEX</code> instruction, using the mnemonic <code>SEX</code> for the unrelated <a href=\"https://bitsavers.trailing-edge.com/components/rca/cosmac/MPM-201A_User_Manual_for_the_CDP1802_COSMAC_Microprocessor_1976.pdf#page=40\">Set X</a> instruction.\nSee also this <a href=\"https://retrocomputing.stackexchange.com/questions/7962/when-did-intel-undergo-the-sex-change\">Retrocomputing Stack Exchange page</a>.&#160;<a class=\"footnote-backref\" href=\"#fnref:sex\" title=\"Jump back to footnote 9 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:decoder\">\n<p>It seems inconvenient to send instructions all the way across the chip from the Bus Interface Unit to the prefetch\nqueue and then back across to the chip to the instruction decoder, which is next to the Bus Interface Unit.\nBut this was probably the best alternative for the layout, since you can't put everything close to everything.\nThe 32-bit datapath circuitry is on the left, organized into 32 columns. It would be nice to put the Bus Interface\nUnit other there too, but there isn't room, so you end up with the wide 32-bit data bus going across the chip.\nSending instruction bytes across the chip is less of an impact, since the instruction bus is just 8 bits wide.&#160;<a class=\"footnote-backref\" href=\"#fnref:decoder\" title=\"Jump back to footnote 10 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:slager\">\n<p>See \"Performance Optimizations of the 80386\", Slager, Oct 1986, in Proceedings of ICCD, pages 165-168.&#160;<a class=\"footnote-backref\" href=\"#fnref:slager\" title=\"Jump back to footnote 11 in the text\">&#8617;</a></p>\n</li>\n</ol>\n</div>",
  "id": "tag:blogger.com,1999:blog-6264947694886887540.post-6792624295909344732"
}