{
  "title": "The GDB JIT interface",
  "link": "https://bernsteinbear.com/blog/gdb-jit/?utm_source=rss",
  "published": "Tue, 30 Dec 2025 00:00:00 +0000",
  "summary": "<p>GDB is great for stepping through machine code to figure out what is going on.\nIt uses debug information under the hood to present you with a tidy backtrace\nand also determine how much machine code to print when you type <code class=\"language-plaintext highlighter-rouge\">disassemble</code>.</p>\n\n<p>This debug information comes from your compiler. Clang, GCC, rustc, etc all\nproduce debug data in a format called <a href=\"https://dwarfstd.org/\">DWARF</a> and then embed that debug\ninformation inside the binary (ELF, Mach-O, …) when you do <code class=\"language-plaintext highlighter-rouge\">-ggdb</code> or\nequivalent.</p>\n\n<p>Unfortunately, this means that by default, GDB has no idea what is going on if\nyou break in a JIT-compiled function. You can step instruction-by-instruction\nand whatnot, but that’s about it. This is because the current instruction\npointer is nowhere to be found in any of the existing debug info tables from\nthe host runtime code, so your terminal is filled with <code class=\"language-plaintext highlighter-rouge\">???</code>. See this example\nfrom the V8 docs:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>#8  0x08281674 in v8::internal::Runtime_SetProperty (args=...) at src/runtime.cc:3758\n#9  0xf5cae28e in ?? ()\n#10 0xf5cc3a0a in ?? ()\n#11 0xf5cc38f4 in ?? ()\n#12 0xf5cbef19 in ?? ()\n#13 0xf5cb09a2 in ?? ()\n#14 0x0809e0a5 in v8::internal::Invoke (...) at src/execution.cc:97\n</code></pre></div></div>\n\n<p>Fortunately, there is a <em>JIT interface</em> to GDB. If you implement a couple of\nfunctions in your JIT and run them every time you finish compiling a function,\nyou can get the debugging niceties for your JIT code too. See again a V8\nexample:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>#6  0x082857fc in v8::internal::Runtime_SetProperty (args=...) at src/runtime.cc:3758\n#7  0xf5cae28e in ?? ()\n#8  0xf5cc3a0a in loop () at test.js:6\n#9  0xf5cc38f4 in test.js () at test.js:13\n#10 0xf5cbef19 in ?? ()\n#11 0xf5cb09a2 in ?? ()\n#12 0x0809e1f9 in v8::internal::Invoke (...) at src/execution.cc:97\n</code></pre></div></div>\n\n<p>Unfortunately, the GDB docs are <a href=\"https://sourceware.org/gdb/current/onlinedocs/gdb.html/JIT-Interface.html\">somewhat sparse</a>. So I went\nspelunking through a bunch of different projects to try and understand what is\ngoing on.</p>\n\n<h2 id=\"the-big-picture-and-the-old-interface\">The big picture (and the old interface)</h2>\n\n<p>GDB expects your runtime to expose a function called\n<code class=\"language-plaintext highlighter-rouge\">__jit_debug_register_code</code> and a global variable called\n<code class=\"language-plaintext highlighter-rouge\">__jit_debug_descriptor</code>. GDB automatically adds its own internal breakpoints\nat this function, if it exists. Then, when you compile code, you call this\nfunction from your runtime.</p>\n\n<p>In slightly more detail:</p>\n\n<ol>\n  <li>Compile a function in your JIT compiler. This gives you a function name,\nmaybe other metadata, an executable code address, and a code size</li>\n  <li>Generate an <em>entire</em> ELF/Mach-O/… object in-memory (!) for that one\nfunction, describing its name, code region, maybe other DWARF metadata such\nas line number maps</li>\n  <li>Write a <code class=\"language-plaintext highlighter-rouge\">jit_code_entry</code> linked list node that points at your object\n(“symfile”)</li>\n  <li>Link it into the <code class=\"language-plaintext highlighter-rouge\">__jit_debug_descriptor</code> linked list</li>\n  <li>Call <code class=\"language-plaintext highlighter-rouge\">__jit_debug_register_code</code>, which gives GDB control of the process so it can\npick up the new function’s metadata</li>\n  <li>Optionally, break into (or crash inside) one of your JITed functions</li>\n  <li>At some point, later, when your function gets GCed, unregister your code by\nediting the linked list and calling <code class=\"language-plaintext highlighter-rouge\">__jit_debug_register_code</code> again</li>\n</ol>\n\n<p>This is why you see compiler projects such as V8 including large swaths of code\njust to make object files:</p>\n\n<ul>\n  <li><a href=\"https://github.com/v8/v8/blob/5668ed57de1c7c8dd5c3dc1598bf071e17d29c8c/src/diagnostics/gdb-jit.cc\">V8</a></li>\n  <li><a href=\"https://github.com/facebookincubator/cinderx/blob/e6e925b20e6fa3fe1e100f147e1c8cd03076ebfb/cinderx/Jit/jit_gdb_support.cpp\">Cinder</a></li>\n  <li><a href=\"https://github.com/zendtech/php-src/blob/f82e5b3abe1ff1d3ffc7954b0810bc584fd650a5/ext/opcache/jit/zend_jit_gdb.c#L473\">Zend PHP</a></li>\n  <li><a href=\"https://github.com/dotnet/runtime/blob/3c040478f19e0f317790acab05dbe3ada9f52dc4/src/coreclr/vm/gdbjit.cpp\">CoreCLR/.NET</a></li>\n  <li><a href=\"https://github.com/qemu/qemu/blob/942b0d378a1de9649085ad6db5306d5b8cef3591/tcg/tcg.c#L7064\">QEMU</a></li>\n  <li><a href=\"https://github.com/WebKit/WebKit/blob/0afc2a867ab45651ac6c353c7b6ade5482b7bba7/Source/JavaScriptCore/jit/GdbJIT.cpp\">JavaScriptCore</a></li>\n  <li><a href=\"https://github.com/LuaJIT/LuaJIT/blob/7152e15489d2077cd299ee23e3d51a4c599ab14f/src/lj_gdbjit.c\">LuaJIT</a></li>\n  <li><a href=\"https://github.com/LineageOS/android_art/blob/8ce603e0c68899bdfbc9cd4c50dcc65bbf777982/runtime/jit/debugger_interface.cc#L187\">ART</a>\n    <ul>\n      <li>which looks like it does something smart about grouping the JIT code\nentries together (<code class=\"language-plaintext highlighter-rouge\">RepackEntries</code>), but I’m not sure exactly what it does</li>\n    </ul>\n  </li>\n  <li><a href=\"https://github.com/facebook/hhvm/blob/b1c47dcfbc574b508fd084f27ba4a06bcf4ba188/hphp/runtime/vm/debug/elfwriter.cpp#L622\">HHVM</a></li>\n  <li><a href=\"https://github.com/TomatOrg/TomatoDotNet/blob/80266bb8dc0e7f0644f0638ecd98dfad4fb74427/src/dotnet/jit/gdb.c\">TomatoDotNet</a></li>\n  <li><a href=\"https://github.com/jatovm/jato/blob/bb1c7d4fd987e016b2e0379182c4bfbb8c1c1a78/jit/elf.c#L164\">Jato JVM</a></li>\n  <li><a href=\"https://gist.github.com/yyny/4a012029b5889853c18b1efc19bb598e\">a minimal example</a></li>\n  <li><a href=\"https://github.com/sisshiki1969/jit-debug/blob/213c72512761f815fc0b067ce68ee0ae12962e2a/src/main.rs\">monoruby</a></li>\n  <li><a href=\"https://github.com/mono/mono/blob/0f53e9e151d92944cacab3e24ac359410c606df6/mono/mini/dwarfwriter.c\">Mono</a></li>\n  <li>It looks like Dart <a href=\"https://github.com/dart-lang/sdk/commit/c4238c71da13d61ff32332058d371c5b2e92694b\">used to</a>\nhave support for this but has since removed it</li>\n  <li><a href=\"https://github.com/bytecodealliance/wasmtime/blob/b5272a5f103053f5ada2a38d5302a8d1e2de442d/crates/wasmtime/src/runtime/code_memory.rs#L509\">wasmtime</a></li>\n</ul>\n\n<p>Because this is a huge hassle, GDB also has a newer interface that does not\nrequire making an ELF/Mach-O/…+DWARF object.</p>\n\n<h2 id=\"custom-debug-info-the-new-interface\">Custom debug info (the new interface)</h2>\n\n<p>This new interface requires writing a binary format of your choice. You make\nthe writer and you make the reader. Then, when you are in GDB, you load your\nreader as a shared object.</p>\n\n<p>The reader must implement <a href=\"https://sourceware.org/gdb/current/onlinedocs/gdb.html/Writing-JIT-Debug-Info-Readers.html#Writing-JIT-Debug-Info-Readers\">the interface specified by GDB</a>:</p>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">GDB_DECLARE_GPL_COMPATIBLE_READER</span><span class=\"p\">;</span>\n<span class=\"k\">extern</span> <span class=\"k\">struct</span> <span class=\"n\">gdb_reader_funcs</span> <span class=\"o\">*</span><span class=\"nf\">gdb_init_reader</span> <span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">);</span>\n<span class=\"k\">struct</span> <span class=\"n\">gdb_reader_funcs</span>\n<span class=\"p\">{</span>\n  <span class=\"cm\">/* Must be set to GDB_READER_INTERFACE_VERSION.  */</span>\n  <span class=\"kt\">int</span> <span class=\"n\">reader_version</span><span class=\"p\">;</span>\n\n  <span class=\"cm\">/* For use by the reader.  */</span>\n  <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">priv_data</span><span class=\"p\">;</span>\n\n  <span class=\"n\">gdb_read_debug_info</span> <span class=\"o\">*</span><span class=\"n\">read</span><span class=\"p\">;</span>\n  <span class=\"n\">gdb_unwind_frame</span> <span class=\"o\">*</span><span class=\"n\">unwind</span><span class=\"p\">;</span>\n  <span class=\"n\">gdb_get_frame_id</span> <span class=\"o\">*</span><span class=\"n\">get_frame_id</span><span class=\"p\">;</span>\n  <span class=\"n\">gdb_destroy_reader</span> <span class=\"o\">*</span><span class=\"n\">destroy</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n\n<p>The <code class=\"language-plaintext highlighter-rouge\">read</code> function pointer does the bulk of the work and is responsible for\nmatching code ranges to function names, line numbers, and more.</p>\n\n<p>Here are <a href=\"https://pwparchive.wordpress.com/2011/11/20/new-jit-interface-for-gdb/\">some details from Sanjoy Das</a>.</p>\n\n<p>Only a few runtimes implement this interface. Most of them stub out the\n<code class=\"language-plaintext highlighter-rouge\">unwind</code> and <code class=\"language-plaintext highlighter-rouge\">get_frame_id</code> function pointers:</p>\n\n<ul>\n  <li><a href=\"https://github.com/ykjit/yk/blob/755e533aa74ef5fa82a6586147727e23146b95fc/ykrt/src/compile/jitc_yk/gdb.rs#L216\">yk write</a> <br />\n<a href=\"https://github.com/ykjit/yk/blob/755e533aa74ef5fa82a6586147727e23146b95fc/ykrt/yk_gdb_plugin/yk_gdb_plugin.c#L22\">yk read</a></li>\n  <li><a href=\"https://github.com/tetzank/asmjit-utilities/blob/2fdbb99f7e002df4f8d7aa97c29910743adfc991/gdb/gdbjit.cpp\">asmjit-utilities write</a> <br />\n<a href=\"https://github.com/tetzank/asmjit-utilities/blob/2fdbb99f7e002df4f8d7aa97c29910743adfc991/gdb/jit-reader/gdbjit-reader.c\">asmjit-utilities read</a></li>\n  <li><a href=\"https://github.com/erlang/otp/blob/28a44634fb04b95ea666abb8aac7254e2c87ae05/erts/emulator/beam/jit/beam_jit_metadata.cpp#L123\">Erlang/OTP write</a> <br />\n<a href=\"https://github.com/erlang/otp-gdb-tools/blob/7b864f58c534699e4124e31ecfda86041b941037/jit-reader.c\">Erlang/OTP read</a></li>\n  <li><a href=\"https://github.com/FEX-Emu/FEX/blob/c8d72eabe589392b962bec94d002c5ffdb7381c2/FEXCore/Source/Interface/GDBJIT/GDBJIT.cpp#L110\">FEX write</a> <br />\n<a href=\"https://github.com/FEX-Emu/FEX/blob/c8d72eabe589392b962bec94d002c5ffdb7381c2/Source/Tools/FEXGDBReader/FEXGDBReader.cpp#L8\">FEX read</a></li>\n  <li><a href=\"https://github.com/bullno1/buxn-jit/blob/69effb96d5fe9725258fe367efcefd6911ef32fd/src/gdb/hook.c\">buxn-jit write</a> <br />\n<a href=\"https://github.com/bullno1/buxn-jit/blob/69effb96d5fe9725258fe367efcefd6911ef32fd/src/gdb/reader.c\">buxn-jit read</a></li>\n  <li><a href=\"https://github.com/KreitinnSoftware/box64/blob/f224a93cc83f9da34bc85ebb5414168d476a135d/src/tools/gdbjit.c#L45\">box64 write</a> <br />\n<a href=\"https://github.com/KreitinnSoftware/box64/blob/f224a93cc83f9da34bc85ebb5414168d476a135d/gdbjit/reader.c\">box64 read</a></li>\n  <li><a href=\"https://github.com/no-defun-allowed/ccl/blob/094a9ec5bf203db118e0ffc8ce2b5b80fc1c91dd/lisp-kernel/gdb.c\">ccl write</a> <br />\n<a href=\"https://gist.github.com/no-defun-allowed/32d38c5e664586c724cf2e0e97f0d2b1\">ccl read</a></li>\n</ul>\n\n<p>I think it also requires at least the reader to proclaim it is GPL via the\nmacro <code class=\"language-plaintext highlighter-rouge\">GDB_DECLARE_GPL_COMPATIBLE_READER</code>.</p>\n\n<p>Since I wrote about the <a href=\"/blog/jit-perf-map/\">perf map interface</a> recently, I\nhave it on my mind. Why can’t we reuse it in GDB?</p>\n\n<h2 id=\"adapting-to-the-linux-perf-interface\">Adapting to the Linux perf interface</h2>\n\n<p>I suppose it would be possible to try and upstream a patch to GDB to support\nthe Linux perf map interface for JITs. After all, why shouldn’t it be able to\nautomatically pick up symbols from <code class=\"language-plaintext highlighter-rouge\">/tmp/perf-...</code>? That would be great\nbaseline debug info for “free”.</p>\n\n<p>In the meantime, maybe it is reasonable to create a re-usable custom debug\nreader:</p>\n\n<ul>\n  <li>When registering code, write the address and name to <code class=\"language-plaintext highlighter-rouge\">/tmp/perf-...</code> as you normally would</li>\n  <li>Write the filename as the symfile (does this make <code class=\"language-plaintext highlighter-rouge\">/tmp</code> the magic number?)</li>\n  <li>Have the debug info reader just parse the perf map file</li>\n</ul>\n\n<p>It would be less flexible than both the DWARF and custom readers support: it\nwould only be able to handle filename and code region. No embedding source code\nfor GDB to display in your debugger. But maybe that is okay for a partial\nsolution?</p>\n\n<p><strong>Update:</strong> Here is <a href=\"https://github.com/tekknolagi/gdb-jit-linux-perf-map\">my small attempt</a>\nat such a plugin.</p>\n\n<h2 id=\"the-n-squared-problem\">The n-squared problem</h2>\n\n<p>V8 notes in their <a href=\"https://v8.dev/docs/gdb-jit\">GDB JIT docs</a> that because the JIT interface is\na linked list and we only keep a pointer to the head, we get O(n<sup>2</sup>)\nbehavior. Bummer. This becomes especially noticeable since they register\nadditional code objects not just for functions, but also trampolines, cache\nstubs, etc.</p>\n\n<h2 id=\"garbage-collection\">Garbage collection</h2>\n\n<p>Since GDB expects the code pointer in your symbol object file not to move, you\nhave to make sure to have a stable symbol file pointer and stable executable\ncode pointer. To make this happen, V8 disables its moving GC.</p>\n\n<p>Additionally, if your compiled function gets collected, you have to make sure\nto unregister the function. Instead of doing this eagerly, ART treats the GDB\nJIT linked list as a weakref and periodically removes dead code entries from\nit.</p>",
  "id": "https://bernsteinbear.com/blog/gdb-jit/"
}