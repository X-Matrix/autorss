{
  "title": "Buffer Overflows and Stacks and Assembly, Oh My!",
  "link": "https://jyn.dev/buffer-overflows-and-stacks-and-assembly-oh-my/",
  "published": "2019-04-29T00:00:00+00:00",
  "summary": "<p>Google has a 'Intro' Capture The Flag competition at\n<a href=\"https://capturetheflag.withgoogle.com/#beginners/\">https://capturetheflag.withgoogle.com/#beginners/</a>.\nI've been trying it out because, why not?\nThe challenges aren't easy by any means - they range from javascript crypto\n(let me know if you find out how to break JS Safe!) to SQL injections to steganography.\nThe challenge this post about, however, is a reverse engineering challenge: three, in fact.</p>\n<p>10-second summary of reverse engineering: you have a binary and no source code,\nand you want to exploit it somehow. In this case, the binary is across a network\nconnection, so you can't modify the code, you have to use what's there already.\nIf you want to try it yourself, the binary is <a href=\"https://jyn.dev/assets/mngmnt\">here</a>,\nit runs on 64-bit Linux 2.4+ (but may work on other machines, I haven't tried).\nI highly recommend going through the whole CTF first, though.</p>\n<h2 id=\"challenge-1\">Challenge 1<a class=\"zola-anchor\" href=\"https://jyn.dev/buffer-overflows-and-stacks-and-assembly-oh-my/#challenge-1\"></a>\n</h2>\n<blockquote>\n<p>Do some black box testing here, it'll go well with your hat.\n<code>nc mngmnt-iface.ctfcompetition.com 1337</code></p>\n</blockquote>\n<p>When you connect, you get a screen saying</p>\n<pre class=\"z-code\"><code><span class=\"z-text z-plain\">=== Management Interface ===\n</span><span class=\"z-text z-plain\"> 1) Service access\n</span><span class=\"z-text z-plain\"> 2) Read EULA/patch notes\n</span><span class=\"z-text z-plain\"> 3) Quit\n</span></code></pre>\n<p>Let's read the patchnotes!</p>\n<pre class=\"z-code\"><code><span class=\"z-text z-plain\">2\n</span><span class=\"z-text z-plain\">The following patchnotes were found:\n</span><span class=\"z-text z-plain\"> - Version0.2\n</span><span class=\"z-text z-plain\"> - Version0.3\n</span><span class=\"z-text z-plain\">Which patchnotes should be shown?\n</span><span class=\"z-text z-plain\">Version0.2\n</span><span class=\"z-text z-plain\"># Release 0.2\n</span><span class=\"z-text z-plain\"> - Updated library X to version 0.Y\n</span><span class=\"z-text z-plain\"> - Fixed path traversal bug\n</span><span class=\"z-text z-plain\"> - Improved the UX\n</span><span class=\"z-text z-plain\">=== Management Interface ===\n</span><span class=\"z-text z-plain\"> 1) Service access\n</span><span class=\"z-text z-plain\"> 2) Read EULA/patch notes\n</span><span class=\"z-text z-plain\"> 3) Quit\n</span><span class=\"z-text z-plain\">2\n</span><span class=\"z-text z-plain\">The following patchnotes were found:\n</span><span class=\"z-text z-plain\"> - Version0.2\n</span><span class=\"z-text z-plain\"> - Version0.3\n</span><span class=\"z-text z-plain\">Which patchnotes should be shown?\n</span><span class=\"z-text z-plain\">Version0.3\n</span><span class=\"z-text z-plain\"># Version 0.3\n</span><span class=\"z-text z-plain\"> - Rollback of version 0.2 because of random reasons\n</span><span class=\"z-text z-plain\"> - Blah Blah\n</span><span class=\"z-text z-plain\"> - Fix random reboots at 2:32 every second Friday when it's new-moon.\n</span></code></pre>\n<p>Well, look at that. There's a path traversal bug:\nfixed in .2 and rolled back in .3 for 'random reasons'.\nA path traversal bug is when you have a public server which is meant to serve\nfiles in the starting directory, but instead servers files from the whole machine if\nyou use relative paths. An example:</p>\n<pre class=\"z-code\"><code><span class=\"z-text z-plain\">=== Management Interface ===\n</span><span class=\"z-text z-plain\"> 1) Service access\n</span><span class=\"z-text z-plain\"> 2) Read EULA/patch notes\n</span><span class=\"z-text z-plain\"> 3) Quit\n</span><span class=\"z-text z-plain\">2\n</span><span class=\"z-text z-plain\">The following patchnotes were found:\n</span><span class=\"z-text z-plain\"> - Version0.2\n</span><span class=\"z-text z-plain\"> - Version0.3\n</span><span class=\"z-text z-plain\">Which patchnotes should be shown?\n</span><span class=\"z-text z-plain\">../../../../../etc/passwd\n</span><span class=\"z-text z-plain\">root:x:0:0:root:/root:/bin/bash\n</span><span class=\"z-text z-plain\">...\n</span><span class=\"z-text z-plain\">user:x:1337:1337::/home/user:\n</span></code></pre>\n<p>From here you have a couple options to get the flag: you can either guess\n('fuzz') the filename, or you can download the binary and see what file it's\ntrying to open. Let's do the second.</p>\n<p>But wait, how do we get the binary? It turns out on linux there's a <code>proc</code> filesystem\nwhich <em>looks</em> like it has a bunch of files but really is a bunch of kernel info about\nthe running system. What that means for us is we can get the program without knowing the filename or current directory.</p>\n<pre class=\"z-code\"><code><span class=\"z-text z-plain\">=== Management Interface ===\n</span><span class=\"z-text z-plain\"> 1) Service access\n</span><span class=\"z-text z-plain\"> 2) Read EULA/patch notes\n</span><span class=\"z-text z-plain\"> 3) Quit\n</span><span class=\"z-text z-plain\">2\n</span><span class=\"z-text z-plain\">The following patchnotes were found:\n</span><span class=\"z-text z-plain\"> - Version0.2\n</span><span class=\"z-text z-plain\"> - Version0.3\n</span><span class=\"z-text z-plain\">Which patchnotes should be shown?\n</span><span class=\"z-text z-plain\">../../../../../proc/self/exe\n</span><span class=\"z-text z-plain\">ELF&gt;PAAA@X�@8\n</span><span class=\"z-text z-plain\">... more binary follows ...\n</span></code></pre>\n<p><code>/proc</code> is the start of the filesystem, <code>self</code> is the directory for the currently running process\n(in this case the vulnerable program), and <code>exe</code> is the executable file as it was\nwhen the process started running. So now that we've got the binary, we can take a look at what it's doing.</p>\n<h3 id=\"enter-gdb\">Enter GDB<a class=\"zola-anchor\" href=\"https://jyn.dev/buffer-overflows-and-stacks-and-assembly-oh-my/#enter-gdb\"></a>\n</h3>\n<p>If you don't know how to use GDB, I highly recommend learning. Not only will it\nbe useful for debugging your own code, but it's the main way I know of to\nreverse engineer executables.</p>\n<p>The first thing I normally do is look at the main function:</p>\n<pre class=\"z-code\"><code><span class=\"z-text z-plain\">gdb -q ./mngmnt\n</span><span class=\"z-text z-plain\">Reading symbols from ./mngmnt...done.\n</span><span class=\"z-text z-plain\">(gdb) break main\n</span><span class=\"z-text z-plain\">Breakpoint 1 at 0x41414660: file main.cpp, line 133.\n</span><span class=\"z-text z-plain\">(gdb) run\n</span><span class=\"z-text z-plain\">Starting program: /home/jyn/Documents/Programming/challenges/googlectf/mngmnt\n</span><span class=\"z-text z-plain\">\n</span><span class=\"z-text z-plain\">Breakpoint 1, main (argc=1, argv=0x7fffffffdc28) at main.cpp:133\n</span><span class=\"z-text z-plain\">133     main.cpp: No such file or directory.\n</span><span class=\"z-text z-plain\">(gdb) disas\n</span><span class=\"z-text z-plain\">Dump of assembler code for function main(int, char**):\n</span><span class=\"z-text z-plain\">   0x0000000041414648 &lt;+0&gt;:     push   %rbp\n</span><span class=\"z-text z-plain\">   0x0000000041414649 &lt;+1&gt;:     mov    %rsp,%rbp\n</span><span class=\"z-text z-plain\">   0x000000004141464c &lt;+4&gt;:     sub    $0x1e0,%rsp\n</span><span class=\"z-text z-plain\">   0x0000000041414653 &lt;+11&gt;:    mov    %edi,-0x1d4(%rbp)\n</span><span class=\"z-text z-plain\">   0x0000000041414659 &lt;+17&gt;:    mov    %rsi,-0x1e0(%rbp)\n</span><span class=\"z-text z-plain\">=&gt; 0x0000000041414660 &lt;+24&gt;:    mov    0x201a99(%rip),%rax        # 0x41616100 &lt;stdin@@GLIBC_2.2.5&gt;\n</span><span class=\"z-text z-plain\">\n</span><span class=\"z-text z-plain\">... lots of assembly follows, about 600 lines ...\n</span></code></pre>\n<p>Well that's a lot to look at. There's a function called <code>primary_login</code>\nabout halfway down though, that looks promising.</p>\n<pre class=\"z-code\"><code><span class=\"z-text z-plain\">(gdb) break primary_login()\n</span><span class=\"z-text z-plain\">Breakpoint 2 at 0x41414576: file main.cpp, line 112.\n</span><span class=\"z-text z-plain\">(gdb) continue\n</span><span class=\"z-text z-plain\">Continuing.\n</span><span class=\"z-text z-plain\">=== Management Interface ===\n</span><span class=\"z-text z-plain\"> 1) Service access\n</span><span class=\"z-text z-plain\"> 2) Read EULA/patch notes\n</span><span class=\"z-text z-plain\"> 3) Quit\n</span><span class=\"z-text z-plain\">1\n</span><span class=\"z-text z-plain\">\n</span><span class=\"z-text z-plain\">Breakpoint 2, primary_login () at main.cpp:112\n</span><span class=\"z-text z-plain\">112     in main.cpp\n</span><span class=\"z-text z-plain\">(gdb) disas\n</span><span class=\"z-text z-plain\">Dump of assembler code for function primary_login():\n</span><span class=\"z-text z-plain\">   0x000000004141456b &lt;+0&gt;:     push   %rbp\n</span><span class=\"z-text z-plain\">   0x000000004141456c &lt;+1&gt;:     mov    %rsp,%rbp\n</span><span class=\"z-text z-plain\">   0x000000004141456f &lt;+4&gt;:     sub    $0x110,%rsp\n</span><span class=\"z-text z-plain\">=&gt; 0x0000000041414576 &lt;+11&gt;:    lea    0x62b(%rip),%rdi        # 0x41414ba8\n</span><span class=\"z-text z-plain\">   0x000000004141457d &lt;+18&gt;:    callq  0x400a90 &lt;puts@plt&gt;\n</span><span class=\"z-text z-plain\">   0x0000000041414582 &lt;+23&gt;:    mov    $0x0,%esi\n</span><span class=\"z-text z-plain\">   0x0000000041414587 &lt;+28&gt;:    lea    0x49e(%rip),%rdi        # 0x41414a2c &lt;_ZL9FLAG_FILE&gt;\n</span><span class=\"z-text z-plain\">   0x000000004141458e &lt;+35&gt;:    mov    $0x0,%eax\n</span><span class=\"z-text z-plain\">   0x0000000041414593 &lt;+40&gt;:    callq  0x400be0 &lt;open@plt&gt;\n</span><span class=\"z-text z-plain\">... about 200 more lines of assembly ...\n</span></code></pre>\n<p>What's <code>_ZL9FLAG_FILE</code>?</p>\n<pre class=\"z-code\"><code><span class=\"z-text z-plain\">(gdb) printf &quot;%s\\n&quot;, 0x41414a2c\n</span><span class=\"z-text z-plain\">flag\n</span></code></pre>\n<p>After all that, that was it? Well, at least we know how to get the flag now.\nOne last trick - we can get the current directory of the running process with\n<code>/proc/self/cwd</code>:</p>\n<pre class=\"z-code\"><code><span class=\"z-text z-plain\">nc mngmnt-iface.ctfcompetition.com 1337\n</span><span class=\"z-text z-plain\">=== Management Interface ===\n</span><span class=\"z-text z-plain\"> 1) Service access\n</span><span class=\"z-text z-plain\"> 2) Read EULA/patch notes\n</span><span class=\"z-text z-plain\"> 3) Quit\n</span><span class=\"z-text z-plain\">2\n</span><span class=\"z-text z-plain\">The following patchnotes were found:\n</span><span class=\"z-text z-plain\"> - Version0.2\n</span><span class=\"z-text z-plain\"> - Version0.3\n</span><span class=\"z-text z-plain\">Which patchnotes should be shown?\n</span><span class=\"z-text z-plain\">../../../../../proc/self/cwd/flag\n</span><span class=\"z-text z-plain\">CTF{I_luv_buggy_sOFtware}\n</span></code></pre>\n<h2 id=\"challenge-2\">Challenge 2<a class=\"zola-anchor\" href=\"https://jyn.dev/buffer-overflows-and-stacks-and-assembly-oh-my/#challenge-2\"></a>\n</h2>\n<p>That got our feet wet. The next challenge is a bit trickier.\nCan we get through the login screen?</p>\n<pre class=\"z-code\"><code><span class=\"z-text z-plain\">nc mngmnt-iface.ctfcompetition.com 1337'\n</span><span class=\"z-text z-plain\">=== Management Interface ===\n</span><span class=\"z-text z-plain\"> 1) Service access\n</span><span class=\"z-text z-plain\"> 2) Read EULA/patch notes\n</span><span class=\"z-text z-plain\"> 3) Quit\n</span><span class=\"z-text z-plain\">1\n</span><span class=\"z-text z-plain\">Please enter the backdoo^Wservice password:\n</span><span class=\"z-text z-plain\">CTF{I_luv_buggy_sOFtware}\n</span><span class=\"z-text z-plain\">! Two factor authentication required !\n</span><span class=\"z-text z-plain\">Please enter secret secondary password:\n</span></code></pre>\n<p>Oh boy, what now? Let's look at the program again.</p>\n<pre class=\"z-code\"><code><span class=\"z-text z-plain\">gdb ./mngmnt\n</span><span class=\"z-text z-plain\">Reading symbols from ./mngmnt...done.\n</span><span class=\"z-text z-plain\">(gdb) disas primary_login\n</span><span class=\"z-text z-plain\">Dump of assembler code for function primary_login():\n</span><span class=\"z-text z-plain\">... lots of code ...\n</span><span class=\"z-text z-plain\">   0x0000000041414627 &lt;+188&gt;:   jne    0x41414630 &lt;primary_login()+197&gt;\n</span><span class=\"z-text z-plain\">   0x0000000041414629 &lt;+190&gt;:   callq  0x41414446 &lt;secondary_login()&gt;\n</span><span class=\"z-text z-plain\">   0x000000004141462e &lt;+195&gt;:   jmp    0x41414646 &lt;primary_login()+219&gt;\n</span><span class=\"z-text z-plain\">   0x0000000041414630 &lt;+197&gt;:   lea    0x5b9(%rip),%rdi        # 0x41414bf0\n</span><span class=\"z-text z-plain\">   0x0000000041414637 &lt;+204&gt;:   callq  0x400a90 &lt;puts@plt&gt;\n</span><span class=\"z-text z-plain\">   0x000000004141463c &lt;+209&gt;:   mov    $0x1,%edi\n</span><span class=\"z-text z-plain\">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---\n</span><span class=\"z-text z-plain\">   0x0000000041414641 &lt;+214&gt;:   callq  0x400aa0 &lt;exit@plt&gt;\n</span><span class=\"z-text z-plain\">   0x0000000041414646 &lt;+219&gt;:   leaveq\n</span><span class=\"z-text z-plain\">   0x0000000041414647 &lt;+220&gt;:   retq\n</span><span class=\"z-text z-plain\">End of assembler dump.\n</span></code></pre>\n<p><code>secondary_login</code> looks promising, what's that look like?\nNote: this is really long because we do need to read it this time.</p>\n<pre class=\"z-code\"><code><span class=\"z-text z-plain\">(gdb) disas secondary_login\n</span><span class=\"z-text z-plain\">Dump of assembler code for function secondary_login():\n</span><span class=\"z-text z-plain\">   0x0000000041414446 &lt;+0&gt;:     push   %rbp\n</span><span class=\"z-text z-plain\">   0x0000000041414447 &lt;+1&gt;:     mov    %rsp,%rbp\n</span><span class=\"z-text z-plain\">   0x000000004141444a &lt;+4&gt;:     sub    $0x90,%rsp\n</span><span class=\"z-text z-plain\">   0x0000000041414451 &lt;+11&gt;:    lea    0x6d8(%rip),%rdi        # 0x41414b30\n</span><span class=\"z-text z-plain\">   0x0000000041414458 &lt;+18&gt;:    callq  0x400a90 &lt;puts@plt&gt;\n</span><span class=\"z-text z-plain\">   0x000000004141445d &lt;+23&gt;:    lea    0x6f4(%rip),%rdi        # 0x41414b58\n</span><span class=\"z-text z-plain\">   0x0000000041414464 &lt;+30&gt;:    callq  0x400a90 &lt;puts@plt&gt;\n</span><span class=\"z-text z-plain\">   0x0000000041414469 &lt;+35&gt;:    lea    -0x90(%rbp),%rax\n</span><span class=\"z-text z-plain\">   0x0000000041414470 &lt;+42&gt;:    mov    %rax,%rsi\n</span><span class=\"z-text z-plain\">   0x0000000041414473 &lt;+45&gt;:    lea    0x706(%rip),%rdi        # 0x41414b80\n</span><span class=\"z-text z-plain\">   0x000000004141447a &lt;+52&gt;:    mov    $0x0,%eax\n</span><span class=\"z-text z-plain\">   0x000000004141447f &lt;+57&gt;:    callq  0x400b00 &lt;scanf@plt&gt;\n</span><span class=\"z-text z-plain\">   0x0000000041414484 &lt;+62&gt;:    lea    -0x90(%rbp),%rax\n</span><span class=\"z-text z-plain\">   0x000000004141448b &lt;+69&gt;:    mov    %rax,%rdi\n</span><span class=\"z-text z-plain\">   0x000000004141448e &lt;+72&gt;:    callq  0x400b10 &lt;strlen@plt&gt;\n</span><span class=\"z-text z-plain\">   0x0000000041414493 &lt;+77&gt;:    mov    %rax,-0x10(%rbp)\n</span><span class=\"z-text z-plain\">   0x0000000041414497 &lt;+81&gt;:    movq   $0x0,-0x8(%rbp)\n</span><span class=\"z-text z-plain\">   0x000000004141449f &lt;+89&gt;:    mov    -0x8(%rbp),%rax\n</span><span class=\"z-text z-plain\">   0x00000000414144a3 &lt;+93&gt;:    cmp    -0x10(%rbp),%rax\n</span><span class=\"z-text z-plain\">   0x00000000414144a7 &lt;+97&gt;:    jae    0x414144d6 &lt;secondary_login()+144&gt;\n</span><span class=\"z-text z-plain\">   0x00000000414144a9 &lt;+99&gt;:    lea    -0x90(%rbp),%rdx\n</span><span class=\"z-text z-plain\">   0x00000000414144b0 &lt;+106&gt;:   mov    -0x8(%rbp),%rax\n</span><span class=\"z-text z-plain\">   0x00000000414144b4 &lt;+110&gt;:   add    %rdx,%rax\n</span><span class=\"z-text z-plain\">   0x00000000414144b7 &lt;+113&gt;:   movzbl (%rax),%eax\n</span><span class=\"z-text z-plain\">   0x00000000414144ba &lt;+116&gt;:   xor    $0xffffffc7,%eax\n</span><span class=\"z-text z-plain\">   0x00000000414144bd &lt;+119&gt;:   mov    %eax,%ecx\n</span><span class=\"z-text z-plain\">   0x00000000414144bf &lt;+121&gt;:   lea    -0x90(%rbp),%rdx\n</span><span class=\"z-text z-plain\">   0x00000000414144c6 &lt;+128&gt;:   mov    -0x8(%rbp),%rax\n</span><span class=\"z-text z-plain\">   0x00000000414144ca &lt;+132&gt;:   add    %rdx,%rax\n</span><span class=\"z-text z-plain\">   0x00000000414144cd &lt;+135&gt;:   mov    %cl,(%rax)\n</span><span class=\"z-text z-plain\">   0x00000000414144cf &lt;+137&gt;:   addq   $0x1,-0x8(%rbp)\n</span><span class=\"z-text z-plain\">   0x00000000414144d4 &lt;+142&gt;:   jmp    0x4141449f &lt;secondary_login()+89&gt;\n</span><span class=\"z-text z-plain\">   0x00000000414144d6 &lt;+144&gt;:   cmpq   $0x23,-0x10(%rbp)\n</span><span class=\"z-text z-plain\">   0x00000000414144db &lt;+149&gt;:   jne    0x41414537 &lt;secondary_login()+241&gt;\n</span><span class=\"z-text z-plain\">   0x00000000414144dd &lt;+151&gt;:   mov    0x55c(%rip),%rax        # 0x41414a40 &lt;_ZL4FLAG&gt;\n</span><span class=\"z-text z-plain\">   0x00000000414144e4 &lt;+158&gt;:   mov    0x55d(%rip),%rdx        # 0x41414a48 &lt;_ZL4FLAG+8&gt;\n</span><span class=\"z-text z-plain\">   0x00000000414144eb &lt;+165&gt;:   mov    %rax,-0x90(%rbp)\n</span><span class=\"z-text z-plain\">   0x00000000414144f2 &lt;+172&gt;:   mov    %rdx,-0x88(%rbp)\n</span><span class=\"z-text z-plain\">   0x00000000414144f9 &lt;+179&gt;:   mov    0x550(%rip),%rax        # 0x41414a50 &lt;_ZL4FLAG+16&gt;\n</span><span class=\"z-text z-plain\">   0x0000000041414500 &lt;+186&gt;:   mov    0x551(%rip),%rdx        # 0x41414a58 &lt;_ZL4FLAG+24&gt;\n</span><span class=\"z-text z-plain\">   0x0000000041414507 &lt;+193&gt;:   mov    %rax,-0x80(%rbp)\n</span><span class=\"z-text z-plain\">   0x000000004141450b &lt;+197&gt;:   mov    %rdx,-0x78(%rbp)\n</span><span class=\"z-text z-plain\">   0x000000004141450f &lt;+201&gt;:   movzwl 0x54a(%rip),%eax        # 0x41414a60 &lt;_ZL4FLAG+32&gt;\n</span><span class=\"z-text z-plain\">   0x0000000041414516 &lt;+208&gt;:   mov    %ax,-0x70(%rbp)\n</span><span class=\"z-text z-plain\">   0x000000004141451a &lt;+212&gt;:   movzbl 0x541(%rip),%eax        # 0x41414a62 &lt;_ZL4FLAG+34&gt;\n</span><span class=\"z-text z-plain\">   0x0000000041414521 &lt;+219&gt;:   mov    %al,-0x6e(%rbp)\n</span><span class=\"z-text z-plain\">   0x0000000041414524 &lt;+222&gt;:   lea    -0x90(%rbp),%rax\n</span><span class=\"z-text z-plain\">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---\n</span><span class=\"z-text z-plain\">   0x000000004141452b &lt;+229&gt;:   test   %rax,%rax\n</span><span class=\"z-text z-plain\">   0x000000004141452e &lt;+232&gt;:   je     0x41414537 &lt;secondary_login()+241&gt;\n</span><span class=\"z-text z-plain\">   0x0000000041414530 &lt;+234&gt;:   mov    $0x1,%eax\n</span><span class=\"z-text z-plain\">   0x0000000041414535 &lt;+239&gt;:   jmp    0x4141453c &lt;secondary_login()+246&gt;\n</span><span class=\"z-text z-plain\">   0x0000000041414537 &lt;+241&gt;:   mov    $0x0,%eax\n</span><span class=\"z-text z-plain\">   0x000000004141453c &lt;+246&gt;:   test   %al,%al\n</span><span class=\"z-text z-plain\">   0x000000004141453e &lt;+248&gt;:   je     0x41414553 &lt;secondary_login()+269&gt;\n</span><span class=\"z-text z-plain\">   0x0000000041414540 &lt;+250&gt;:   lea    0x63f(%rip),%rdi        # 0x41414b86\n</span><span class=\"z-text z-plain\">   0x0000000041414547 &lt;+257&gt;:   callq  0x400a90 &lt;puts@plt&gt;\n</span><span class=\"z-text z-plain\">   0x000000004141454c &lt;+262&gt;:   callq  0x4141428e &lt;command_line()&gt;\n</span><span class=\"z-text z-plain\">   0x0000000041414551 &lt;+267&gt;:   jmp    0x41414569 &lt;secondary_login()+291&gt;\n</span><span class=\"z-text z-plain\">   0x0000000041414553 &lt;+269&gt;:   lea    0x63a(%rip),%rdi        # 0x41414b94\n</span><span class=\"z-text z-plain\">   0x000000004141455a &lt;+276&gt;:   callq  0x400a90 &lt;puts@plt&gt;\n</span><span class=\"z-text z-plain\">   0x000000004141455f &lt;+281&gt;:   mov    $0x1,%edi\n</span><span class=\"z-text z-plain\">   0x0000000041414564 &lt;+286&gt;:   callq  0x400aa0 &lt;exit@plt&gt;\n</span><span class=\"z-text z-plain\">   0x0000000041414569 &lt;+291&gt;:   leaveq\n</span><span class=\"z-text z-plain\">   0x000000004141456a &lt;+292&gt;:   retq\n</span></code></pre>\n<p>There's a few things of note here. First is the <code>command_line</code> function,\nwhich looks promising. Next is <code>_ZL4FLAG</code>, which seems useful. What's there?</p>\n<pre class=\"z-code\"><code><span class=\"z-text z-plain\">(gdb) printf &quot;%s\\n&quot;, 0x41414a40\n</span><span class=\"z-text z-plain\">�����������������������������������/bin/sh\n</span></code></pre>\n<p>That's not helpful, it's binary data. And why does it have a shell at the end there?\nAnd finally, how do we get to <code>command_line</code>? Let's trace the execution.\nIf you've heard of 'basic blocks' in compilers, that's basically what we're going\nto do now: split up the code into segments divided by jumps.</p>\n<p>First we start at +0. Then execution is linear until line +93, where there's a\n<code>cmp</code> (compare) and a <code>jae</code> (jump above equal) to +144. At 144, it compares\n-0x10(%rbp) to 0x23, or 35 in decimal.</p>\n<p>That's funny, the number of <code>�</code> characters in the data above is 35.\nCoincidence? I think not. What happens if we just put in a string with 35 characters?</p>\n<pre class=\"z-code\"><code><span class=\"z-text z-plain\">! Two factor authentication required !\n</span><span class=\"z-text z-plain\">Please enter secret secondary password:\n</span><span class=\"z-text z-plain\">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n</span><span class=\"z-text z-plain\">Authenticated\n</span><span class=\"z-text z-plain\">&gt;\n</span></code></pre>\n<p>Wait, what? That's it? Where's the flag?\nIt turns out this program forgot to check that you had the right password.\nI couldn't figure out what was going on, so I cheated and looked at\nhttps://jhalon.github.io/2018-google-ctf-beginners-pwn-solutions-1/\n(which is a much better writeup). Long story short, there's an inner loop\ndoing funny things with <code>xor</code>. If we xor the binary at <code>_ZL4FLAG</code> with\n<code>0xc7</code>, we get back the flag. GDB and python will both be helpful here.</p>\n<pre class=\"z-code\"><code><span class=\"z-text z-plain\">(gdb) print/x _ZL4FLAG\n</span><span class=\"z-text z-plain\">$5 = {0x84, 0x93, 0x81, 0xbc, 0x93, 0xb0, 0xa8, 0x98, 0x97, 0xa6, 0xb4, 0x94, 0xb0, 0xa8,\n</span><span class=\"z-text z-plain\">  0xb5, 0x83, 0xbd, 0x98, 0x85, 0xa2, 0xb3, 0xb3, 0xa2, 0xb5, 0x98, 0xb3, 0xaf, 0xf3, 0xa9,\n</span><span class=\"z-text z-plain\">  0x98, 0xf6, 0x98, 0xac, 0xf8, 0xba}\n</span><span class=\"z-text z-plain\">(gdb) quit\n</span><span class=\"z-text z-plain\">$ python -q\n</span><span class=\"z-text z-plain\">&gt;&gt;&gt; import re\n</span><span class=\"z-text z-plain\">&gt;&gt;&gt; hexes = &quot;&quot;&quot;0x84, 0x93, 0x81, 0xbc, 0x93, 0xb0, 0xa8, 0x98, 0x97, 0xa6, 0xb4, 0x94, 0xb0, 0xa8,\n</span><span class=\"z-text z-plain\">...   0xb5, 0x83, 0xbd, 0x98, 0x85, 0xa2, 0xb3, 0xb3, 0xa2, 0xb5, 0x98, 0xb3, 0xaf, 0xf3, 0xa9,\n</span><span class=\"z-text z-plain\">...   0x98, 0xf6, 0x98, 0xac, 0xf8, 0xba&quot;&quot;&quot;\n</span><span class=\"z-text z-plain\">&gt;&gt;&gt; chars = ''.join(hexes.split()).replace(',', '').replace('0x', '')\n</span><span class=\"z-text z-plain\">&gt;&gt;&gt; chars\n</span><span class=\"z-text z-plain\">'849381bc93b0a89897a6b494b0a8b583bd9885a2b3b3a2b598b3aff3a998f698acf8ba'\n</span><span class=\"z-text z-plain\">&gt;&gt;&gt; ''.join([chr(int(c, 16) ^ 0xc7) for c in re.findall('..', chars)])\n</span><span class=\"z-text z-plain\">'CTF{Two_PasSworDz_Better_th4n_1_k?}'\n</span></code></pre>\n<p>Quick explanation of that awful and hacky code:\n<code>print/x</code> means print as hexidecimal instead of decimal or binary.\n<code>''.join(hexes.split())</code> is a hacky way of removing whitespace.\nThe <code>replace</code> calls are just getting rid of formatting we don't care about.\n<code>re.findall('..', chars)</code> splits the strings into 2-character sequences.\nThe rest is a list comprehesion which converts each string to an int,\nxors it with hexidecimal c7, then finally joins the whole list into a string.</p>\n<p>Side note: originally this was even more hacky - I used gdb's <code>&lt;address&gt;@n</code> syntax\nwhich gives you back the memory in architecture-endian order. 1/10 do not recommend.</p>\n<!--\n\n## Challenge 3\n> It's a sure bet that they can't handle their memory properly\n\nThe last challenge was also the hardest to exploit. Once you enter the second flag,\nyou get a shell without any instructions:\n\n```\n$  ./mngmnt\n=== Management Interface ===\n 1) Service access\n 2) Read EULA/patch notes\n 3) Quit\n1\nPlease enter the backdoo^Wservice password:\nflag\n! Two factor authentication required !\nPlease enter secret secondary password:\nCTF{Two_PasSworDz_Better_th4n_1_k?}\nAuthenticated\n> help\nUnknown command 'help'\n> ls\nUnknown command 'ls'\n> whoami\nUnknown command 'whoami'\n```\n\nLet's see if we can find what's going on. Looking back up at the assembly,\nwe see that it calls `command_line` once you put in the second password.\nWhat's that doing?\n\n```\ngdb ./mngmnt\nReading symbols from ./mngmnt...done.\n(gdb) disas command_line\nDump of assembler code for function command_line():\n   0x000000004141428e <+0>:     push   %rbp\n   0x000000004141428f <+1>:     mov    %rsp,%rbp\n   0x0000000041414292 <+4>:     push   %rbx\n   0x0000000041414293 <+5>:     sub    $0x128,%rsp\n   0x000000004141429a <+12>:    lea    0x7ca(%rip),%rdi        # 0x41414a6b\n   0x00000000414142a1 <+19>:    mov    $0x0,%eax\n   0x00000000414142a6 <+24>:    callq  0x400a70 <printf@plt>\n   0x00000000414142ab <+29>:    lea    -0x30(%rbp),%rax\n   0x00000000414142af <+33>:    mov    %rax,%rdi\n   0x00000000414142b2 <+36>:    callq  0x4141423a <getsx(char*)>\n   0x00000000414142b7 <+41>:    mov    0x201e77(%rip),%eax        # 0x41616134 <_ZL13cmds_executed>\n   0x00000000414142bd <+47>:    add    $0x1,%eax\n   0x00000000414142c0 <+50>:    mov    %eax,0x201e6e(%rip)        # 0x41616134 <_ZL13cmds_executed>\n   0x00000000414142c6 <+56>:    lea    -0x30(%rbp),%rax\n   0x00000000414142ca <+60>:    lea    0x79d(%rip),%rsi        # 0x41414a6e\n   0x00000000414142d1 <+67>:    mov    %rax,%rdi\n   0x00000000414142d4 <+70>:    callq  0x400ba0 <strcmp@plt>\n   0x00000000414142d9 <+75>:    test   %eax,%eax\n   0x00000000414142db <+77>:    jne    0x414142ee <command_line()+96>\n   0x00000000414142dd <+79>:    lea    0x78f(%rip),%rdi        # 0x41414a73\n   0x00000000414142e4 <+86>:    callq  0x400a90 <puts@plt>\n   0x00000000414142e9 <+91>:    jmpq   0x4141443c <command_line()+430>\n   0x00000000414142ee <+96>:    lea    -0x30(%rbp),%rax\n   0x00000000414142f2 <+100>:   lea    0x77f(%rip),%rsi        # 0x41414a78\n   0x00000000414142f9 <+107>:   mov    %rax,%rdi\n   0x00000000414142fc <+110>:   callq  0x400ba0 <strcmp@plt>\n   0x0000000041414301 <+115>:   test   %eax,%eax\n   0x0000000041414303 <+117>:   jne    0x41414313 <command_line()+133>\n   0x0000000041414305 <+119>:   lea    0x774(%rip),%rdi        # 0x41414a80\n   0x000000004141430c <+126>:   callq  0x400a90 <puts@plt>\n... snip ...\n   0x00000000414143ff <+369>:   lea    0x708(%rip),%rdi        # 0x41414b0e\n   0x0000000041414406 <+376>:   callq  0x400a90 <puts@plt>\n   0x000000004141440b <+381>:   lea    -0x130(%rbp),%rax\n   0x0000000041414412 <+388>:   mov    %rax,%rdi\n   0x0000000041414415 <+391>:   callq  0x400ae0 <system@plt>\n   0x000000004141441a <+396>:   jmpq   0x4141429a <command_line()+12>\n---Type <return> to continue, or q <return> to quit---\n   0x000000004141441f <+401>:   lea    -0x30(%rbp),%rax\n   0x0000000041414423 <+405>:   mov    %rax,%rsi\n   0x0000000041414426 <+408>:   lea    0x6ec(%rip),%rdi        # 0x41414b19\n   0x000000004141442d <+415>:   mov    $0x0,%eax\n   0x0000000041414432 <+420>:   callq  0x400a70 <printf@plt>\n   0x0000000041414437 <+425>:   jmpq   0x4141429a <command_line()+12>\n   0x000000004141443c <+430>:   add    $0x128,%rsp\n   0x0000000041414443 <+437>:   pop    %rbx\n   0x0000000041414444 <+438>:   pop    %rbp\n   0x0000000041414445 <+439>:   retq\n```\n\nThis looks long and compilicated, but it's really doing the same thing\nover and over: comparing a string to a bunch of other strings.\nThat begs the question: What other strings?\n\n```\n(gdb) printf \"%s\\n\", 0x41414a6e\nquit\n(gdb) printf \"%s\\n\", 0x41414a78\nversion\n(gdb) printf \"%s\\n\", 0x41414a8c\nshell\n(gdb) printf \"%s\\n\", 0x41414ac3\necho\n(gdb) printf \"%s\\n\", 0x41414ac8\ndebug\n```\n\nLet's see what these do.\n\n```\n> version\nVersion 0.3\n> shell\nSecurity made us disable the shell, sorry!\n> echo hi\nhi\n> debug\nDebug data dump:\n pid=30575 cmds executed=0x41616134->8 Mappings:\n───────┬─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n       │ File: /proc/30575/maps\n───────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n   1   │ 00400000-00401000 r-xp 00000000 08:04 315016                             /home/jyn/Documents/Programming/challenges/googlectf/mngmnt\n   2   │ 41414000-41415000 r-xp 00014000 08:04 315016                             /home/jyn/Documents/Programming/challenges/googlectf/mngmnt\n   3   │ 41615000-41616000 r--p 00015000 08:04 315016                             /home/jyn/Documents/Programming/challenges/googlectf/mngmnt\n   4   │ 41616000-41617000 rw-p 00016000 08:04 315016                             /home/jyn/Documents/Programming/challenges/googlectf/mngmnt\n   5   │ 41617000-41638000 rw-p 00000000 00:00 0                                  [heap]\n   6   │ 7ffff70a5000-7ffff728c000 r-xp 00000000 08:05 1840331                    /lib/x86_64-linux-gnu/libc-2.27.so\n   7   │ 7ffff728c000-7ffff748c000 ---p 001e7000 08:05 1840331                    /lib/x86_64-linux-gnu/libc-2.27.so\n   8   │ 7ffff748c000-7ffff7490000 r--p 001e7000 08:05 1840331                    /lib/x86_64-linux-gnu/libc-2.27.so\n   9   │ 7ffff7490000-7ffff7492000 rw-p 001eb000 08:05 1840331                    /lib/x86_64-linux-gnu/libc-2.27.so\n  10   │ 7ffff7492000-7ffff7496000 rw-p 00000000 00:00 0 \n  11   │ 7ffff7496000-7ffff74ad000 r-xp 00000000 08:05 1840694                    /lib/x86_64-linux-gnu/libgcc_s.so.1\n  12   │ 7ffff74ad000-7ffff76ac000 ---p 00017000 08:05 1840694                    /lib/x86_64-linux-gnu/libgcc_s.so.1\n  13   │ 7ffff76ac000-7ffff76ad000 r--p 00016000 08:05 1840694                    /lib/x86_64-linux-gnu/libgcc_s.so.1\n  14   │ 7ffff76ad000-7ffff76ae000 rw-p 00017000 08:05 1840694                    /lib/x86_64-linux-gnu/libgcc_s.so.1\n  15   │ 7ffff76ae000-7ffff784b000 r-xp 00000000 08:05 1840394                    /lib/x86_64-linux-gnu/libm-2.27.so\n  16   │ 7ffff784b000-7ffff7a4a000 ---p 0019d000 08:05 1840394                    /lib/x86_64-linux-gnu/libm-2.27.so\n  17   │ 7ffff7a4a000-7ffff7a4b000 r--p 0019c000 08:05 1840394                    /lib/x86_64-linux-gnu/libm-2.27.so\n  18   │ 7ffff7a4b000-7ffff7a4c000 rw-p 0019d000 08:05 1840394                    /lib/x86_64-linux-gnu/libm-2.27.so\n  19   │ 7ffff7a4c000-7ffff7bc5000 r-xp 00000000 08:05 1706663                    /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.25\n  20   │ 7ffff7bc5000-7ffff7dc5000 ---p 00179000 08:05 1706663                    /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.25\n  21   │ 7ffff7dc5000-7ffff7dcf000 r--p 00179000 08:05 1706663                    /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.25\n  22   │ 7ffff7dcf000-7ffff7dd1000 rw-p 00183000 08:05 1706663                    /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.25\n  23   │ 7ffff7dd1000-7ffff7dd5000 rw-p 00000000 00:00 0 \n  24   │ 7ffff7dd5000-7ffff7dfc000 r-xp 00000000 08:05 1840303                    /lib/x86_64-linux-gnu/ld-2.27.so\n  25   │ 7ffff7fc4000-7ffff7fca000 rw-p 00000000 00:00 0 \n  26   │ 7ffff7ff7000-7ffff7ffa000 r--p 00000000 00:00 0                          [vvar]\n  27   │ 7ffff7ffa000-7ffff7ffc000 r-xp 00000000 00:00 0                          [vdso]\n  28   │ 7ffff7ffc000-7ffff7ffd000 r--p 00027000 08:05 1840303                    /lib/x86_64-linux-gnu/ld-2.27.so\n  29   │ 7ffff7ffd000-7ffff7ffe000 rw-p 00028000 08:05 1840303                    /lib/x86_64-linux-gnu/ld-2.27.so\n  30   │ 7ffff7ffe000-7ffff7fff000 rw-p 00000000 00:00 0 \n  31   │ 7ffffffdd000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]\n  32   │ ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]\n> quit\nBye!\n```\n\nWell, no dice. That debug info is a little strange.\nAnd why have a shell option if it's disabled?\nLet's look at that more closely.\n\n```\n   0x0000000041414317 <+137>:   lea    0x76e(%rip),%rsi        # 0x41414a8c\n   0x000000004141431e <+144>:   mov    %rax,%rdi\n   0x0000000041414321 <+147>:   callq  0x400ba0 <strcmp@plt>\n   0x0000000041414326 <+152>:   test   %eax,%eax\n   0x0000000041414328 <+154>:   jne    0x41414353 <command_line()+197>\n   0x000000004141432a <+156>:   movzbl 0x201e07(%rip),%eax        # 0x41616138 <_ZL13shell_enabled>\n   0x0000000041414331 <+163>:   xor    $0x1,%eax\n   0x0000000041414334 <+166>:   test   %al,%al\n   0x0000000041414336 <+168>:   je     0x41414349 <command_line()+187>\n   0x0000000041414338 <+170>:   lea    0x759(%rip),%rdi        # 0x41414a98\n   0x000000004141433f <+177>:   callq  0x400a90 <puts@plt>\n   0x0000000041414344 <+182>:   jmpq   0x4141429a <command_line()+12>\n   0x0000000041414349 <+187>:   callq  0x41414227 <debug_shell()>\n```\n\nThis is basically doing three things - checking if we input 'shell',\nchecking if `_ZL13shell_enabled` is 0, and if so launching a shell on the host.\nUnfortunately, `_ZL13shell_enabled` is _always_ 0. What can we do?\n\nWell, the challenge description mentioned memory.\nCould there be a buffer overrun somewhere? Let's open gdb and check it out.\nFor this bit I'm actually going to use a gdb addon called\n[peda](https://github.com/longld/peda) which makes debugging much nicer\nwithout changing any behaviour.\n\nWhat happens if we put in a really long string?\n\n```\n\n!-->\n<p>(Challenge 3 will probably not be forthcoming, I finished it but never got around to writing it up.)</p>",
  "id": "https://jyn.dev/buffer-overflows-and-stacks-and-assembly-oh-my/"
}