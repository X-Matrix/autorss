{
  "title": "Programming vs. Coding vs. Software Engineering",
  "link": "https://rakhim.exotext.com/programming-vs-coding-vs-software-engineering",
  "published": "Wed, 27 Nov 2019 00:00:00 GMT",
  "summary": "<p>Programming, coding, and software engineering are often used interchangeably. Here is how I usually think of them.</p>\n<h2>Programming</h2>\n<blockquote>\n<p><strong>Programming is solving explicit problems in a verifiable manner.</strong></p>\n</blockquote>\n<p>It is similar to mathematical proofs. &quot;Find an element in a sorted sequence&quot; is a problem. A binary search algorithm is a solution. You can prove it works, and even analyze whether it's optimal in terms of time or memory.</p>\n<p>A better word for programming might be <em>computing</em>—a branch of mathematics. At this level, code isn't the focus; algorithms are. Only <strong>essential complexity</strong> matters. <strong>Accidental complexity</strong> doesn't exist here.</p>\n<p>The goal of programming is to create an algorithm—or prove that one cannot exist.</p>\n<h2>Coding</h2>\n<blockquote>\n<p><strong>Coding is expressing a programming solution in a formal language.</strong></p>\n</blockquote>\n<p>It’s like writing or speaking. Binary search can be coded imperatively in C or JavaScript, or declaratively in Haskell. The implementation details differ, but the algorithm remains the same.</p>\n<p>Coding is both easier and harder than programming. Easier, because it assumes the problem is already solved. Harder, because translating an abstract solution into a real system often introduces vague, hard-to-verify constraints (e.g., &quot;make it work on every device&quot;).</p>\n<p>In a perfect world, coding would be strictly simpler than programming. In reality, it introduces a lot of accidental complexity.</p>\n<p>The goal of coding is to produce working code.</p>\n<h2>Software engineering</h2>\n<blockquote>\n<p><strong>Software engineering is building a product for the real world.</strong></p>\n</blockquote>\n<p>Think of “product” not just in commercial terms. A product is anything that solves a real-world problem and can be used by someone other than its creator.</p>\n<p>It’s similar to civil engineering. Software engineering includes programming and coding, but also:</p>\n<ul>\n<li>communication</li>\n<li>management</li>\n<li>compliance</li>\n<li>durability</li>\n<li>scalability</li>\n</ul>\n<p>Depending on the context—cultural, historical, or organizational—software engineering may encompass even more responsibilities. It’s where most <strong>accidental complexity</strong> shows up.</p>\n<p>The goal of software engineering is to solve real-world problems.</p>\n<h2>Bang, Marry, Kill</h2>\n<p>For many softwave developers, this is true:</p>\n<ol>\n<li>Love programming.</li>\n<li>Enjoy coding.</li>\n<li>Tolerate software engineering.</li>\n</ol>\n<p>Since real-world tech jobs blend all three, many of us return even after burnout. We love programming. Burnout tends to come from engineering, sometimes coding, but rarely from pure programming.</p>\n<p>We dream of a world where we craft elegant algorithms in a clean, mathematical space—then implement them in a perfect language, running in a well-designed system. Instead, we deal with inconsistent formats, ambiguous requirements, needless complexity, infrastructure, deployment, deliveries, backups, relationships, communication, politics, finance, etc.</p>\n<h2>Why differentiate</h2>\n<p>These distinctions aren’t always useful in daily life—we often lump everything together as “programming.” But in moments of reflection, they help. When I feel energized, I want to understand what drives me. When I feel drained, I want to identify the cause.</p>\n<p>They’re also helpful when asking: Which of the three do I enjoy most?\nThere are no wrong answers. Programming isn’t sacred. Engineering isn’t dirty. Coding isn’t trivial.</p>",
  "id": "https://rakhim.exotext.com/programming-vs-coding-vs-software-engineering"
}