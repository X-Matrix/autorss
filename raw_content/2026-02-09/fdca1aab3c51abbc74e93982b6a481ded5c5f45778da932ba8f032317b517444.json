{
  "title": "I made a little audio speed calculator",
  "link": "https://evanhahn.com/playback-speed-calculator/",
  "published": "Wed, 03 Dec 2025 00:00:00 +0000",
  "summary": "<p><img alt=\"\" src=\"./screenshot.avif\" /></p><p>I was recently listening to an 8-hour-and-51-minute audiobook, and wanted to know how much time I&rsquo;d save if I listened to it on 1.5× speed.</p>\n<p>This math is easy enough; divide 8 hours and 51 minutes by 1.5 to get the new duration: 5 hours and 54 minutes. But I also wanted to:</p>\n<ol>\n<li>See the final duration along with the time I&rsquo;d save (with some simple subtraction).</li>\n<li>Compare different speeds. How much more time would I save with 1.6× speed, for example?</li>\n<li>Enter the time in plain English: &ldquo;8 hours 51 minutes&rdquo; instead of &ldquo;531 minutes&rdquo;.</li>\n</ol>\n<p>So I built a little web tool to do this: the <a href=\"https://evanhahn.com/uploads/2025-12-03-playback-speed-calculator/\">playback speed calculator</a>. You enter a time in English, and you get a big table showing the duration and savings for 1.1× speed, 1.2× speed, and so on.</p>\n<h2 id=\"did-llms-help\">Did LLMs help?</h2>\n<p>This is the kind of software modern LLMs can &ldquo;one-shot&rdquo;. You give them a description in plain English, and they produce all the code. And indeed, this was how I built the first version! I prompted an LLM with the app I wanted, and it mostly worked. I had to make a few tiny tweaks to fix a few tiny errors, but it was totally usable in this version, and <em>significantly</em> quicker than scaffolding it myself.</p>\n<p>But I wanted to turn this prototype into something I could share with others. I didn&rsquo;t want it to be a buggy mess! Unfortunately, there were a number of things the LLM failed to do in the first version:</p>\n<ul>\n<li>It made a basic accessibility mistake, failing to associate the <code>&lt;input&gt;</code> with any label.</li>\n<li>The code for parsing inputs had a number of inefficiencies.</li>\n<li>It had very simplistic handling of error cases.</li>\n<li>The tool had a very generic generated-by-LLM look. I don&rsquo;t know exactly how to describe it, but it had the vibe that it was not human-made.</li>\n<li>No dark mode support.</li>\n<li>No thought for users who have JavaScript disabled.</li>\n<li>A number of other little things needed fixing, such as using the &ldquo;×&rdquo; symbol (<code>&amp;times;</code>) instead of the letter X.</li>\n</ul>\n<p>The LLM also made a number of decisions I wouldn&rsquo;t have made that weren&rsquo;t necessarily errors. For example, it showed milliseconds instead of rounding seconds, and it added hover states I wouldn&rsquo;t have. I can&rsquo;t fault it for that—I wasn&rsquo;t explicit about what I wanted in the instructions—but there were a <em>lot</em> of things I went back and corrected.</p>\n<p>In fact, I changed almost all the significant code the LLM wrote. For example, the code that parses &ldquo;4 minutes 20 seconds&rdquo; looks very different. I kept bits and pieces of the LLM&rsquo;s approach, but it&rsquo;s pretty substantially different in my version—enough to say I completely rewrote it. This was true for almost all of the LLM&rsquo;s work.</p>\n<p>Did the LLM make me more effective? It was <em>definitely</em> faster to build the prototype. I&rsquo;m not sure it was faster for me overall, though, because I spent a lot of time correcting the code—either due to unambiguous errors or due to my persnickety preferences.</p>\n<h2 id=\"a-little-app-for-me\">A little app for me</h2>\n<p>This was a nice reminder that it&rsquo;s fun to build software just for yourself.</p>\n<p>I didn&rsquo;t have to worry that I was disappointing my users, because it&rsquo;s just for me! I knew exactly what I wanted and I built it.</p>\n<p>I also thought about how long it took to turn the prototype into something I considered finished. If I wanted it to be usable with a few rough edges, this could have been <em>done and deployed in under 10 minutes</em>. But I wound up spending a few hours on this simple tool! This is partly because &ldquo;productionizing&rdquo; usually takes the longest, and partly because I was particular.</p>\n<p><a href=\"https://evanhahn.com/how-i-build-software-quickly/\">When I&rsquo;m developing software in a professional context, I try to relax my perfectionism most of the time because that attitude clashes with deadlines.</a> But it&rsquo;s fun to try to do it &ldquo;the right way&rdquo; sometimes&hellip;at least by my personal definition.</p>\n<p>If you&rsquo;re listening to a long audiobook and want to know whether you should listen on 1.2× or 1.3× speed, I hope you&rsquo;ll <a href=\"https://evanhahn.com/uploads/2025-12-03-playback-speed-calculator/\">give my little app a try</a>.</p>",
  "id": "https://evanhahn.com/playback-speed-calculator/"
}