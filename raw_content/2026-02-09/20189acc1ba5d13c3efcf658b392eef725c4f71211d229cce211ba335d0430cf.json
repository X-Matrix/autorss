{
  "title": "A multi-entry CFG design conundrum",
  "link": "https://bernsteinbear.com/blog/multiple-entry/?utm_source=rss",
  "published": "Thu, 22 Jan 2026 00:00:00 +0000",
  "summary": "<h2 id=\"background-and-bytecode-design\">Background and bytecode design</h2>\n\n<p>The ZJIT compiler compiles Ruby bytecode (YARV) to machine code. It starts by\ntransforming the stack machine bytecode into a high-level graph-based\nintermediate representation called HIR.</p>\n\n<p>We use a more or less typical<sup id=\"fnref:ebb\"><a class=\"footnote\" href=\"#fn:ebb\" rel=\"footnote\">1</a></sup> control-flow graph (CFG) in HIR. We have a\ncompilation unit, <code class=\"language-plaintext highlighter-rouge\">Function</code>, which has multiple basic blocks, <code class=\"language-plaintext highlighter-rouge\">Block</code>. Each\nblock contains multiple instructions, <code class=\"language-plaintext highlighter-rouge\">Insn</code>. HIR is always in SSA form, and we\nuse the variant of SSA with block parameters instead of phi nodes.</p>\n\n<p>Where it gets weird, though, is our handling of multiple entrypoints. See, YARV\nhandles default positional parameters (but <em>not</em> default keyword parameters) by\nembedding the code to compute the defaults inside the callee bytecode. Then\ncallers are responsible for figuring out what offset in the bytecode they\nshould start running the callee, depending on the amount of arguments the\ncaller provides.<sup id=\"fnref:keywords\"><a class=\"footnote\" href=\"#fn:keywords\" rel=\"footnote\">2</a></sup></p>\n\n<p>In the following example, we have a function that takes two optional positional\nparameters <code class=\"language-plaintext highlighter-rouge\">a</code> and <code class=\"language-plaintext highlighter-rouge\">b</code>. If neither is provided, we start at offset <code class=\"language-plaintext highlighter-rouge\">0000</code>. If\njust <code class=\"language-plaintext highlighter-rouge\">a</code> is provided, we start at offset <code class=\"language-plaintext highlighter-rouge\">0005</code>. If both are provided, we can\nstart at offset <code class=\"language-plaintext highlighter-rouge\">0010</code>.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ ruby --dump=insns -e 'def foo(a=compute_a, b=compute_b) = a + b'\n...\n== disasm: #&lt;ISeq:foo@-e:1 (1,0)-(1,41)&gt;\nlocal table (size: 2, argc: 0 [opts: 2, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])\n[ 2] a@0&lt;Opt=0&gt; [ 1] b@1&lt;Opt=5&gt;\n0000 putself                                                          (   1)\n0001 opt_send_without_block   &lt;calldata!mid:compute_a, argc:0, FCALL|VCALL|ARGS_SIMPLE&gt;\n0003 setlocal_WC_0            a@0\n0005 putself\n0006 opt_send_without_block   &lt;calldata!mid:compute_b, argc:0, FCALL|VCALL|ARGS_SIMPLE&gt;\n0008 setlocal_WC_0            b@1\n0010 getlocal_WC_0            a@0[Ca]\n0012 getlocal_WC_0            b@1\n0014 opt_plus                 &lt;calldata!mid:+, argc:1, ARGS_SIMPLE&gt;[CcCr]\n0016 leave                    [Re]\n$\n</code></pre></div></div>\n\n<p>(See the jump table debug output: <code class=\"language-plaintext highlighter-rouge\">[ 2] a@0&lt;Opt=0&gt; [ 1] b@1&lt;Opt=5&gt;</code>)</p>\n\n<p>Unlike in Python, where default arguments are evaluated <em>at function creation\ntime</em>, Ruby computes the default values <em>at function call time</em>. This includes\narbitrary function calls, raising exceptions, doing long I/O, or whatever your\nheart desires. For this reason, embedding the default code inside the callee\nmakes a lot of sense; we have a full call frame already set up, so any\noptimizations (!), side-exits, exception handling machinery, profiling, etc\ndoesn’t need special treatment.</p>\n\n<p>Since the caller knows what arguments it is passing, and often to what\nfunction, we can efficiently support this in the JIT. We just need to know what\noffset in the compiled callee to call into. The interpreter can also call into\nthe compiled function, which just has a stub to do dispatch to the appropriate\nentry block.</p>\n\n<p>This has led us to design the HIR to support <em>multiple function entrypoints</em>.\nInstead of having just a single entry block, as most control-flow graphs do,\neach of our functions now has an array of function entries: one for the\ninterpreter, at least one for the JIT, and more for default parameter handling.\nEach of these entry blocks is separately callable from the outside world.</p>\n\n<p>Here is what the (slightly cleaned up) HIR looks like for the above example:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Optimized HIR:\nfn foo@tmp/branchnil.rb:4:\nbb0():\n  EntryPoint interpreter\n  v1:BasicObject = LoadSelf\n  v2:BasicObject = GetLocal :a, l0, SP@5\n  v3:BasicObject = GetLocal :b, l0, SP@4\n  v4:CPtr = LoadPC\n  v5:CPtr[CPtr(0x16d27e908)] = Const CPtr(0x16d282120)\n  v6:CBool = IsBitEqual v4, v5\n  IfTrue v6, bb2(v1, v2, v3)\n  v8:CPtr[CPtr(0x16d27e908)] = Const CPtr(0x16d282120)\n  v9:CBool = IsBitEqual v4, v8\n  IfTrue v9, bb4(v1, v2, v3)\n  Jump bb6(v1, v2, v3)\nbb1(v13:BasicObject):\n  EntryPoint JIT(0)\n  v14:NilClass = Const Value(nil)\n  v15:NilClass = Const Value(nil)\n  Jump bb2(v13, v14, v15)\nbb2(v27:BasicObject, v28:BasicObject, v29:BasicObject):\n  v65:HeapObject[...] = GuardType v27, HeapObject[class_exact*:Object@VALUE(0x1043aed00)]\n  v66:BasicObject = SendWithoutBlockDirect v65, :compute_a (0x16d282148)\n  Jump bb4(v27, v66, v29)\nbb3(v18:BasicObject, v19:BasicObject):\n  EntryPoint JIT(1)\n  v20:NilClass = Const Value(nil)\n  Jump bb4(v18, v19, v20)\nbb4(v38:BasicObject, v39:BasicObject, v40:BasicObject):\n  v69:HeapObject[...] = GuardType v38, HeapObject[class_exact*:Object@VALUE(0x1043aed00)]\n  v70:BasicObject = SendWithoutBlockDirect v69, :compute_b (0x16d282148)\n  Jump bb6(v38, v39, v70)\nbb5(v23:BasicObject, v24:BasicObject, v25:BasicObject):\n  EntryPoint JIT(2)\n  Jump bb6(v23, v24, v25)\nbb6(v49:BasicObject, v50:BasicObject, v51:BasicObject):\n  v73:Fixnum = GuardType v50, Fixnum\n  v74:Fixnum = GuardType v51, Fixnum\n  v75:Fixnum = FixnumAdd v73, v74\n  CheckInterrupts\n  Return v75\n</code></pre></div></div>\n\n<p>If you’re not a fan of text HIR, here is an embedded clickable visualization of\nHIR thanks to our former intern <a href=\"https://aidenfoxivey.com/\">Aiden</a> porting\nFirefox’s <a href=\"https://github.com/mozilla-spidermonkey/iongraph\">Iongraph</a>:</p>\n\n\n\n<p>(You might have to scroll sideways and down and zoom around. Or you can <a href=\"/assets/zjit-multi-entry-iongraph.html\">open it\nin its own window</a>.)</p>\n\n<p>Each entry block also comes with block parameters which mirror the function’s\nparameters. These get passed in (roughly) the System V ABI registers.</p>\n\n<p>This is kind of gross. We have to handle these blocks specially in reverse\npost-order (RPO) graph traversal. And, recently, I ran into an even worse case\nwhen trying to implement the Cooper-style “engineered” dominator algorithm: if\nwe walk backwards in block dominators, the walk is not guaranteed to converge.\nAll non-entry blocks are dominated by all entry blocks, which are only\ndominated by themselves. There is no one “start block”. So what is there to do?</p>\n\n<h2 id=\"the-design-conundrum\">The design conundrum</h2>\n\n<p><strong>Approach 1</strong> is to keep everything as-is, but handle entry blocks specially\nin the dominator algorithm too. I’m not exactly sure what would be needed, but\nit seems possible. Most of the existing block infra could be left alone, but\nit’s not clear how much this would “spread” within the compiler. What else in\nthe future might need to be handled specially?</p>\n\n<p><strong>Approach 2</strong> is to synthesize a super-entry block and make it a predecessor\nof every interpreter and JIT entry block. Inside this approach there are two\nways to do it: one (<strong>2.a</strong>) is to fake it and report some non-existent block.\nAnother (<strong>2.b</strong>) is to actually make a block and a new instruction that is a\nquasi-jump instruction. In this approach, we would either need to synthesize\nfake block arguments for the JIT entry block parameters or add some kind of new\n<code class=\"language-plaintext highlighter-rouge\">LoadArg&lt;i&gt;</code> instruction that reads the argument <em>i</em> passed in.</p>\n\n<p>(suggested by Iain Ireland, as seen in the IBM COBOL compiler)</p>\n\n<p><strong>Approach 3</strong> is to duplicate the entire CFG per entrypoint. This would return\nus to having one entry block per CFG at the expense of code duplication. It\nhandles the problem pretty cleanly but then <em>forces</em> code duplication. I think\nI want the duplication to be opt-in instead of having it be the only way we\nsupport multiple entrypoints. What if it increases memory too much? The\nspecialization probably would make the generated code faster, though.</p>\n\n<p>(suggested by Ben Titzer)</p>\n\n<p>None of these approaches feel great to me. The probable candidate is <strong>2.b</strong>\nwhere we have <code class=\"language-plaintext highlighter-rouge\">LoadArg</code> instructions. That gives us flexibility to also later\nadd full specialization without forcing it.</p>\n\n<p>Cameron Zwarich also notes that this this is an analogue to the common problem\npeople have when implementing the reverse: postdominators. This is because\noften functions have multiple return IR instructions. He notes the usual\nsolution is to transform them into branches to a single return instruction.</p>\n\n<p>Do you have this problem? What does your compiler do?</p>\n<div class=\"footnotes\">\n  <ol>\n    <li id=\"fn:ebb\">\n      <p>We use extended basic blocks (EBBs), but this doesn’t matter for this\npost. It makes dominators and predecessors slightly more complicated (now\nyou have dominating <em>instructions</em>), but that’s about it as far as I can\ntell. We’ll see how they fare in the face of more complicated analysis\nlater. <a class=\"reversefootnote\" href=\"#fnref:ebb\">&#8617;</a></p>\n    </li>\n    <li id=\"fn:keywords\">\n      <p>Keyword parameters have some mix of caller/callee presence checks\nin the callee because they are passed in un-ordered. The caller handles\nsimple constant defaults whereas the callee handles anything that may\nraise. Check out <a href=\"https://kddnewton.com/2022/12/17/advent-of-yarv-part-17\">Kevin Newton’s awesome overview</a>. <a class=\"reversefootnote\" href=\"#fnref:keywords\">&#8617;</a></p>\n    </li>\n  </ol>\n</div>",
  "id": "https://bernsteinbear.com/blog/multiple-entry/"
}