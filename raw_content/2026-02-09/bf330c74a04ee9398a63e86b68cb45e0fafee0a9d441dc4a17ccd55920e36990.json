{
  "title": "Load and store forwarding in the Toy Optimizer",
  "link": "https://bernsteinbear.com/blog/toy-load-store/?utm_source=rss",
  "published": "Wed, 24 Dec 2025 00:00:00 +0000",
  "summary": "<p><em>Another entry in the <a href=\"https://pypy.org/categories/toy-optimizer.html\">Toy Optimizer series</a></em>.</p>\n\n<p>A long, long time ago (two years!) <a href=\"https://cfbolz.de/\">CF Bolz-Tereick</a> and I made a <a href=\"https://www.youtube.com/watch?v=w-UHg0yOPSE\">video\nabout load/store forwarding</a> and an accompanying <a href=\"https://gist.github.com/tekknolagi/4e3fa26d350f6d3b39ede40d372b97fe\">GitHub Gist</a>\nabout load/store forwarding (also called load elimination) in the Toy Optimizer. I\nsaid I would write a blog post about it, but never found the time—it got lost\namid a sea of large life changes.</p>\n\n<p>It’s a neat idea: do an abstract interpretation over the trace, modeling the\nheap at compile-time, eliminating redundant loads and stores. That means it’s\npossible to optimize traces like this:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>v0 = ...\nv1 = load(v0, 5)\nv2 = store(v0, 6, 123)\nv3 = load(v0, 6)\nv4 = load(v0, 5)\nv5 = do_something(v1, v3, v4)\n</code></pre></div></div>\n\n<p>into traces like this:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>v0 = ...\nv1 = load(v0, 5)\nv2 = store(v0, 6, 123)\nv5 = do_something(v1, 123, v1)\n</code></pre></div></div>\n\n<p>(where <code class=\"language-plaintext highlighter-rouge\">load(v0, 5)</code> is equivalent to <code class=\"language-plaintext highlighter-rouge\">*(v0+5)</code> in C syntax and <code class=\"language-plaintext highlighter-rouge\">store(v0, 6,\n123)</code> is equvialent to <code class=\"language-plaintext highlighter-rouge\">*(v0+6)=123</code> in C syntax)</p>\n\n<p>This indicates that we were able to eliminate two redundant loads by keeping\naround information about previous loads and stores. Let’s get to work making\nthis possible.</p>\n\n<h2 id=\"the-usual-infrastructure\">The usual infrastructure</h2>\n\n<p>We’ll start off with the usual infrastructure from the <a href=\"https://pypy.org/categories/toy-optimizer.html\">Toy\nOptimizer series</a>: a very stringly-typed representation of a\n<a href=\"https://gist.github.com/tekknolagi/4e3fa26d350f6d3b39ede40d372b97fe#file-port-py-L4-L112\">trace-based SSA IR</a> and a union-find rewrite mechanism.</p>\n\n<p>This means we can start writing some new optimization pass and our first test:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">optimize_load_store</span><span class=\"p\">(</span><span class=\"n\">bb</span><span class=\"p\">:</span> <span class=\"n\">Block</span><span class=\"p\">):</span>\n    <span class=\"n\">opt_bb</span> <span class=\"o\">=</span> <span class=\"n\">Block</span><span class=\"p\">()</span>\n    <span class=\"c1\"># TODO: copy an optimized version of bb into opt_bb\n</span>    <span class=\"k\">return</span> <span class=\"n\">opt_bb</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test_two_loads</span><span class=\"p\">():</span>\n    <span class=\"n\">bb</span> <span class=\"o\">=</span> <span class=\"n\">Block</span><span class=\"p\">()</span>\n    <span class=\"n\">var0</span> <span class=\"o\">=</span> <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">getarg</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">var1</span> <span class=\"o\">=</span> <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">var0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">var2</span> <span class=\"o\">=</span> <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">var0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">escape</span><span class=\"p\">(</span><span class=\"n\">var1</span><span class=\"p\">)</span>\n    <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">escape</span><span class=\"p\">(</span><span class=\"n\">var2</span><span class=\"p\">)</span>\n    <span class=\"n\">opt_bb</span> <span class=\"o\">=</span> <span class=\"n\">optimize_load_store</span><span class=\"p\">(</span><span class=\"n\">bb</span><span class=\"p\">)</span>\n    <span class=\"k\">assert</span> <span class=\"n\">bb_to_str</span><span class=\"p\">(</span><span class=\"n\">opt_bb</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"s\">\"\"\"</span><span class=\"se\">\\\n</span><span class=\"s\">var0 = getarg(0)\nvar1 = load(var0, 0)\nvar2 = escape(var1)\nvar3 = escape(var1)\"\"\"</span>\n</code></pre></div></div>\n\n<p>This test is asserting that we can remove duplicate loads. Why load twice if we\ncan cache the result? Let’s make that happen.</p>\n\n<h2 id=\"caching-loads\">Caching loads</h2>\n\n<p>To do this, we’ll model the the heap at compile-time. When I say “model”, I\nmean that we will have an imprecise but correct abstract representation of the\nheap: we don’t (and can’t) have knowledge of every value, but we can know for\nsure that some addresses have certain values.</p>\n\n<p>For example, if we have observed a load from object <em>O</em> at offset <em>8</em> <code class=\"language-plaintext highlighter-rouge\">v0 =\nload(O, 8)</code>, we know that the SSA value <code class=\"language-plaintext highlighter-rouge\">v0</code> is at <code class=\"language-plaintext highlighter-rouge\">heap[(O, 8)]</code>. That sounds\ntautological, but it’s not. Future loads can make use of this information.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">get_num</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">:</span> <span class=\"n\">Operation</span><span class=\"p\">,</span> <span class=\"n\">index</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n    <span class=\"k\">assert</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">arg</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">),</span> <span class=\"n\">Constant</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">arg</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">).</span><span class=\"n\">value</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">optimize_load_store</span><span class=\"p\">(</span><span class=\"n\">bb</span><span class=\"p\">:</span> <span class=\"n\">Block</span><span class=\"p\">):</span>\n    <span class=\"n\">opt_bb</span> <span class=\"o\">=</span> <span class=\"n\">Block</span><span class=\"p\">()</span>\n    <span class=\"c1\"># Stores things we know about the heap at... compile-time.\n</span>    <span class=\"c1\"># Key: an object and an offset pair acting as a heap address\n</span>    <span class=\"c1\"># Value: a previous SSA value we know exists at that address\n</span>    <span class=\"n\">compile_time_heap</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Value</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">Value</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n    <span class=\"k\">for</span> <span class=\"n\">op</span> <span class=\"ow\">in</span> <span class=\"n\">bb</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s\">\"load\"</span><span class=\"p\">:</span>\n            <span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">arg</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n            <span class=\"n\">offset</span> <span class=\"o\">=</span> <span class=\"n\">get_num</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n            <span class=\"n\">load_info</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">offset</span><span class=\"p\">)</span>\n            <span class=\"n\">previous</span> <span class=\"o\">=</span> <span class=\"n\">compile_time_heap</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">load_info</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"n\">previous</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n                <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">make_equal_to</span><span class=\"p\">(</span><span class=\"n\">previous</span><span class=\"p\">)</span>\n                <span class=\"k\">continue</span>\n            <span class=\"n\">compile_time_heap</span><span class=\"p\">[</span><span class=\"n\">load_info</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">op</span>\n        <span class=\"n\">opt_bb</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">opt_bb</span>\n</code></pre></div></div>\n\n<p>This pass records information about loads and uses the result of a previous\ncached load operation if available. We treat the pair of (SSA value, offset) as\nan address into our abstract heap.</p>\n\n<p>That’s great! If you run our simple test, it should now pass. But what happens\nif we store into that address before the second load? Oops…</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">test_store_to_same_object_offset_invalidates_load</span><span class=\"p\">():</span>\n    <span class=\"n\">bb</span> <span class=\"o\">=</span> <span class=\"n\">Block</span><span class=\"p\">()</span>\n    <span class=\"n\">var0</span> <span class=\"o\">=</span> <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">getarg</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">var1</span> <span class=\"o\">=</span> <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">var0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">var2</span> <span class=\"o\">=</span> <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">(</span><span class=\"n\">var0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n    <span class=\"n\">var3</span> <span class=\"o\">=</span> <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">var0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">escape</span><span class=\"p\">(</span><span class=\"n\">var1</span><span class=\"p\">)</span>\n    <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">escape</span><span class=\"p\">(</span><span class=\"n\">var3</span><span class=\"p\">)</span>\n    <span class=\"n\">opt_bb</span> <span class=\"o\">=</span> <span class=\"n\">optimize_load_store</span><span class=\"p\">(</span><span class=\"n\">bb</span><span class=\"p\">)</span>\n    <span class=\"k\">assert</span> <span class=\"n\">bb_to_str</span><span class=\"p\">(</span><span class=\"n\">opt_bb</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"s\">\"\"\"</span><span class=\"se\">\\\n</span><span class=\"s\">var0 = getarg(0)\nvar1 = load(var0, 0)\nvar2 = store(var0, 0, 5)\nvar3 = load(var0, 0)\nvar4 = escape(var1)\nvar5 = escape(var3)\"\"\"</span>\n</code></pre></div></div>\n\n<p>This test fails because we are incorrectly keeping around <code class=\"language-plaintext highlighter-rouge\">var1</code> in our\nabstract heap. We need to get rid of it and not replace <code class=\"language-plaintext highlighter-rouge\">var3</code> with <code class=\"language-plaintext highlighter-rouge\">var1</code>.</p>\n\n<h2 id=\"invalidating-cached-loads\">Invalidating cached loads</h2>\n\n<p>So it turns out we have to also model stores in order to cache loads correctly.\nOne valid, albeit aggressive, way to do that is to throw away all the\ninformation we know at each store operation:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">optimize_load_store</span><span class=\"p\">(</span><span class=\"n\">bb</span><span class=\"p\">:</span> <span class=\"n\">Block</span><span class=\"p\">):</span>\n    <span class=\"n\">opt_bb</span> <span class=\"o\">=</span> <span class=\"n\">Block</span><span class=\"p\">()</span>\n    <span class=\"n\">compile_time_heap</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Value</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">Value</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n    <span class=\"k\">for</span> <span class=\"n\">op</span> <span class=\"ow\">in</span> <span class=\"n\">bb</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s\">\"store\"</span><span class=\"p\">:</span>\n            <span class=\"n\">compile_time_heap</span><span class=\"p\">.</span><span class=\"n\">clear</span><span class=\"p\">()</span>\n        <span class=\"k\">elif</span> <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s\">\"load\"</span><span class=\"p\">:</span>\n            <span class=\"c1\"># ...\n</span>        <span class=\"n\">opt_bb</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">opt_bb</span>\n</code></pre></div></div>\n\n<p>That makes our test pass—yay!—but at great cost. It means any store\noperation mucks up redundant loads. In our world where we frequently read from\nand write to objects, this is what we call a huge bummer.</p>\n\n<p>For example, a store to offset 4 on some object should never interfere with a\nload from a different offset on the same object<sup id=\"fnref:size\"><a class=\"footnote\" href=\"#fn:size\" rel=\"footnote\">1</a></sup>. We should be able to\nkeep our load from offset 0 cached here:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">test_store_to_same_object_different_offset_does_not_invalidate_load</span><span class=\"p\">():</span>\n    <span class=\"n\">bb</span> <span class=\"o\">=</span> <span class=\"n\">Block</span><span class=\"p\">()</span>\n    <span class=\"n\">var0</span> <span class=\"o\">=</span> <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">getarg</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">var1</span> <span class=\"o\">=</span> <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">var0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">var2</span> <span class=\"o\">=</span> <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">(</span><span class=\"n\">var0</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n    <span class=\"n\">var3</span> <span class=\"o\">=</span> <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">var0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">escape</span><span class=\"p\">(</span><span class=\"n\">var1</span><span class=\"p\">)</span>\n    <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">escape</span><span class=\"p\">(</span><span class=\"n\">var3</span><span class=\"p\">)</span>\n    <span class=\"n\">opt_bb</span> <span class=\"o\">=</span> <span class=\"n\">optimize_load_store</span><span class=\"p\">(</span><span class=\"n\">bb</span><span class=\"p\">)</span>\n    <span class=\"k\">assert</span> <span class=\"n\">bb_to_str</span><span class=\"p\">(</span><span class=\"n\">opt_bb</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"s\">\"\"\"</span><span class=\"se\">\\\n</span><span class=\"s\">var0 = getarg(0)\nvar1 = load(var0, 0)\nvar2 = store(var0, 4, 5)\nvar3 = escape(var1)\nvar4 = escape(var1)\"\"\"</span>\n</code></pre></div></div>\n\n<p>We could try instead checking if our specific (object, offset) pair is in the\nheap and only removing cached information about that offset and that object.\nThat would definitely help!</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">optimize_load_store</span><span class=\"p\">(</span><span class=\"n\">bb</span><span class=\"p\">:</span> <span class=\"n\">Block</span><span class=\"p\">):</span>\n    <span class=\"n\">opt_bb</span> <span class=\"o\">=</span> <span class=\"n\">Block</span><span class=\"p\">()</span>\n    <span class=\"n\">compile_time_heap</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Value</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">Value</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n    <span class=\"k\">for</span> <span class=\"n\">op</span> <span class=\"ow\">in</span> <span class=\"n\">bb</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s\">\"store\"</span><span class=\"p\">:</span>\n            <span class=\"n\">load_info</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">arg</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">),</span> <span class=\"n\">get_num</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">))</span>\n            <span class=\"k\">if</span> <span class=\"n\">load_info</span> <span class=\"ow\">in</span> <span class=\"n\">compile_time_heap</span><span class=\"p\">:</span>\n                <span class=\"k\">del</span> <span class=\"n\">compile_time_heap</span><span class=\"p\">[</span><span class=\"n\">load_info</span><span class=\"p\">]</span>\n        <span class=\"k\">elif</span> <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s\">\"load\"</span><span class=\"p\">:</span>\n            <span class=\"c1\"># ...\n</span>        <span class=\"n\">opt_bb</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">opt_bb</span>\n</code></pre></div></div>\n\n<p>It makes our test pass, too, which is great news.</p>\n\n<p>Unfortunately, this runs into problems due to aliasing: it’s entirely possible\nthat our compile-time heap could contain a pair <code class=\"language-plaintext highlighter-rouge\">(v0, 0)</code> and a pair <code class=\"language-plaintext highlighter-rouge\">(v1, 0)</code> where <code class=\"language-plaintext highlighter-rouge\">v0</code>\nand <code class=\"language-plaintext highlighter-rouge\">v1</code> are the same object (but not known to the optimizer). Then we might\nrun into a situation where we incorrectly cache loads because the optimizer\ndoesn’t know our abstract addresses <code class=\"language-plaintext highlighter-rouge\">(v0, 0)</code> and <code class=\"language-plaintext highlighter-rouge\">(v1, 0)</code> are actually the\nsame pointer at run-time.</p>\n\n<p>This means that we are breaking abstract interpretation rules: our abstract\ninterpreter has to correctly model <em>all</em> possible outcomes at run-time. This\nmeans to me that we should instead pick some tactic in-between clearing all\ninformation (correct but over-eager) and clearing only exact matches of\nobject+offset (incorrect).</p>\n\n<p>The term that will help us here is called an <em>alias class</em>. It is a name for a\nway to efficiently partition objects in your abstract heap into completely\ndisjoint sets. Writes to any object in one class never affect objects in\nanother class.</p>\n\n<p>Our very scrappy alias classes will be just based on the offset: each offset is\na different alias class. If we write to any object at offset K, we have to\ninvalidate all of our compile-time offset K knowledge—even if it’s for\nanother object. This is a nice middle ground, and it’s possible because our\n(made up) object system guarantees that distinct objects do not overlap, and\nalso that we are not writing out-of-bounds.<sup id=\"fnref:tbaa\"><a class=\"footnote\" href=\"#fn:tbaa\" rel=\"footnote\">2</a></sup></p>\n\n<p>So let’s remove all of the entries from <code class=\"language-plaintext highlighter-rouge\">compile_time_heap</code> where the offset\nmatches the offset in the current <code class=\"language-plaintext highlighter-rouge\">store</code>:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">optimize_load_store</span><span class=\"p\">(</span><span class=\"n\">bb</span><span class=\"p\">:</span> <span class=\"n\">Block</span><span class=\"p\">):</span>\n    <span class=\"n\">opt_bb</span> <span class=\"o\">=</span> <span class=\"n\">Block</span><span class=\"p\">()</span>\n    <span class=\"n\">compile_time_heap</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Value</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">Value</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n    <span class=\"k\">for</span> <span class=\"n\">op</span> <span class=\"ow\">in</span> <span class=\"n\">bb</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s\">\"store\"</span><span class=\"p\">:</span>\n            <span class=\"n\">offset</span> <span class=\"o\">=</span> <span class=\"n\">get_num</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n            <span class=\"n\">compile_time_heap</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n                <span class=\"n\">load_info</span><span class=\"p\">:</span> <span class=\"n\">value</span>\n                <span class=\"k\">for</span> <span class=\"n\">load_info</span><span class=\"p\">,</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"n\">compile_time_heap</span><span class=\"p\">.</span><span class=\"n\">items</span><span class=\"p\">()</span>\n                <span class=\"k\">if</span> <span class=\"n\">load_info</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"n\">offset</span>\n            <span class=\"p\">}</span>\n        <span class=\"k\">elif</span> <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s\">\"load\"</span><span class=\"p\">:</span>\n            <span class=\"c1\"># ...\n</span>        <span class=\"n\">opt_bb</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">opt_bb</span>\n</code></pre></div></div>\n\n<p>Great! Now our test passes.</p>\n\n<p>This concludes the load optimization section of the post. We have modeled\nenough of loads and stores that we can eliminate redundant loads. Very cool.\nBut we can go further.</p>\n\n<h2 id=\"caching-stores\">Caching stores</h2>\n\n<p>Stores don’t just invalidate information. They also give us new information!\nAny time we see an operation of the form <code class=\"language-plaintext highlighter-rouge\">v1 = store(v0, 8, 5)</code> we also learn\nthat <code class=\"language-plaintext highlighter-rouge\">load(v0, 8) == 5</code>! Until it gets invalidated, anyway.</p>\n\n<p>For example, in this test, we can eliminate the load from <code class=\"language-plaintext highlighter-rouge\">var0</code> at offset 0:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">test_load_after_store_removed</span><span class=\"p\">():</span>\n    <span class=\"n\">bb</span> <span class=\"o\">=</span> <span class=\"n\">Block</span><span class=\"p\">()</span>\n    <span class=\"n\">var0</span> <span class=\"o\">=</span> <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">getarg</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">(</span><span class=\"n\">var0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n    <span class=\"n\">var1</span> <span class=\"o\">=</span> <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">var0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">var2</span> <span class=\"o\">=</span> <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">var0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">escape</span><span class=\"p\">(</span><span class=\"n\">var1</span><span class=\"p\">)</span>\n    <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">escape</span><span class=\"p\">(</span><span class=\"n\">var2</span><span class=\"p\">)</span>\n    <span class=\"n\">opt_bb</span> <span class=\"o\">=</span> <span class=\"n\">optimize_load_store</span><span class=\"p\">(</span><span class=\"n\">bb</span><span class=\"p\">)</span>\n    <span class=\"k\">assert</span> <span class=\"n\">bb_to_str</span><span class=\"p\">(</span><span class=\"n\">opt_bb</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"s\">\"\"\"</span><span class=\"se\">\\\n</span><span class=\"s\">var0 = getarg(0)\nvar1 = store(var0, 0, 5)\nvar2 = load(var0, 1)\nvar3 = escape(5)\nvar4 = escape(var2)\"\"\"</span>\n</code></pre></div></div>\n\n<p>Making that work is thankfully not very hard; we need only add that new\ninformation to the compile-time heap after removing all the\npotentially-aliased info:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">optimize_load_store</span><span class=\"p\">(</span><span class=\"n\">bb</span><span class=\"p\">:</span> <span class=\"n\">Block</span><span class=\"p\">):</span>\n    <span class=\"n\">opt_bb</span> <span class=\"o\">=</span> <span class=\"n\">Block</span><span class=\"p\">()</span>\n    <span class=\"n\">compile_time_heap</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Value</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">Value</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n    <span class=\"k\">for</span> <span class=\"n\">op</span> <span class=\"ow\">in</span> <span class=\"n\">bb</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s\">\"store\"</span><span class=\"p\">:</span>\n            <span class=\"n\">offset</span> <span class=\"o\">=</span> <span class=\"n\">get_num</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n            <span class=\"n\">compile_time_heap</span> <span class=\"o\">=</span> <span class=\"c1\"># ... as before ...\n</span>            <span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">arg</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n            <span class=\"n\">new_value</span> <span class=\"o\">=</span> <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">arg</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n            <span class=\"n\">compile_time_heap</span><span class=\"p\">[(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">offset</span><span class=\"p\">)]</span> <span class=\"o\">=</span> <span class=\"n\">new_value</span>  <span class=\"c1\"># NEW!\n</span>        <span class=\"k\">elif</span> <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s\">\"load\"</span><span class=\"p\">:</span>\n            <span class=\"c1\"># ...\n</span>        <span class=\"n\">opt_bb</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">opt_bb</span>\n</code></pre></div></div>\n\n<p>This makes the test pass. It makes another test fail, but only\nbecause—oops—we now know more. You can delete the old test because the new\ntest supersedes it.</p>\n\n<p>Now, note that we are not removing the store. This is because we have nothing\nin our optimizer that keeps track of what might have observed the side-effects\nof the store. What if the object got <code class=\"language-plaintext highlighter-rouge\">escape</code>d? Or someone did a load later on?\nWe would only be able to remove the store (<code class=\"language-plaintext highlighter-rouge\">continue</code>) if we could guarantee it\nwas not observable.</p>\n\n<p>In our current framework, this only happens in one case: someone is doing a\nstore of the exact same value that already exists in our compile-time heap.\nThat is, either the same constant, or the same SSA value. If we see this, then\nwe can completely skip the second store instruction.</p>\n\n<p>Here’s a test case for that, where we have gained information from the load\ninstruction that we can then use to get rid of the store instruction:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">test_load_then_store</span><span class=\"p\">():</span>\n    <span class=\"n\">bb</span> <span class=\"o\">=</span> <span class=\"n\">Block</span><span class=\"p\">()</span>\n    <span class=\"n\">arg1</span> <span class=\"o\">=</span> <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">getarg</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">var1</span> <span class=\"o\">=</span> <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">arg1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">(</span><span class=\"n\">arg1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">var1</span><span class=\"p\">)</span>\n    <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">escape</span><span class=\"p\">(</span><span class=\"n\">var1</span><span class=\"p\">)</span>\n    <span class=\"n\">opt_bb</span> <span class=\"o\">=</span> <span class=\"n\">optimize_load_store</span><span class=\"p\">(</span><span class=\"n\">bb</span><span class=\"p\">)</span>\n    <span class=\"k\">assert</span> <span class=\"n\">bb_to_str</span><span class=\"p\">(</span><span class=\"n\">opt_bb</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"s\">\"\"\"</span><span class=\"se\">\\\n</span><span class=\"s\">var0 = getarg(0)\nvar1 = load(var0, 0)\nvar2 = escape(var1)\"\"\"</span>\n</code></pre></div></div>\n\n<p>Let’s make it pass. To do that, first we’ll make an equality function that\nworks for both constants and operations. Constants are equal if their values\nare equal, and operations are equal if they are the identical (by\naddress/pointer) operation.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">eq_value</span><span class=\"p\">(</span><span class=\"n\">left</span><span class=\"p\">:</span> <span class=\"n\">Value</span><span class=\"o\">|</span><span class=\"bp\">None</span><span class=\"p\">,</span> <span class=\"n\">right</span><span class=\"p\">:</span> <span class=\"n\">Value</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">Constant</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">right</span><span class=\"p\">,</span> <span class=\"n\">Constant</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">left</span><span class=\"p\">.</span><span class=\"n\">value</span> <span class=\"o\">==</span> <span class=\"n\">right</span><span class=\"p\">.</span><span class=\"n\">value</span>\n    <span class=\"k\">return</span> <span class=\"n\">left</span> <span class=\"ow\">is</span> <span class=\"n\">right</span>\n</code></pre></div></div>\n\n<p>This is a partial equality: if two operations are not equal under <code class=\"language-plaintext highlighter-rouge\">eq_value</code>,\nit doesn’t mean that they are different, only that we don’t know that they are\nthe same.</p>\n\n<p>Then, after that, we need only check if the current value in the compile-time\nheap is the same as the value being stored in. If it is, wonderful. No need to\nstore. <code class=\"language-plaintext highlighter-rouge\">continue</code> and don’t append the operation to <code class=\"language-plaintext highlighter-rouge\">opt_bb</code>:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">optimize_load_store</span><span class=\"p\">(</span><span class=\"n\">bb</span><span class=\"p\">:</span> <span class=\"n\">Block</span><span class=\"p\">):</span>\n    <span class=\"n\">opt_bb</span> <span class=\"o\">=</span> <span class=\"n\">Block</span><span class=\"p\">()</span>\n    <span class=\"n\">compile_time_heap</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Value</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">Value</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n    <span class=\"k\">for</span> <span class=\"n\">op</span> <span class=\"ow\">in</span> <span class=\"n\">bb</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s\">\"store\"</span><span class=\"p\">:</span>\n            <span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">arg</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n            <span class=\"n\">offset</span> <span class=\"o\">=</span> <span class=\"n\">get_num</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n            <span class=\"n\">store_info</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">offset</span><span class=\"p\">)</span>\n            <span class=\"n\">current_value</span> <span class=\"o\">=</span> <span class=\"n\">compile_time_heap</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">store_info</span><span class=\"p\">)</span>\n            <span class=\"n\">new_value</span> <span class=\"o\">=</span> <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">arg</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"n\">eq_value</span><span class=\"p\">(</span><span class=\"n\">current_value</span><span class=\"p\">,</span> <span class=\"n\">new_value</span><span class=\"p\">):</span>  <span class=\"c1\"># NEW!\n</span>                <span class=\"k\">continue</span>\n            <span class=\"n\">compile_time_heap</span> <span class=\"o\">=</span> <span class=\"c1\"># ... as before ...\n</span>            <span class=\"c1\"># ...\n</span>        <span class=\"k\">elif</span> <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s\">\"load\"</span><span class=\"p\">:</span>\n            <span class=\"n\">load_info</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">arg</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">),</span> <span class=\"n\">get_num</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">))</span>\n            <span class=\"k\">if</span> <span class=\"n\">load_info</span> <span class=\"ow\">in</span> <span class=\"n\">compile_time_heap</span><span class=\"p\">:</span>\n                <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">make_equal_to</span><span class=\"p\">(</span><span class=\"n\">compile_time_heap</span><span class=\"p\">[</span><span class=\"n\">load_info</span><span class=\"p\">])</span>\n                <span class=\"k\">continue</span>\n            <span class=\"n\">compile_time_heap</span><span class=\"p\">[</span><span class=\"n\">load_info</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">op</span>\n        <span class=\"n\">opt_bb</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">opt_bb</span>\n</code></pre></div></div>\n\n<p>This makes our load-then-store pass and it also makes other tests pass too,\nlike eliminating a store after another store!</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">test_store_after_store</span><span class=\"p\">():</span>\n    <span class=\"n\">bb</span> <span class=\"o\">=</span> <span class=\"n\">Block</span><span class=\"p\">()</span>\n    <span class=\"n\">arg1</span> <span class=\"o\">=</span> <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">getarg</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">(</span><span class=\"n\">arg1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n    <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">(</span><span class=\"n\">arg1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n    <span class=\"n\">opt_bb</span> <span class=\"o\">=</span> <span class=\"n\">optimize_load_store</span><span class=\"p\">(</span><span class=\"n\">bb</span><span class=\"p\">)</span>\n    <span class=\"k\">assert</span> <span class=\"n\">bb_to_str</span><span class=\"p\">(</span><span class=\"n\">opt_bb</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"s\">\"\"\"</span><span class=\"se\">\\\n</span><span class=\"s\">var0 = getarg(0)\nvar1 = store(var0, 0, 5)\"\"\"</span>\n</code></pre></div></div>\n\n<p>Unfortunately, this only works if the values—constants or SSA values—are\nknown to be the same. If we store <em>different</em> values, we can’t optimize. In the\nlive stream, we left this an exercise for the viewer:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">@</span><span class=\"n\">pytest</span><span class=\"p\">.</span><span class=\"n\">mark</span><span class=\"p\">.</span><span class=\"n\">xfail</span>\n<span class=\"k\">def</span> <span class=\"nf\">test_exercise_for_the_reader</span><span class=\"p\">():</span>\n    <span class=\"n\">bb</span> <span class=\"o\">=</span> <span class=\"n\">Block</span><span class=\"p\">()</span>\n    <span class=\"n\">arg0</span> <span class=\"o\">=</span> <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">getarg</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">var0</span> <span class=\"o\">=</span> <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">(</span><span class=\"n\">arg0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n    <span class=\"n\">var1</span> <span class=\"o\">=</span> <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">(</span><span class=\"n\">arg0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">)</span>\n    <span class=\"n\">var2</span> <span class=\"o\">=</span> <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">arg0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">escape</span><span class=\"p\">(</span><span class=\"n\">var2</span><span class=\"p\">)</span>\n    <span class=\"n\">opt_bb</span> <span class=\"o\">=</span> <span class=\"n\">optimize_load_store</span><span class=\"p\">(</span><span class=\"n\">bb</span><span class=\"p\">)</span>\n    <span class=\"k\">assert</span> <span class=\"n\">bb_to_str</span><span class=\"p\">(</span><span class=\"n\">opt_bb</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"s\">\"\"\"</span><span class=\"se\">\\\n</span><span class=\"s\">var0 = getarg(0)\nvar1 = store(var0, 0, 7)\nvar2 = escape(7)\"\"\"</span>\n</code></pre></div></div>\n\n<p>We would only be able to optimize this away if we had some notion of a store\nbeing <em>dead</em>. In this case, that is a store in which the value is never read\nbefore being overwritten.</p>\n\n<h2 id=\"removing-dead-stores\">Removing dead stores</h2>\n\n<p>TODO, I suppose. I have not gotten this far yet. If I get around to it, I will\ncome back and update the post.</p>\n\n<h2 id=\"in-the-real-world\">In the real world</h2>\n\n<p>This small optimization pass may seem silly or fiddly—when would we ever see\nsomething like this in a real IR?—but it’s pretty useful. Here’s the Ruby\ncode that got me thinking about it again some years later for ZJIT:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">C</span>\n  <span class=\"k\">def</span> <span class=\"nf\">initialize</span>\n    <span class=\"vi\">@a</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n    <span class=\"vi\">@b</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n    <span class=\"vi\">@c</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>CRuby has a shape system and ZJIT makes use of it, so we end up optimizing this\ncode (if it’s monomorphic) into a series of shape checks and stores. The HIR\nmight end up looking something like the mess below, where I’ve annotated the\nshape guards (can be thought of as loads) and stores with asterisks:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>fn initialize@tmp/init.rb:3:\n# ...\nbb2(v6:BasicObject):\n  v10:Fixnum[1] = Const Value(1)\n  v31:HeapBasicObject = GuardType v6, HeapBasicObject\n* v32:HeapBasicObject = GuardShape v31, 0x400000\n* StoreField v32, :@a@0x10, v10\n  WriteBarrier v32, v10\n  v35:CShape[0x40008e] = Const CShape(0x40008e)\n* StoreField v32, :_shape_id@0x4, v35\n  v16:Fixnum[2] = Const Value(2)\n  v37:HeapBasicObject = GuardType v6, HeapBasicObject\n* v38:HeapBasicObject = GuardShape v37, 0x40008e\n* StoreField v38, :@b@0x18, v16\n  WriteBarrier v38, v16\n  v41:CShape[0x40008f] = Const CShape(0x40008f)\n* StoreField v38, :_shape_id@0x4, v41\n  v22:Fixnum[3] = Const Value(3)\n  v43:HeapBasicObject = GuardType v6, HeapBasicObject\n* v44:HeapBasicObject = GuardShape v43, 0x40008f\n* StoreField v44, :@c@0x20, v22\n  WriteBarrier v44, v22\n  v47:CShape[0x400090] = Const CShape(0x400090)\n* StoreField v44, :_shape_id@0x4, v47\n  CheckInterrupts\n  Return v22\n</code></pre></div></div>\n\n<p>If we had store-load forwarding in ZJIT, we could get rid of the intermediate\nshape guards; they would know the shape from the previous <code class=\"language-plaintext highlighter-rouge\">StoreField</code>\ninstruction. If we had dead store elimination, we could get rid of the\nintermediate shape writes; they are never read. (And the repeated type guards\nto check if it’s a heap object still are just silly and need to get removed\neventually.)</p>\n\n<p>This is on the roadmap and will make object initialization even faster than it\nis right now.</p>\n\n<h2 id=\"wrapping-up\">Wrapping up</h2>\n\n<p>Thanks for reading the text version of the video that CF and I made a while\nback. Now you know how to do load/store elimination on traces.</p>\n\n<p>I think this does not need too much extra work to get it going on full CFGs; a\nblock is pretty much the same as a trace, so you can do a block-local version\nwithout much fuss. If you want to go global, you need dominator information and\ngen-kill sets.</p>\n\n<p>Maybe check out the implementation in other compilers:</p>\n\n<ul>\n  <li><a href=\"https://github.com/tekknolagi/v8/blob/f030838700a83cde6992cb8ebcb3facc6a8fc1f1/src/crankshaft/hydrogen-load-elimination.cc\">V8’s old Hydrogen load elimination</a></li>\n  <li><a href=\"https://github.com/tekknolagi/v8/blob/f030838700a83cde6992cb8ebcb3facc6a8fc1f1/src/crankshaft/hydrogen-escape-analysis.cc\">V8’s old Hydrogen escape analysis</a>\n    <ul>\n      <li>Which also does some load-store forwarding</li>\n    </ul>\n  </li>\n  <li><a href=\"https://github.com/tekknolagi/v8/blob/f030838700a83cde6992cb8ebcb3facc6a8fc1f1/src/crankshaft/hydrogen-alias-analysis.h\">V8’s old Hydrogen simple alias analysis</a></li>\n  <li><a href=\"https://github.com/LineageOS/android_art/blob/8ce603e0c68899bdfbc9cd4c50dcc65bbf777982/compiler/optimizing/load_store_elimination.cc\">Android ART’s load-store elimination</a></li>\n</ul>\n\n<p>Maybe I will touch on this in a future post…</p>\n\n<h2 id=\"thank-you\">Thank you</h2>\n\n<p>Thank you to CF, who walked me through this live on a stream two years ago!\nThis blog post wouldn’t be possible without you.</p>\n<div class=\"footnotes\">\n  <ol>\n    <li id=\"fn:size\">\n      <p>In this toy optimizer example, we are assuming that all reads and writes\nare the same size and different offsets don’t overlap at all. This is often\nthe case for managed runtimes, where object fields are pointer-sized and\nall reads/writes are pointer-aligned. <a class=\"reversefootnote\" href=\"#fnref:size\">&#8617;</a></p>\n    </li>\n    <li id=\"fn:tbaa\">\n      <p>We could do better. If we had type information, we could also use that\nto make alias classes. Writes to a List will never overlap with writes to a\nMap, for example. This requires your compiler to have strict aliasing—if\nyou can freely cast between types, as in C, then this tactic goes out the\nwindow.</p>\n\n      <p>This is called <a href=\"/assets/img/tbaa.pdf\">Type-based alias analysis</a> (PDF). <a class=\"reversefootnote\" href=\"#fnref:tbaa\">&#8617;</a></p>\n    </li>\n  </ol>\n</div>",
  "id": "https://bernsteinbear.com/blog/toy-load-store/"
}