{
  "title": "Linear scan register allocation on SSA",
  "link": "https://bernsteinbear.com/blog/linear-scan/?utm_source=rss",
  "published": "Wed, 13 Aug 2025 00:00:00 +0000",
  "summary": "<p><em>Much of the code and education that resulted in this post happened with <a href=\"https://tenderlovemaking.com/\">Aaron\nPatterson</a>.</em></p>\n\n<p>The fundamental problem in register allocation is to take an IR that uses a\nvirtual registers (as many as you like) and rewrite it to use a finite amount\nof physical registers and stack space<sup id=\"fnref:calendaring\"><a class=\"footnote\" href=\"#fn:calendaring\" rel=\"footnote\">1</a></sup>.</p>\n\n<p>This is an example of a code snippet using virtual registers:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>add R1, R2 -&gt; R3\nadd R1, R3 -&gt; R4\nret R4\n</code></pre></div></div>\n\n<p>And here is the same example after it has been passed through a register\nallocator (note that Rs changed to Ps):</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>add Stack[0], P0 -&gt; P1\nadd Stack[0], P1 -&gt; P0\nret\n</code></pre></div></div>\n\n<p>Each virtual register was assigned a physical place: R1 to the stack, R2 to P0,\nR3 to P1, and R4 <em>also</em> to P0 (since we weren’t using R2 anymore).</p>\n\n<p>People use register allocators like they use garbage collectors: it’s an\nabstraction that can manage your resources for you, maybe with some cost. When\nwriting the back-end of a compiler, it’s probably much easier to have a\nseparate register-allocator-in-a-box than manually managing variable lifetimes\nwhile also considering all of your different target architectures.</p>\n\n<p>How do JIT compilers do register allocation? Well, “everyone knows” that “every\nJIT does its own variant of linear scan”<sup id=\"fnref:everyone\"><a class=\"footnote\" href=\"#fn:everyone\" rel=\"footnote\">2</a></sup>. This bothered me for some\ntime because I’ve worked on a couple of JITs and still didn’t understand the\nbackend bits.</p>\n\n<p>There are a couple different approaches to register allocation, but in this\npost we’ll focus on <em>linear scan of SSA</em>.</p>\n\n<p>I started reading <a href=\"/assets/img/wimmer-linear-scan-ssa.pdf\">Linear Scan Register Allocation on SSA Form</a> (PDF,\n2010) by Wimmer and Franz after writing <a href=\"/blog/ssa/\">A catalog of ways to generate\nSSA</a>. Reading alone didn’t make a ton of sense—I ended up with a\nlot of very frustrated margin notes. I started trying to implement it alongside\nthe paper. As it turns out, though, there is a rich history of papers in this\narea that it leans on really heavily. I needed to follow the chain of\nreferences!</p>\n\n<blockquote>\n  <p>For example, here is a lovely explanation of the process, start to finish,\nfrom Christian Wimmer’s <a href=\"/assets/img/wimmer-masters-thesis.pdf\">Master’s thesis</a> (PDF, 2004).</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>LINEAR_SCAN\n  // order blocks and operations (including loop detection)\n  COMPUTE_BLOCK_ORDER\n  NUMBER_OPERATIONS\n  // create intervals with live ranges\n  COMPUTE_LOCAL_LIVE_SETS\n  COMPUTE_GLOBAL_LIVE_SETS\n  BUILD_INTERVALS\n  // allocate registers\n  WALK_INTERVALS\n  RESOLVE_DATA_FLOW\n  // replace virtual registers with physical registers\n  ASSIGN_REG_NUM\n  // special handling for the Intel FPU stack\n  ALLOCATE_FPU_STACK\n</code></pre></div>  </div>\n\n  <p>There it is, all laid out at once. It’s very refreshing when compared to all\nof the compact research papers.</p>\n</blockquote>\n\n<p>I didn’t realize that there were more than one or two papers on linear scan. So\nthis post will also incidentally serve as a bit of a survey or a history of\nlinear scan—as best as I can figure it out, anyway. If you were in or near\nthe room where it happened, please feel free to reach out and correct some\nparts.</p>\n\n<h2 id=\"some-example-code\">Some example code</h2>\n\n<p>Throughout this post, we’ll use an example SSA code snippet from Wimmer2010,\nadapted from phi-SSA to block-argument-SSA. Wimmer2010’s code snippet is\nbetween the arrows and we add some filler (as alluded to in the paper):</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>label B1(R10, R11):\njmp B2($1, R11)\n # vvvvvvvvvv #\nlabel B2(R12, R13)\ncmp R13, $1\nbranch lessThan B4()\n\nlabel B3()\nmul R12, R13 -&gt; R14\nsub R13, $1 -&gt; R15\njump B2(R14, R15)\n\nlabel B4()\n # ^^^^^^^^^^ #\nadd R10, R12 -&gt; R16\nret R16\n</code></pre></div></div>\n\n<p>Virtual registers start with R and are defined either with an arrow or by a\nblock parameter.</p>\n\n<p>Because it takes a moment to untangle the unfamiliar syntax and draw the\ncontrol-flow graph by hand, I’ve also provided the same code in graphical form.\nBlock names (and block parameters) are shaded with grey.</p>\n\n<!--\n# dot IN.dot -Tsvg -Nfontname=Monospace -Efontname=Monospace > OUT.svg\n\ndigraph G {\nnode [shape=plaintext]\nB1 [label=<<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\">\n<TR><TD PORT=\"params\" BGCOLOR=\"lightgray\">B1(R10, R11)&nbsp;</TD></TR>\n<TR><TD ALIGN=\"left\" PORT=\"0\">jump →B2($1, R11)&nbsp;</TD></TR>\n</TABLE>>];\nB1:s -> B2:params:n;\nB2 [label=<<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\">\n<TR><TD PORT=\"params\" BGCOLOR=\"lightgray\">B2(R12, R13)&nbsp;</TD></TR>\n<TR><TD ALIGN=\"left\" PORT=\"0\">cmp R13, $1&nbsp;</TD></TR>\n<TR><TD ALIGN=\"left\" PORT=\"1\">blt →B4, →B3&nbsp;</TD></TR>\n</TABLE>>];\nB2:s -> B4:params:n;\nB2:s -> B3:params:n;\nB3 [label=<<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\">\n<TR><TD PORT=\"params\" BGCOLOR=\"lightgray\">B3()&nbsp;</TD></TR>\n<TR><TD ALIGN=\"left\" PORT=\"0\">R14 = mul R12, R13&nbsp;</TD></TR>\n<TR><TD ALIGN=\"left\" PORT=\"1\">R15 = sub R13, $1&nbsp;</TD></TR>\n<TR><TD ALIGN=\"left\" PORT=\"2\">jump →B2(R14, R15)&nbsp;</TD></TR>\n</TABLE>>];\nB3:s -> B2:params:n;\nB4 [label=<<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\">\n<TR><TD PORT=\"params\" BGCOLOR=\"lightgray\">B4()&nbsp;</TD></TR>\n<TR><TD ALIGN=\"left\" PORT=\"0\">R16 = add R10, R12&nbsp;</TD></TR>\n<TR><TD ALIGN=\"left\" PORT=\"1\">ret R16&nbsp;</TD></TR>\n</TABLE>>];\n}\n-->\n<figure>\n\n<figcaption>\n    <p>We have one entry block, <code class=\"language-plaintext highlighter-rouge\">B1</code>, that is implied in\nWimmer2010. Its only job is to define <code class=\"language-plaintext highlighter-rouge\">R10</code> and <code class=\"language-plaintext highlighter-rouge\">R11</code> for the rest of the CFG.</p>\n\n    <p>Then we have a loop between <code class=\"language-plaintext highlighter-rouge\">B2</code> and <code class=\"language-plaintext highlighter-rouge\">B3</code> with an implicit fallthrough. Instead\nof doing that, we instead generate a conditional branch with explicit jump\ntargets. This makes it possible to re-order blocks as much as we like.</p>\n\n    <p>The contents of <code class=\"language-plaintext highlighter-rouge\">B4</code> are also just to fill in the blanks from Wimmer2010 and\nadd some variable uses.</p>\n  </figcaption>\n</figure>\n\n<p>Our goal for the post is to analyze this CFG, assign physical locations\n(registers or stack slots) to each virtual register, and then rewrite the code\nappropriately.</p>\n\n<p>For now, let’s rewind the clock and look at how linear scan came about.</p>\n\n<h2 id=\"in-the-beginning\">In the beginning</h2>\n\n<p>Linear scan register allocation (LSRA) has been around for awhile. It’s neat\nbecause it does the actual register assignment part of register allocation in\none pass over your low-level IR. (We’ll talk more about what that means in a\nminute.)</p>\n\n<p>It first appeared in the literature in <a href=\"/assets/img/tcc-linearscan-ra.pdf\">tcc: A System for Fast, Flexible, and\nHigh-level Dynamic Code Generation</a> (PDF, 1997) by Poletto, Engler,\nand Kaashoek. (Until writing this post, I had never seen this paper. It was\nonly on a re-read of the 1999 paper (below) that I noticed it.) In this paper,\nthey mostly describe a staged variant of C called ‘C (TickC), for which a fast\nregister allocator is quite useful.</p>\n\n<p>Then came a paper called <a href=\"/assets/img/quality-speed-linear-scan-ra-clean.pdf\">Quality and Speed in Linear-scan Register\nAllocation</a> (PDF, 1998) by Traub, Holloway, and Smith. It adds\nsome optimizations (lifetime holes, binpacking) to the algorithm presented in\nPoletto1997.</p>\n\n<p>Then came the first paper I read, and I think the paper everyone refers to when\nthey talk about linear scan: <a href=\"/assets/img/linearscan-ra.pdf\">Linear Scan Register Allocation</a> (PDF,\n1999) by Poletto and Sarkar. In this paper, they give a fast alternative to\ngraph coloring register allocation, especially motivated by just-in-time\ncompilers. In retrospect, it seems to be a bit of a rehash of the previous two\npapers.</p>\n\n<p>Linear scan (1997, 1999) operates on <em>live ranges</em> instead of virtual\nregisters. A live range is a pair of integers [start, end) (end is exclusive)\nthat begins when the register is defined and ends when it is last used. This\nmeans that there is an assumption that the order for instructions in your\nprogram has already been fixed into a single linear sequence! It also means\nthat you have given each instruction a number that represents its position in\nthat order.</p>\n\n<blockquote>\n  <p>This may or not be a surprising requirement depending on your compilers\nbackground. It was surprising to me because I often live in control flow\ngraph fantasy land where blocks are unordered and instructions sometimes\nfloat around. But if you live in a land of basic blocks that are already in\nreverse post order, then it may be less surprising.</p>\n</blockquote>\n\n<p>In non-SSA-land, these live ranges are different from the virtual registers:\nthey represent some kind of lifetimes of each <em>version</em> of a virtual register.\nFor an example, consider the following code snippet:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>...      -&gt; a\nadd 1, a -&gt; b\nadd 1, b -&gt; c\nadd 1, c -&gt; a\nadd 1, a -&gt; d\n</code></pre></div></div>\n\n<p>There are two definitions of <code class=\"language-plaintext highlighter-rouge\">a</code> and they each live for different amounts of\ntime:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>                  a  b  c  a  d\n...      -&gt; a     |                &lt;- the first a\nadd 1, a -&gt; b     v  |\nadd 1, b -&gt; c        v  |\nadd 1, c -&gt; a           v  |       &lt;- the second a\nadd 1, a -&gt; d              v  |\n</code></pre></div></div>\n\n<p>In fact, the ranges are completely disjoint. It wouldn’t make sense for the\nregister allocator to consider variables, because there’s no reason the two\n<code class=\"language-plaintext highlighter-rouge\">a</code>s should necessarily live in the same physical register.</p>\n\n<p>In SSA land, it’s a little different: since each virtual registers only has one\ndefinition (by, uh, definition), live ranges are an exact 1:1 mapping with\nvirtual registers. <strong>We’ll focus on SSA for the remainder of the post because\nthis is what I am currently interested in.</strong> The research community seems to\nhave decided that allocating directly on SSA gives more information to the\nregister allocator<sup id=\"fnref:allocate-on-ssa\"><a class=\"footnote\" href=\"#fn:allocate-on-ssa\" rel=\"footnote\">3</a></sup>.</p>\n\n<p>Linear scan starts at the point in your compiler process where you already know\nthese live ranges—that you have already done some kind of analysis to build a\nmapping.</p>\n\n<p>In this blog post, we’re going to back up to the point where we’ve just built\nour SSA low-level IR and have yet to do any work on it. We’ll do all of the\nanalysis from scratch.</p>\n\n<p>Part of this analysis is called <em>liveness analysis</em>.</p>\n\n<h2 id=\"liveness-analysis\">Liveness analysis</h2>\n\n<p>The result of liveness analysis is a mapping of <code class=\"language-plaintext highlighter-rouge\">BasicBlock -&gt;\nSet[Instruction]</code> that tells you which virtual registers (remember, since we’re\nin SSA, instruction==vreg) are alive (used later) at the beginning of the basic\nblock. This is called a <em>live-in</em> set. For example:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>B0:\n... -&gt; R12\n... -&gt; R13\njmp B1\n\nB1:\nmul R12, R13 -&gt; R14\nsub R13, 1 -&gt; R15\njmp B2\n\nB2:\nadd R14, R15 -&gt; R16\nret R16\n</code></pre></div></div>\n\n<p>We compute liveness by working backwards: a variable is <em>live</em> from the moment\nit is backwardly-first used until its definition.</p>\n\n<p>In this case, at the end of B2, nothing is live. If we step backwards to the\n<code class=\"language-plaintext highlighter-rouge\">ret</code>, we see a use: R16 becomes live. If we step once more, we see its\ndefinition—R16 no longer live—but now we see a use of R14 and R15, which\nbecome live. This leaves us with R14 and R15 being <em>live-in</em> to B2.</p>\n\n<p>This live-in set becomes B1’s <em>live-out</em> set because B1 is B2’s predecessor. We\ncontinue in B1. We could continue backwards linearly through the blocks. In\nfact, I encourage you to do it as an exercise. You should have a (potentially\nemtpy) set of registers per basic block.</p>\n\n<p>It gets more interesting, though, when we have branches: what does it mean when\ntwo blocks’ live-in results merge into their shared predecessor? If we have two\nblocks A and B that are successors of a block C, the live-in sets get\n<em>unioned</em> together.</p>\n\n<!--\ndigraph G {\n  node [shape=square];\n  C -> A;\n  C -> B;\n}\n-->\n<figure>\n<svg height=\"116pt\" viewBox=\"0.00 0.00 98.00 116.00\" width=\"98pt\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n<g class=\"graph\" id=\"graph0\" transform=\"scale(1 1) rotate(0) translate(4 112)\">\n<title>G</title>\n<polygon fill=\"white\" points=\"-4,4 -4,-112 94,-112 94,4 -4,4\" stroke=\"none\">\n<!-- C -->\n<g class=\"node\" id=\"node1\">\n<title>C</title>\n<polygon fill=\"none\" points=\"63,-108 27,-108 27,-72 63,-72 63,-108\" stroke=\"black\">\n<text font-family=\"Times,serif\" font-size=\"14.00\" text-anchor=\"middle\" x=\"45\" y=\"-85.8\">C</text>\n</g>\n<!-- A -->\n<g class=\"node\" id=\"node2\">\n<title>A</title>\n<polygon fill=\"none\" points=\"36,-36 0,-36 0,0 36,0 36,-36\" stroke=\"black\">\n<text font-family=\"Times,serif\" font-size=\"14.00\" text-anchor=\"middle\" x=\"18\" y=\"-13.8\">A</text>\n</g>\n<!-- C&#45;&gt;A -->\n<g class=\"edge\" id=\"edge1\">\n<title>C-&gt;A</title>\n<path d=\"M38.33,-71.7C35.42,-64.15 31.93,-55.12 28.68,-46.68\" fill=\"none\" stroke=\"black\">\n<polygon fill=\"black\" points=\"32.01,-45.59 25.14,-37.52 25.48,-48.11 32.01,-45.59\" stroke=\"black\">\n</g>\n<!-- B -->\n<g class=\"node\" id=\"node3\">\n<title>B</title>\n<polygon fill=\"none\" points=\"90,-36 54,-36 54,0 90,0 90,-36\" stroke=\"black\">\n<text font-family=\"Times,serif\" font-size=\"14.00\" text-anchor=\"middle\" x=\"72\" y=\"-13.8\">B</text>\n</g>\n<!-- C&#45;&gt;B -->\n<g class=\"edge\" id=\"edge2\">\n<title>C-&gt;B</title>\n<path d=\"M51.67,-71.7C54.58,-64.15 58.07,-55.12 61.32,-46.68\" fill=\"none\" stroke=\"black\">\n<polygon fill=\"black\" points=\"64.52,-48.11 64.86,-37.52 57.99,-45.59 64.52,-48.11\" stroke=\"black\">\n</g>\n</g>\n</svg>\n</figure>\n\n<p>That is, if there were some register R0 live-in to B and some register R1\nlive-in to A, both R0 and R1 would be live-out of C. They may also be live-in\nto C, but that entirely depends on the contents of C.</p>\n\n<p>Since the total number of virtual registers is nonnegative and is finite for a\ngiven program, it seems like a good lattice for an <em>abstract interpreter</em>.\nThat’s right, we’re doing AI.</p>\n\n<p>In this liveness analysis, we’ll:</p>\n\n<ol>\n  <li>compute a summary of what virtual registers each basic block needs to be\nalive (gen set) and what variables it defines (kill set)</li>\n  <li>initialize all live-in sets to 0</li>\n  <li>do an iterative dataflow analysis over the blocks until the live-in sets\nconverge</li>\n</ol>\n\n<p>We store gen, kill, and live-in sets as bitsets, using some APIs conveniently\navailable on Ruby’s Integer class.</p>\n\n<p>Like most abstract interpretations, it doesn’t matter what order we iterate\nover the collection of basic blocks for correctness, but it <em>does</em> matter for\nperformance. In this case, iterating backwards (<code class=\"language-plaintext highlighter-rouge\">post_order</code>) converges much\nfaster than forwards (<code class=\"language-plaintext highlighter-rouge\">reverse_post_order</code>):</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Function</span>\n  <span class=\"k\">def</span> <span class=\"nf\">compute_initial_liveness_sets</span> <span class=\"n\">order</span>\n    <span class=\"c1\"># Map of Block -&gt; what variables it alone needs to be live-in</span>\n    <span class=\"n\">gen</span> <span class=\"o\">=</span> <span class=\"no\">Hash</span><span class=\"p\">.</span><span class=\"nf\">new</span> <span class=\"mi\">0</span>\n    <span class=\"c1\"># Map of Block -&gt; what variables it alone defines</span>\n    <span class=\"n\">kill</span> <span class=\"o\">=</span> <span class=\"no\">Hash</span><span class=\"p\">.</span><span class=\"nf\">new</span> <span class=\"mi\">0</span>\n    <span class=\"n\">order</span><span class=\"p\">.</span><span class=\"nf\">each</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">block</span><span class=\"o\">|</span>\n      <span class=\"n\">block</span><span class=\"p\">.</span><span class=\"nf\">instructions</span><span class=\"p\">.</span><span class=\"nf\">reverse_each</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">insn</span><span class=\"o\">|</span>\n        <span class=\"n\">out</span> <span class=\"o\">=</span> <span class=\"n\">insn</span><span class=\"p\">.</span><span class=\"nf\">out</span><span class=\"o\">&amp;</span><span class=\"p\">.</span><span class=\"nf\">as_vreg</span>\n        <span class=\"k\">if</span> <span class=\"n\">out</span>\n          <span class=\"n\">kill</span><span class=\"p\">[</span><span class=\"n\">block</span><span class=\"p\">]</span> <span class=\"o\">|=</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">out</span><span class=\"p\">.</span><span class=\"nf\">num</span><span class=\"p\">)</span>\n        <span class=\"k\">end</span>\n        <span class=\"n\">insn</span><span class=\"p\">.</span><span class=\"nf\">vreg_ins</span><span class=\"p\">.</span><span class=\"nf\">each</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">vreg</span><span class=\"o\">|</span>\n          <span class=\"n\">gen</span><span class=\"p\">[</span><span class=\"n\">block</span><span class=\"p\">]</span> <span class=\"o\">|=</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">vreg</span><span class=\"p\">.</span><span class=\"nf\">num</span><span class=\"p\">)</span>\n        <span class=\"k\">end</span>\n      <span class=\"k\">end</span>\n      <span class=\"n\">block</span><span class=\"p\">.</span><span class=\"nf\">parameters</span><span class=\"p\">.</span><span class=\"nf\">each</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">param</span><span class=\"o\">|</span>\n        <span class=\"n\">kill</span><span class=\"p\">[</span><span class=\"n\">block</span><span class=\"p\">]</span> <span class=\"o\">|=</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">param</span><span class=\"p\">.</span><span class=\"nf\">num</span><span class=\"p\">)</span>\n      <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n    <span class=\"p\">[</span><span class=\"n\">gen</span><span class=\"p\">,</span> <span class=\"n\">kill</span><span class=\"p\">]</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"k\">def</span> <span class=\"nf\">analyze_liveness</span>\n    <span class=\"n\">order</span> <span class=\"o\">=</span> <span class=\"n\">post_order</span>\n    <span class=\"n\">gen</span><span class=\"p\">,</span> <span class=\"n\">kill</span> <span class=\"o\">=</span> <span class=\"n\">compute_initial_liveness_sets</span><span class=\"p\">(</span><span class=\"n\">order</span><span class=\"p\">)</span>\n    <span class=\"c1\"># Map from Block -&gt; what variables are live-in</span>\n    <span class=\"n\">live_in</span> <span class=\"o\">=</span> <span class=\"no\">Hash</span><span class=\"p\">.</span><span class=\"nf\">new</span> <span class=\"mi\">0</span>\n    <span class=\"n\">changed</span> <span class=\"o\">=</span> <span class=\"kp\">true</span>\n    <span class=\"k\">while</span> <span class=\"n\">changed</span>\n      <span class=\"n\">changed</span> <span class=\"o\">=</span> <span class=\"kp\">false</span>\n      <span class=\"k\">for</span> <span class=\"n\">block</span> <span class=\"k\">in</span> <span class=\"n\">order</span>\n        <span class=\"c1\"># Union-ing all the successors' live-in sets gives us this block's</span>\n        <span class=\"c1\"># live-out, which is a good starting point for computing the live-in</span>\n        <span class=\"n\">block_live</span> <span class=\"o\">=</span> <span class=\"n\">block</span><span class=\"p\">.</span><span class=\"nf\">successors</span><span class=\"p\">.</span><span class=\"nf\">map</span> <span class=\"p\">{</span> <span class=\"o\">|</span><span class=\"n\">succ</span><span class=\"o\">|</span> <span class=\"n\">live_in</span><span class=\"p\">[</span><span class=\"n\">succ</span><span class=\"p\">]</span> <span class=\"p\">}.</span><span class=\"nf\">reduce</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"ss\">:|</span><span class=\"p\">)</span>\n        <span class=\"n\">block_live</span> <span class=\"o\">|=</span> <span class=\"n\">gen</span><span class=\"p\">[</span><span class=\"n\">block</span><span class=\"p\">]</span>\n        <span class=\"n\">block_live</span> <span class=\"o\">&amp;=</span> <span class=\"o\">~</span><span class=\"n\">kill</span><span class=\"p\">[</span><span class=\"n\">block</span><span class=\"p\">]</span>\n        <span class=\"k\">if</span> <span class=\"n\">live_in</span><span class=\"p\">[</span><span class=\"n\">block</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"n\">block_live</span>\n          <span class=\"n\">changed</span> <span class=\"o\">=</span> <span class=\"kp\">true</span>\n          <span class=\"n\">live_in</span><span class=\"p\">[</span><span class=\"n\">block</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">block_live</span>\n        <span class=\"k\">end</span>\n      <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">live_in</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>We could also use a worklist here, and it would be faster, but eh. Repeatedly\niterating over all blocks is fine for now.</p>\n\n<p>The Wimmer2010 paper skips this liveness analysis entirely by assuming some\ncomputed information about your CFG: where loops start and end. It also\nrequires all loop blocks be contiguous. Then it makes variables defined before\na loop and used at any point inside the loop live <em>for the whole loop</em>. By\nhaving this information available, it folds the liveness analysis into the live\nrange building, which we’ll instead do separately in a moment.</p>\n\n<p>The Wimmer approach sounded complicated and finicky. Maybe it is, maybe it\nisn’t. So I went with a dataflow liveness analysis instead. If it turns out to\nbe the slow part, maybe it will matter enough to learn about this loop tagging\nmethod.</p>\n\n<p>For now, we will pick a <em>schedule</em> for the control-flow graph.</p>\n\n<h2 id=\"scheduling\">Scheduling</h2>\n\n<p>In order to build live ranges, you have to have some kind of numbering system\nfor your instructions, otherwise a live range’s start and end are meaningless.\nWe can write a function that fixes a particular block order (in this case,\nreverse post-order) and then assigns each block and instruction a number in a\nlinear sequence. You can think of this as flattening or projecting the graph:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Function</span>\n  <span class=\"k\">def</span> <span class=\"nf\">number_instructions!</span>\n    <span class=\"vi\">@block_order</span> <span class=\"o\">=</span> <span class=\"n\">rpo</span>\n    <span class=\"n\">number</span> <span class=\"o\">=</span> <span class=\"mi\">16</span>  <span class=\"c1\"># just so we match the Wimmer2010 paper</span>\n    <span class=\"vi\">@block_order</span><span class=\"p\">.</span><span class=\"nf\">each</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">blk</span><span class=\"o\">|</span>\n      <span class=\"n\">blk</span><span class=\"p\">.</span><span class=\"nf\">number</span> <span class=\"o\">=</span> <span class=\"n\">number</span>\n      <span class=\"n\">number</span> <span class=\"o\">+=</span> <span class=\"mi\">2</span>\n      <span class=\"n\">blk</span><span class=\"p\">.</span><span class=\"nf\">instructions</span><span class=\"p\">.</span><span class=\"nf\">each</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">insn</span><span class=\"o\">|</span>\n        <span class=\"n\">insn</span><span class=\"p\">.</span><span class=\"nf\">number</span> <span class=\"o\">=</span> <span class=\"n\">number</span>\n        <span class=\"n\">number</span> <span class=\"o\">+=</span> <span class=\"mi\">2</span>\n      <span class=\"k\">end</span>\n      <span class=\"n\">blk</span><span class=\"p\">.</span><span class=\"nf\">to</span> <span class=\"o\">=</span> <span class=\"n\">number</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<!--\nI think using RPO is just a heuristic; other block orders may shrink live\nranges, reduce parallel moves, etc. I could be way off base here but I don't\nthink we even have to order the blocks in dominance order because we're doing a\nfull dataflow-based liveness analysis; the ordering and positioning\nrequirements from Wimmer2010 come from the quick liveness with loop headers\nthing.\n-->\n\n<p>A couple interesting things to note:</p>\n\n<ul>\n  <li>We number blocks because we use block starts as the start index for all of\nthat block’s parameters</li>\n  <li>We start numbering at 16 just so we can eyeball things and make sure they\nline up with the Wimmer2010 paper</li>\n  <li>We only give out even numbers because later we’ll insert loads and stores at\nodd-numbered instructions\n    <ul>\n      <li>Cinder does this to <a href=\"https://github.com/facebookincubator/cinderx/blob/2b8774f077d6ef441207067411d157bb4f94a40b/cinderx/Jit/lir/regalloc.cpp#L243\">separately identify instruction input and instruction output</a></li>\n      <li>Vox <a href=\"https://github.com/MrSmith33/vox/blob/b49cc734d6e5119e20229ee2d14612e33c6a5499/source/vox/be/reg_alloc/linear_scan.d#L10\">splits only at odd positions</a></li>\n    </ul>\n  </li>\n</ul>\n\n<p>Even though we have extra instructions, it looks very similar to the example in\nthe Wimmer2010 paper.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>16: label B1(R10, R11):\n18: jmp B2($1, R11)\n     # vvvvvvvvvv #\n20: label B2(R12, R13)\n22: cmp R13, $1\n24: branch lessThan B4() else B3()\n\n26: label B3()\n28: mul R12, R13 -&gt; R14\n30: sub R13, $1 -&gt; R15\n32: jump B2(R14, R15)\n\n34: label B4()\n     # ^^^^^^^^^^ #\n36: add R10, R12 -&gt; R16\n38: ret R16\n</code></pre></div></div>\n\n<p>Since we’re not going to be messing with the order of the instructions within a\nblock anymore, all we have to do going forward is make sure that we iterate\nthrough the blocks in <code class=\"language-plaintext highlighter-rouge\">@block_order</code>.</p>\n\n<p>Finally, we have all that we need to compute live ranges.</p>\n\n<h2 id=\"live-ranges\">Live ranges</h2>\n\n<p>We’ll more or less copy the algorithm to compute live ranges from the\nWimmer2010 paper. We’ll have two main differences:</p>\n\n<ul>\n  <li>We’re going to compute live ranges, not live intervals (as they do in the\npaper)</li>\n  <li>We’re going to use our dataflow liveness analysis, not the loop header thing</li>\n</ul>\n\n<p>I know I said we were going to be computing live ranges. So why am I presenting\nyou with a function called <code class=\"language-plaintext highlighter-rouge\">build_intervals</code>? That’s because early in\nthe history of linear scan (Traub1998!), people moved from having a single range for a\nparticular virtual register to having <em>multiple</em> disjoint ranges. This\ncollection of multiple ranges is called an <em>interval</em> and it exists to free up\nregisters in the context of branches.</p>\n\n<p>For example, in the our IR snippet (above), R12 is defined in B2 as a block\nparameter, used in B3, and then not used again until some indetermine point in\nB4. (Our example uses it immediately in an add instruction to keep things\nshort, but pretend the second use is some time away.)</p>\n\n<p>The Wimmer2010 paper creates a <em>lifetime hole</em> between 28 and 34, meaning that the\ninterval for R12 (called i12) is <code class=\"language-plaintext highlighter-rouge\">[[20, 28), [34, ...)]</code>. Interval holes are\nnot strictly necessary—they exist to generate better code. So for this post,\nwe’re going to start simple and assume 1 interval == 1 range. We may come back\nlater and add additional ranges, but that will require some fixes to our later\nimplementation. We’ll note where we think those fixes should happen.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>BUILDINTERVALS\nfor each block b in reverse order do\n  live = union of successor.liveIn for each successor of b\n  for each phi function phi of successors of b do\n    live.add(phi.inputOf(b))\n  for each opd in live do\n    intervals[opd].addRange(b.from, b.to)\n  for each operation op of b in reverse order do\n    for each output operand opd of op do\n      intervals[opd].setFrom(op.id)\n      live.remove(opd)\n    for each input operand opd of op do\n      intervals[opd].addRange(b.from, op.id)\n      live.add(opd)\n  for each phi function phi of b do\n    live.remove(phi.output)\n  if b is loop header then\n    loopEnd = last block of the loop starting at b\n    for each opd in live do\n      intervals[opd].addRange(b.from, loopEnd.to)\n  b.liveIn = live\n</code></pre></div></div>\n\n<p>Anyway, here is the mostly-copied annotated implementation of BuildIntervals\nfrom the Wimmer2010 paper:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Function</span>\n  <span class=\"k\">def</span> <span class=\"nf\">build_intervals</span> <span class=\"n\">live_in</span>\n    <span class=\"n\">intervals</span> <span class=\"o\">=</span> <span class=\"no\">Hash</span><span class=\"p\">.</span><span class=\"nf\">new</span> <span class=\"p\">{</span> <span class=\"o\">|</span><span class=\"nb\">hash</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">|</span> <span class=\"nb\">hash</span><span class=\"p\">[</span><span class=\"n\">key</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"no\">Interval</span><span class=\"p\">.</span><span class=\"nf\">new</span> <span class=\"p\">}</span>\n    <span class=\"vi\">@block_order</span><span class=\"p\">.</span><span class=\"nf\">reverse_each</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">block</span><span class=\"o\">|</span>\n      <span class=\"c1\"># live = union of successor.liveIn for each successor of b</span>\n      <span class=\"c1\"># this is the *live out* of the current block since we're going to be</span>\n      <span class=\"c1\"># iterating backwards over instructions</span>\n      <span class=\"n\">live</span> <span class=\"o\">=</span> <span class=\"n\">block</span><span class=\"p\">.</span><span class=\"nf\">successors</span><span class=\"p\">.</span><span class=\"nf\">map</span> <span class=\"p\">{</span> <span class=\"o\">|</span><span class=\"n\">succ</span><span class=\"o\">|</span> <span class=\"n\">live_in</span><span class=\"p\">[</span><span class=\"n\">succ</span><span class=\"p\">]</span> <span class=\"p\">}.</span><span class=\"nf\">reduce</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"ss\">:|</span><span class=\"p\">)</span>\n      <span class=\"c1\"># for each phi function phi of successors of b do</span>\n      <span class=\"c1\">#   live.add(phi.inputOf(b))</span>\n      <span class=\"n\">live</span> <span class=\"o\">|=</span> <span class=\"n\">block</span><span class=\"p\">.</span><span class=\"nf\">out_vregs</span><span class=\"p\">.</span><span class=\"nf\">map</span> <span class=\"p\">{</span> <span class=\"o\">|</span><span class=\"n\">vreg</span><span class=\"o\">|</span> <span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">vreg</span><span class=\"p\">.</span><span class=\"nf\">num</span> <span class=\"p\">}.</span><span class=\"nf\">reduce</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"ss\">:|</span><span class=\"p\">)</span>\n      <span class=\"n\">each_bit</span><span class=\"p\">(</span><span class=\"n\">live</span><span class=\"p\">)</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">idx</span><span class=\"o\">|</span>\n        <span class=\"n\">opd</span> <span class=\"o\">=</span> <span class=\"n\">vreg</span> <span class=\"n\">idx</span>\n        <span class=\"n\">intervals</span><span class=\"p\">[</span><span class=\"n\">opd</span><span class=\"p\">].</span><span class=\"nf\">add_range</span><span class=\"p\">(</span><span class=\"n\">block</span><span class=\"p\">.</span><span class=\"nf\">from</span><span class=\"p\">,</span> <span class=\"n\">block</span><span class=\"p\">.</span><span class=\"nf\">to</span><span class=\"p\">)</span>\n      <span class=\"k\">end</span>\n      <span class=\"n\">block</span><span class=\"p\">.</span><span class=\"nf\">instructions</span><span class=\"p\">.</span><span class=\"nf\">reverse</span><span class=\"p\">.</span><span class=\"nf\">each</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">insn</span><span class=\"o\">|</span>\n        <span class=\"n\">out</span> <span class=\"o\">=</span> <span class=\"n\">insn</span><span class=\"p\">.</span><span class=\"nf\">out</span><span class=\"o\">&amp;</span><span class=\"p\">.</span><span class=\"nf\">as_vreg</span>\n        <span class=\"k\">if</span> <span class=\"n\">out</span>\n          <span class=\"c1\"># for each output operand opd of op do</span>\n          <span class=\"c1\">#   intervals[opd].setFrom(op.id)</span>\n          <span class=\"n\">intervals</span><span class=\"p\">[</span><span class=\"n\">out</span><span class=\"p\">].</span><span class=\"nf\">set_from</span><span class=\"p\">(</span><span class=\"n\">insn</span><span class=\"p\">.</span><span class=\"nf\">number</span><span class=\"p\">)</span>\n        <span class=\"k\">end</span>\n        <span class=\"c1\"># for each input operand opd of op do</span>\n        <span class=\"c1\">#   intervals[opd].addRange(b.from, op.id)</span>\n        <span class=\"n\">insn</span><span class=\"p\">.</span><span class=\"nf\">vreg_ins</span><span class=\"p\">.</span><span class=\"nf\">each</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">opd</span><span class=\"o\">|</span>\n          <span class=\"n\">intervals</span><span class=\"p\">[</span><span class=\"n\">opd</span><span class=\"p\">].</span><span class=\"nf\">add_range</span><span class=\"p\">(</span><span class=\"n\">block</span><span class=\"p\">.</span><span class=\"nf\">from</span><span class=\"p\">,</span> <span class=\"n\">insn</span><span class=\"p\">.</span><span class=\"nf\">number</span><span class=\"p\">)</span>\n        <span class=\"k\">end</span>\n      <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">intervals</span><span class=\"p\">.</span><span class=\"nf\">default_proc</span> <span class=\"o\">=</span> <span class=\"kp\">nil</span>\n    <span class=\"n\">intervals</span><span class=\"p\">.</span><span class=\"nf\">freeze</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>Another difference is that since we’re using block parameters, we don’t really\nhave this <code class=\"language-plaintext highlighter-rouge\">phi.inputOf</code> thing. That’s just the block argument.</p>\n\n<p>The last difference is that since we’re skipping the loop liveness hack, we\ndon’t modify a block’s <code class=\"language-plaintext highlighter-rouge\">live</code> set as we iterate through instructions.</p>\n\n<p>I know we said we’re building live ranges, so our <code class=\"language-plaintext highlighter-rouge\">Interval</code> class only has\none <code class=\"language-plaintext highlighter-rouge\">Range</code> on it. This is Ruby’s built-in range, but it’s really just being\nused as a tuple of integers here.</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Interval</span>\n  <span class=\"nb\">attr_reader</span> <span class=\"ss\">:range</span>\n\n  <span class=\"k\">def</span> <span class=\"nf\">add_range</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">,</span> <span class=\"n\">to</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">to</span> <span class=\"o\">&lt;=</span> <span class=\"n\">from</span>\n      <span class=\"k\">raise</span> <span class=\"no\">ArgumentError</span><span class=\"p\">,</span> <span class=\"s2\">\"Invalid range: </span><span class=\"si\">#{</span><span class=\"n\">from</span><span class=\"si\">}</span><span class=\"s2\"> to </span><span class=\"si\">#{</span><span class=\"n\">to</span><span class=\"si\">}</span><span class=\"s2\">\"</span>\n    <span class=\"k\">end</span>\n    <span class=\"k\">if</span> <span class=\"o\">!</span><span class=\"vi\">@range</span>\n      <span class=\"vi\">@range</span> <span class=\"o\">=</span> <span class=\"no\">Range</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">,</span> <span class=\"n\">to</span><span class=\"p\">)</span>\n      <span class=\"k\">return</span>\n    <span class=\"k\">end</span>\n    <span class=\"vi\">@range</span> <span class=\"o\">=</span> <span class=\"no\">Range</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">([</span><span class=\"vi\">@range</span><span class=\"p\">.</span><span class=\"nf\">begin</span><span class=\"p\">,</span> <span class=\"n\">from</span><span class=\"p\">].</span><span class=\"nf\">min</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"vi\">@range</span><span class=\"p\">.</span><span class=\"nf\">end</span><span class=\"p\">,</span> <span class=\"n\">to</span><span class=\"p\">].</span><span class=\"nf\">max</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"k\">def</span> <span class=\"nf\">set_from</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">)</span>\n    <span class=\"vi\">@range</span> <span class=\"o\">=</span> <span class=\"k\">if</span> <span class=\"vi\">@range</span>\n      <span class=\"k\">if</span> <span class=\"vi\">@range</span><span class=\"p\">.</span><span class=\"nf\">end</span> <span class=\"o\">&lt;=</span> <span class=\"n\">from</span>\n        <span class=\"k\">raise</span> <span class=\"no\">ArgumentError</span><span class=\"p\">,</span> <span class=\"s2\">\"Invalid range: </span><span class=\"si\">#{</span><span class=\"n\">from</span><span class=\"si\">}</span><span class=\"s2\"> to </span><span class=\"si\">#{</span><span class=\"vi\">@range</span><span class=\"p\">.</span><span class=\"nf\">end</span><span class=\"si\">}</span><span class=\"s2\">\"</span>\n      <span class=\"k\">end</span>\n      <span class=\"no\">Range</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">,</span> <span class=\"vi\">@range</span><span class=\"p\">.</span><span class=\"nf\">end</span><span class=\"p\">)</span>\n    <span class=\"k\">else</span>\n      <span class=\"c1\"># This happens when we don't have a use of the vreg</span>\n      <span class=\"c1\"># If we don't have a use, the live range is very short</span>\n      <span class=\"no\">Range</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">,</span> <span class=\"n\">from</span><span class=\"p\">)</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"k\">def</span> <span class=\"nf\">==</span><span class=\"p\">(</span><span class=\"n\">other</span><span class=\"p\">)</span>\n    <span class=\"n\">other</span><span class=\"p\">.</span><span class=\"nf\">is_a?</span><span class=\"p\">(</span><span class=\"no\">Interval</span><span class=\"p\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"vi\">@range</span> <span class=\"o\">==</span> <span class=\"n\">other</span><span class=\"p\">.</span><span class=\"nf\">range</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>Note that there’s some implicit behavior happening here:</p>\n\n<ul>\n  <li>If we haven’t initialized a range yet, we build one automatically</li>\n  <li>If we have a range, <code class=\"language-plaintext highlighter-rouge\">add_range</code> builds the smallest range that overlaps with\nthe existing range and incoming information</li>\n  <li>If we have a range, <code class=\"language-plaintext highlighter-rouge\">set_from</code> may shrink it</li>\n</ul>\n\n<p>For example, if we have <code class=\"language-plaintext highlighter-rouge\">[1, 5)</code> and someone calls <code class=\"language-plaintext highlighter-rouge\">add_range(7, 10)</code>, we end\nup with <code class=\"language-plaintext highlighter-rouge\">[1, 10)</code>. There’s no gap in the middle.</p>\n\n<p>And if we have <code class=\"language-plaintext highlighter-rouge\">[1, 7)</code> and someone calls <code class=\"language-plaintext highlighter-rouge\">set_from(3)</code>, we end up with <code class=\"language-plaintext highlighter-rouge\">[3,\n7)</code>.</p>\n\n<p>After figuring out from scratch some of these assumptions about what the\ninterval/range API should and should not do, Aaron and I realized that there\nwas some actual code for <code class=\"language-plaintext highlighter-rouge\">add_range</code> in a different, earlier paper: <a href=\"/assets/img/linear-scan-ra-context-ssa.pdf\">Linear\nScan Register Allocation in the Context of SSA Form and Register\nConstraints</a> (PDF, 2002) by Mössenböck and Pfeiffer.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ADDRANGE(i: Instruction; b: Block; end: integer)\n  if b.first.n ≤ i.n ≤ b.last.n then range ← [i.n, end[ else range ← [b.first.n, end[\n  add range to interval[i.n] // merging adjacent ranges\n</code></pre></div></div>\n\n<p>Unfortunately, many other versions of this PDF look absolutely horrible (like\nbad OCR) and I had to do some digging to find the version linked above.</p>\n\n<p>Finally we can start thinking about doing some actual register assignment.\nLet’s return to the 90s.</p>\n\n<h2 id=\"linear-scan\">Linear scan</h2>\n\n<p>Because we have faithfully kept 1 interval == 1 range, we can re-use the linear\nscan algorithm from Poletto1999 (which looks, at a glance, to be the same\nas 1997).</p>\n\n<p>I recommend looking at the PDF side by side with the code. We have tried to\nkeep the structure very similar.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>LinearScanRegisterAllocation\nactive ← {}\nforeach live interval i, in order of increasing start point\n  ExpireOldIntervals(i)\n  if length(active) = R then\n    SpillAtInterval(i)\n  else\n    register[i] ← a register removed from pool of free registers\n    add i to active, sorted by increasing end point\n\nExpireOldIntervals(i)\nforeach interval j in active, in order of increasing end point\n  if endpoint[j] ≥ startpoint[i] then\n    return\n  remove j from active\n  add register[j] to pool of free registers\n\nSpillAtInterval(i)\nspill ← last interval in active\nif endpoint[spill] &gt; endpoint[i] then\n  register[i] ← register[spill]\n  location[spill] ← new stack location\n  remove spill from active\n  add i to active, sorted by increasing end point\nelse\n  location[i] ← new stack location\n</code></pre></div></div>\n\n<p>Note that unlike in many programming languages these days, <code class=\"language-plaintext highlighter-rouge\">{}</code> in the\nalgorithm description represents a <em>set</em>, not a (hash-)map.</p>\n\n<p>In our Ruby code, we represent <code class=\"language-plaintext highlighter-rouge\">active</code> as an array:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Function</span>\n  <span class=\"k\">def</span> <span class=\"nf\">ye_olde_linear_scan</span> <span class=\"n\">intervals</span><span class=\"p\">,</span> <span class=\"n\">num_registers</span>\n    <span class=\"k\">if</span> <span class=\"n\">num_registers</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">0</span>\n      <span class=\"k\">raise</span> <span class=\"no\">ArgumentError</span><span class=\"p\">,</span> <span class=\"s2\">\"Number of registers must be positive\"</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">free_registers</span> <span class=\"o\">=</span> <span class=\"no\">Set</span><span class=\"p\">.</span><span class=\"nf\">new</span> <span class=\"mi\">0</span><span class=\"o\">...</span><span class=\"n\">num_registers</span>\n    <span class=\"n\">active</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>  <span class=\"c1\"># Active intervals, sorted by increasing end point</span>\n    <span class=\"n\">assignment</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>  <span class=\"c1\"># Map from Interval to PReg|StackSlot</span>\n    <span class=\"n\">num_stack_slots</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"c1\"># Iterate through intervals in order of increasing start point</span>\n    <span class=\"c1\"># TODO(max): Build a deque for intervals, pushing to the front, so we</span>\n    <span class=\"c1\"># automatically get this in sorted order</span>\n    <span class=\"n\">sorted_intervals</span> <span class=\"o\">=</span> <span class=\"n\">intervals</span><span class=\"p\">.</span><span class=\"nf\">sort_by</span> <span class=\"p\">{</span> <span class=\"o\">|</span><span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">interval</span><span class=\"o\">|</span> <span class=\"n\">interval</span><span class=\"p\">.</span><span class=\"nf\">range</span><span class=\"p\">.</span><span class=\"nf\">begin</span> <span class=\"p\">}</span>\n    <span class=\"n\">sorted_intervals</span><span class=\"p\">.</span><span class=\"nf\">each</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">_vreg</span><span class=\"p\">,</span> <span class=\"n\">interval</span><span class=\"o\">|</span>\n      <span class=\"c1\"># expire_old_intervals(interval)</span>\n      <span class=\"n\">active</span><span class=\"p\">.</span><span class=\"nf\">select!</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">active_interval</span><span class=\"o\">|</span>\n        <span class=\"k\">if</span> <span class=\"n\">active_interval</span><span class=\"p\">.</span><span class=\"nf\">range</span><span class=\"p\">.</span><span class=\"nf\">end</span> <span class=\"o\">&gt;</span> <span class=\"n\">interval</span><span class=\"p\">.</span><span class=\"nf\">range</span><span class=\"p\">.</span><span class=\"nf\">begin</span>\n          <span class=\"kp\">true</span>\n        <span class=\"k\">else</span>\n          <span class=\"n\">operand</span> <span class=\"o\">=</span> <span class=\"n\">assignment</span><span class=\"p\">.</span><span class=\"nf\">fetch</span><span class=\"p\">(</span><span class=\"n\">active_interval</span><span class=\"p\">)</span>\n          <span class=\"k\">raise</span> <span class=\"s2\">\"Should be assigned a register\"</span> <span class=\"k\">unless</span> <span class=\"n\">operand</span><span class=\"p\">.</span><span class=\"nf\">is_a?</span><span class=\"p\">(</span><span class=\"no\">PReg</span><span class=\"p\">)</span>\n          <span class=\"n\">free_registers</span><span class=\"p\">.</span><span class=\"nf\">add</span><span class=\"p\">(</span><span class=\"n\">operand</span><span class=\"p\">.</span><span class=\"nf\">name</span><span class=\"p\">)</span>\n          <span class=\"kp\">false</span>\n        <span class=\"k\">end</span>\n      <span class=\"k\">end</span>\n      <span class=\"k\">if</span> <span class=\"n\">active</span><span class=\"p\">.</span><span class=\"nf\">length</span> <span class=\"o\">==</span> <span class=\"n\">num_registers</span>\n        <span class=\"c1\"># spill_at_interval(interval)</span>\n        <span class=\"c1\"># Pick an interval to spill. Picking the longest-lived active one is</span>\n        <span class=\"c1\"># a heuristic from the original linear scan paper.</span>\n        <span class=\"n\">spill</span> <span class=\"o\">=</span> <span class=\"n\">active</span><span class=\"p\">.</span><span class=\"nf\">last</span>\n        <span class=\"c1\"># In either case, we need to allocate a slot on the stack.</span>\n        <span class=\"n\">slot</span> <span class=\"o\">=</span> <span class=\"no\">StackSlot</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">num_stack_slots</span><span class=\"p\">)</span>\n        <span class=\"n\">num_stack_slots</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n        <span class=\"k\">if</span> <span class=\"n\">spill</span><span class=\"p\">.</span><span class=\"nf\">range</span><span class=\"p\">.</span><span class=\"nf\">end</span> <span class=\"o\">&gt;</span> <span class=\"n\">interval</span><span class=\"p\">.</span><span class=\"nf\">range</span><span class=\"p\">.</span><span class=\"nf\">end</span>\n          <span class=\"c1\"># The last active interval ends further away than the current</span>\n          <span class=\"c1\"># interval; spill the last active interval.</span>\n          <span class=\"n\">assignment</span><span class=\"p\">[</span><span class=\"n\">interval</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">assignment</span><span class=\"p\">[</span><span class=\"n\">spill</span><span class=\"p\">]</span>\n          <span class=\"k\">raise</span> <span class=\"s2\">\"Should be assigned a register\"</span> <span class=\"k\">unless</span> <span class=\"n\">assignment</span><span class=\"p\">[</span><span class=\"n\">interval</span><span class=\"p\">].</span><span class=\"nf\">is_a?</span><span class=\"p\">(</span><span class=\"no\">PReg</span><span class=\"p\">)</span>\n          <span class=\"n\">assignment</span><span class=\"p\">[</span><span class=\"n\">spill</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">slot</span>\n          <span class=\"n\">active</span><span class=\"p\">.</span><span class=\"nf\">pop</span>  <span class=\"c1\"># We know spill is the last one</span>\n          <span class=\"c1\"># Insert interval into already-sorted active</span>\n          <span class=\"n\">insert_idx</span> <span class=\"o\">=</span> <span class=\"n\">active</span><span class=\"p\">.</span><span class=\"nf\">bsearch_index</span> <span class=\"p\">{</span> <span class=\"o\">|</span><span class=\"n\">i</span><span class=\"o\">|</span> <span class=\"n\">i</span><span class=\"p\">.</span><span class=\"nf\">range</span><span class=\"p\">.</span><span class=\"nf\">end</span> <span class=\"o\">&gt;=</span> <span class=\"n\">interval</span><span class=\"p\">.</span><span class=\"nf\">range</span><span class=\"p\">.</span><span class=\"nf\">end</span> <span class=\"p\">}</span> <span class=\"o\">||</span> <span class=\"n\">active</span><span class=\"p\">.</span><span class=\"nf\">length</span>\n          <span class=\"n\">active</span><span class=\"p\">.</span><span class=\"nf\">insert</span><span class=\"p\">(</span><span class=\"n\">insert_idx</span><span class=\"p\">,</span> <span class=\"n\">interval</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span>\n          <span class=\"c1\"># The current interval ends further away than the last active</span>\n          <span class=\"c1\"># interval; spill the current interval.</span>\n          <span class=\"n\">assignment</span><span class=\"p\">[</span><span class=\"n\">interval</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">slot</span>\n        <span class=\"k\">end</span>\n      <span class=\"k\">else</span>\n        <span class=\"n\">reg</span> <span class=\"o\">=</span> <span class=\"n\">free_registers</span><span class=\"p\">.</span><span class=\"nf\">min</span>\n        <span class=\"n\">free_registers</span><span class=\"p\">.</span><span class=\"nf\">delete</span><span class=\"p\">(</span><span class=\"n\">reg</span><span class=\"p\">)</span>\n        <span class=\"n\">assignment</span><span class=\"p\">[</span><span class=\"n\">interval</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"no\">PReg</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">reg</span><span class=\"p\">)</span>\n        <span class=\"c1\"># Insert interval into already-sorted active</span>\n        <span class=\"n\">insert_idx</span> <span class=\"o\">=</span> <span class=\"n\">active</span><span class=\"p\">.</span><span class=\"nf\">bsearch_index</span> <span class=\"p\">{</span> <span class=\"o\">|</span><span class=\"n\">i</span><span class=\"o\">|</span> <span class=\"n\">i</span><span class=\"p\">.</span><span class=\"nf\">range</span><span class=\"p\">.</span><span class=\"nf\">end</span> <span class=\"o\">&gt;=</span> <span class=\"n\">interval</span><span class=\"p\">.</span><span class=\"nf\">range</span><span class=\"p\">.</span><span class=\"nf\">end</span> <span class=\"p\">}</span> <span class=\"o\">||</span> <span class=\"n\">active</span><span class=\"p\">.</span><span class=\"nf\">length</span>\n        <span class=\"n\">active</span><span class=\"p\">.</span><span class=\"nf\">insert</span><span class=\"p\">(</span><span class=\"n\">insert_idx</span><span class=\"p\">,</span> <span class=\"n\">interval</span><span class=\"p\">)</span>\n      <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n    <span class=\"p\">[</span><span class=\"n\">assignment</span><span class=\"p\">,</span> <span class=\"n\">num_stack_slots</span><span class=\"p\">]</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>Internalizing this took us a bit. It is mostly a three-state machine:</p>\n\n<ul>\n  <li>have not been allocated</li>\n  <li>have been allocated a register</li>\n  <li>have been allocated a stack slot</li>\n</ul>\n\n<p>We would like to come back to this and incrementally modify it as we add\nlifetime holes to intervals.</p>\n\n<p>I finally understood, very late in the game, that Poletto1999 linear scan assigns only one\nlocation per virtual register. <em>Ever</em>. It’s not that every virtual register\ngets a shot in a register and then gets moved to a stack slot—that would be\ninterval splitting and hopefully we get to that later—if a register gets\nspilled, it’s in a stack slot from beginning to end.</p>\n\n<p>I only found this out accidentally after trying to figure out a bug (that\nwasn’t a bug) due to a lovely sentence in <a href=\"/assets/img/optimized-interval-splitting-linear-scan-ra.pdf\">Optimized Interval Splitting in a\nLinear Scan Register Allocator</a> (PDF, 2005) by\nWimmer and Mössenböck):</p>\n\n<blockquote>\n  <p>However, it cannot deal with lifetime holes and does not split intervals, so\nan interval has either a register assigned for the whole lifetime, or it is\nspilled completely.</p>\n</blockquote>\n\n<p>Also,</p>\n\n<blockquote>\n  <p>In particular, it is not possible to implement the algorithm without\nreserving a scratch register: When a spilled interval is used by an\ninstruction requiring the operand in a register, the interval must be\ntemporarily reloaded to the scratch register</p>\n</blockquote>\n\n<p>Also,</p>\n\n<blockquote>\n  <p>Additionally, register constraints for method calls and instructions\nrequiring fixed registers must be handled separately</p>\n</blockquote>\n\n<p>Marvelous.</p>\n\n<p>Let’s take a look at the code snippet again. Here it is before register\nallocation, using virtual registers:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>16: label B1(R10, R11):\n18: jmp B2($1, R11)\n     # vvvvvvvvvv #\n20: label B2(R12, R13)\n22: cmp R13, $1\n24: branch lessThan B4()\n\n26: label B3()\n28: mul R12, R13 -&gt; R14\n30: sub R13, $1 -&gt; R15\n32: jump B2(R14, R15)\n\n34: label B4()\n     # ^^^^^^^^^^ #\n36: add R10, R12 -&gt; R16\n38: ret R16\n</code></pre></div></div>\n\n<p>Let’s run it through register allocation with incrementally decreasing numbers\nof physical registers available. We get the following assignments:</p>\n\n<ul>\n  <li>4 registers <code class=\"language-plaintext highlighter-rouge\">{R10: P0, R11: P1, R12: P1, R13: P2, R14: P3, R15: P2, R16: P0}</code></li>\n  <li>3 registers <code class=\"language-plaintext highlighter-rouge\">{R10: Stack[0], R11: P1, R12: P1, R13: P2, R14: P0, R15: P2, R16: P0}</code></li>\n  <li>2 registers <code class=\"language-plaintext highlighter-rouge\">{R10: Stack[0], R11: P1, R12: Stack[1], R13: P0, R14: P1, R15: P0, R16: P0}</code></li>\n  <li>1 register <code class=\"language-plaintext highlighter-rouge\">{R10: Stack[0], R11: P0, R12: Stack[1], R13: P0, R14: Stack[2], R15: P0, R16: P0}</code></li>\n</ul>\n\n<p>Some other things to note:</p>\n\n<ul>\n  <li>\n    <p>If you have a register free, choosing which register to allocate is a\nheuristic! It is tunable. There is probably some research out there that\nexplores the space.</p>\n\n    <p>In fact, you might even consider <em>not</em> allocating a register greedily. What\nmight that look like? I have no idea.</p>\n  </li>\n  <li>\n    <p>Spilling the interval with the furthest endpoint is a heuristic! You can\npick any active interval you want. In <a href=\"/assets/img/register-spilling-range-splitting-ssa.pdf\">Register Spilling and Live-Range\nSplitting for SSA-Form Programs</a> (PDF,\n2009) by Braun and Hack, for example, they present the MIN algorithm, which\nspills the interval with the furthest next use.</p>\n\n    <p>This requires slightly more information and takes slightly more time than\nthe default heuristic but apparently generates much better code.</p>\n  </li>\n  <li>\n    <p>Also, block ordering? You guessed it. Heuristic.</p>\n  </li>\n</ul>\n\n<p>Here is an example “slideshow” I generated by running linear scan with 2\nregisters. Use the arrow keys to navigate forward and backward in time<sup id=\"fnref:rsms\"><a class=\"footnote\" href=\"#fn:rsms\" rel=\"footnote\">4</a></sup>.</p>\n\n\n\n<h2 id=\"resolving-ssa\">Resolving SSA</h2>\n\n<p>At this point we have register <em>assignments</em>: we have a hash table mapping\nintervals to physical locations. That’s great but we’re still in SSA form:\nlabelled code regions don’t have block arguments in hardware. We need to write\nsome code to take us out of SSA and into the real world.</p>\n\n<p>We can use a modified Wimmer2010 as a great start point here. It handles more\nthan we need to right now—interval splitting—but we can simplify.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>RESOLVE\nfor each control flow edge from predecessor to successor do\n  for each interval it live at begin of successor do\n    if it starts at begin of successor then\n      phi = phi function defining it\n      opd = phi.inputOf(predecessor)\n      if opd is a constant then\n        moveFrom = opd\n      else\n        moveFrom = location of intervals[opd] at end of predecessor\n    else\n      moveFrom = location of it at end of predecessor\n    moveTo = location of it at begin of successor\n    if moveFrom ≠ moveTo then\n      mapping.add(moveFrom, moveTo)\n  mapping.orderAndInsertMoves()\n</code></pre></div></div>\n\n<p>Because we don’t split intervals, we know that every interval live at the\nbeginning of a block is either:</p>\n\n<ul>\n  <li>live across an edge between two blocks and therefore has already been placed\nin a location by assignment/spill code</li>\n  <li>beginning its life at the beginning of the block as a block parameter and\ntherefore needs to be moved from its source location</li>\n</ul>\n\n<p>For this reason, we only handle the second case in our SSA resolution. If we\nadded <del>lifetime holes</del> interval splitting, we would have to go back to the\nfull Wimmer SSA resolution.</p>\n\n<p>This means that we’re going to iterate over every outbound edge from every\nblock. For each edge, we’re going to insert some parallel moves.</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Function</span>\n  <span class=\"k\">def</span> <span class=\"nf\">resolve_ssa</span> <span class=\"n\">intervals</span><span class=\"p\">,</span> <span class=\"n\">assignments</span>\n    <span class=\"c1\"># ...</span>\n    <span class=\"vi\">@block_order</span><span class=\"p\">.</span><span class=\"nf\">each</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">predecessor</span><span class=\"o\">|</span>\n      <span class=\"n\">outgoing_edges</span> <span class=\"o\">=</span> <span class=\"n\">predecessor</span><span class=\"p\">.</span><span class=\"nf\">edges</span>\n      <span class=\"n\">num_successors</span> <span class=\"o\">=</span> <span class=\"n\">outgoing_edges</span><span class=\"p\">.</span><span class=\"nf\">length</span>\n      <span class=\"n\">outgoing_edges</span><span class=\"p\">.</span><span class=\"nf\">each</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">edge</span><span class=\"o\">|</span>\n        <span class=\"n\">mapping</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"n\">successor</span> <span class=\"o\">=</span> <span class=\"n\">edge</span><span class=\"p\">.</span><span class=\"nf\">block</span>\n        <span class=\"n\">edge</span><span class=\"p\">.</span><span class=\"nf\">args</span><span class=\"p\">.</span><span class=\"nf\">zip</span><span class=\"p\">(</span><span class=\"n\">successor</span><span class=\"p\">.</span><span class=\"nf\">parameters</span><span class=\"p\">).</span><span class=\"nf\">each</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">moveFrom</span><span class=\"p\">,</span> <span class=\"n\">moveTo</span><span class=\"o\">|</span>\n          <span class=\"k\">if</span> <span class=\"n\">moveFrom</span> <span class=\"o\">!=</span> <span class=\"n\">moveTo</span>\n            <span class=\"n\">mapping</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">[</span><span class=\"n\">moveFrom</span><span class=\"p\">,</span> <span class=\"n\">moveTo</span><span class=\"p\">]</span>\n          <span class=\"k\">end</span>\n        <span class=\"k\">end</span>\n        <span class=\"c1\"># predecessor.order_and_insert_moves(mapping)</span>\n        <span class=\"c1\"># TODO: order_and_insert_moves</span>\n      <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n    <span class=\"c1\"># Remove all block parameters and arguments; we have resolved SSA</span>\n    <span class=\"vi\">@block_order</span><span class=\"p\">.</span><span class=\"nf\">each</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">block</span><span class=\"o\">|</span>\n      <span class=\"n\">block</span><span class=\"p\">.</span><span class=\"nf\">parameters</span><span class=\"p\">.</span><span class=\"nf\">clear</span>\n      <span class=\"n\">block</span><span class=\"p\">.</span><span class=\"nf\">edges</span><span class=\"p\">.</span><span class=\"nf\">each</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">edge</span><span class=\"o\">|</span>\n        <span class=\"n\">edge</span><span class=\"p\">.</span><span class=\"nf\">args</span><span class=\"p\">.</span><span class=\"nf\">clear</span>\n      <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>This already looks very similar to the RESOLVE function from Wimmer2010.\nUnfortunately, Wimmer2010 basically shrugs off <code class=\"language-plaintext highlighter-rouge\">orderAndInsertMoves</code> with an <em>eh, it’s\nalready in the literature</em> comment.</p>\n\n<h3 id=\"a-brief-and-frustrating-parallel-moves-detour\">A brief and frustrating parallel moves detour</h3>\n\n<p>What’s not made clear, though, is that this particular subroutine has been the\nsource of a significant amount of bugs in the literature. Only recently did\nsome folks roll through and suggest (proven!) fixes:</p>\n\n<ul>\n  <li><a href=\"/assets/img/parallel-move-leroy.pdf\">Battling windmills with Coq: formal verification of a compilation algorithm\nfor parallel moves</a> (PDF, 2007) by Rideau, Serpette, and\nLeroy</li>\n  <li><a href=\"/assets/img/boissinot-out-ssa.pdf\">Revisiting Out-of-SSA Translation for Correctness, Code Quality, and\nEfficiency</a> (PDF, 2009) by Boissinot, Darte, Rastello,\nDupont de Dinechin, and Guillon.\n    <ul>\n      <li>and again in <a href=\"/assets/img/boissinot-thesis.pdf\">Boissinot’s thesis</a> (PDF, 2010)</li>\n    </ul>\n  </li>\n</ul>\n\n<p>This sent us on a deep rabbit hole of trying to understand what bugs occur,\nwhen, and how to fix them. We implemented both the Leroy and the Boissinot\nalgorithms. We found differences between Boissinot2009, Boissinot2010, and the\nSSA book implementation following those algorithms. We found Paul Sokolovsky’s\n<a href=\"https://github.com/pfalcon/parcopy/\">implementation with bugfixes</a>. We found\nDmitry Stogov’s <a href=\"https://github.com/pfalcon/parcopy/pull/1\">unmerged pull\nrequest</a> to the same repository to\nfix another bug.</p>\n\n<p>We looked at Benoit Boissinot’s thesis again and emailed him some questions. He\nresponded! And then he even put up an <a href=\"https://github.com/bboissin/thesis_bboissin\">amended version of his\nalgorithm</a> in Rust with tests and\nfuzzing.</p>\n\n<p>All this is to say that this is still causing people grief and, though I\nunderstand page limits, I wish parallel moves were not handwaved away.</p>\n\n<p>We ended up with this implementation which passes all of the tests from\nSokolovsky’s repository as well as the example from Boissinot’s thesis (though,\nas we discussed in the email, the example solution in the thesis is\nincorrect<sup id=\"fnref:thesis-correction\"><a class=\"footnote\" href=\"#fn:thesis-correction\" rel=\"footnote\">5</a></sup>).</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># copies contains an array of [src, dst] arrays</span>\n<span class=\"k\">def</span> <span class=\"nf\">sequentialize</span> <span class=\"n\">copies</span>\n  <span class=\"n\">ready</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>  <span class=\"c1\"># Contains only destination regs (\"available\")</span>\n  <span class=\"n\">to_do</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>  <span class=\"c1\"># Contains only destination regs</span>\n  <span class=\"n\">pred</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>  <span class=\"c1\"># Map of destination reg -&gt; what reg is written to it (its source)</span>\n  <span class=\"n\">loc</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>  <span class=\"c1\"># Map of reg -&gt; the current location where the initial value of reg is available (\"resource\")</span>\n  <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n\n  <span class=\"n\">emit_copy</span> <span class=\"o\">=</span> <span class=\"o\">-&gt;</span> <span class=\"p\">(</span><span class=\"n\">src</span><span class=\"p\">,</span> <span class=\"n\">dst</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\"># We add an arrow here just for clarity in reading this algorithm because</span>\n    <span class=\"c1\"># different people do [src, dst] and [dst, src] depending on if they prefer</span>\n    <span class=\"c1\"># Intel or AT&amp;T</span>\n    <span class=\"n\">result</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">[</span><span class=\"n\">src</span><span class=\"p\">,</span> <span class=\"s2\">\"-&gt;\"</span><span class=\"p\">,</span> <span class=\"n\">dst</span><span class=\"p\">]</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"c1\"># In Ruby, loc[x] is nil if x not in loc, so this loop could be omitted</span>\n  <span class=\"n\">copies</span><span class=\"p\">.</span><span class=\"nf\">each</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"p\">(</span><span class=\"n\">src</span><span class=\"p\">,</span> <span class=\"n\">dst</span><span class=\"p\">)</span><span class=\"o\">|</span>\n    <span class=\"n\">loc</span><span class=\"p\">[</span><span class=\"n\">dst</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kp\">nil</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"n\">copies</span><span class=\"p\">.</span><span class=\"nf\">each</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"p\">(</span><span class=\"n\">src</span><span class=\"p\">,</span> <span class=\"n\">dst</span><span class=\"p\">)</span><span class=\"o\">|</span>\n    <span class=\"n\">loc</span><span class=\"p\">[</span><span class=\"n\">src</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">src</span>\n    <span class=\"k\">if</span> <span class=\"n\">pred</span><span class=\"p\">.</span><span class=\"nf\">key?</span> <span class=\"n\">dst</span>  <span class=\"c1\"># Alternatively, to_do.include? dst</span>\n      <span class=\"k\">raise</span> <span class=\"s2\">\"Conflicting assignments to destination </span><span class=\"si\">#{</span><span class=\"n\">dst</span><span class=\"si\">}</span><span class=\"s2\">, latest: </span><span class=\"si\">#{</span><span class=\"p\">[</span><span class=\"n\">dst</span><span class=\"p\">,</span> <span class=\"n\">src</span><span class=\"p\">]</span><span class=\"si\">}</span><span class=\"s2\">\"</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">pred</span><span class=\"p\">[</span><span class=\"n\">dst</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">src</span>\n    <span class=\"n\">to_do</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">dst</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"n\">copies</span><span class=\"p\">.</span><span class=\"nf\">each</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"p\">(</span><span class=\"n\">src</span><span class=\"p\">,</span> <span class=\"n\">dst</span><span class=\"p\">)</span><span class=\"o\">|</span>\n    <span class=\"k\">if</span> <span class=\"o\">!</span><span class=\"n\">loc</span><span class=\"p\">[</span><span class=\"n\">dst</span><span class=\"p\">]</span>\n      <span class=\"c1\"># All destinations that are not also sources can be written to immediately (tree leaves)</span>\n      <span class=\"n\">ready</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">dst</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"k\">while</span> <span class=\"o\">!</span><span class=\"n\">to_do</span><span class=\"p\">.</span><span class=\"nf\">empty?</span>\n    <span class=\"k\">while</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">ready</span><span class=\"p\">.</span><span class=\"nf\">pop</span>\n      <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">loc</span><span class=\"p\">[</span><span class=\"n\">pred</span><span class=\"p\">[</span><span class=\"n\">b</span><span class=\"p\">]]</span> <span class=\"c1\"># a in the paper</span>\n      <span class=\"n\">emit_copy</span><span class=\"o\">.</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">)</span>\n      <span class=\"c1\"># pred[b] is now living at b</span>\n      <span class=\"n\">loc</span><span class=\"p\">[</span><span class=\"n\">pred</span><span class=\"p\">[</span><span class=\"n\">b</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"n\">b</span>\n      <span class=\"k\">if</span> <span class=\"n\">to_do</span><span class=\"p\">.</span><span class=\"nf\">include?</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span>\n        <span class=\"n\">to_do</span><span class=\"p\">.</span><span class=\"nf\">delete</span> <span class=\"n\">a</span>\n      <span class=\"k\">end</span>\n      <span class=\"k\">if</span> <span class=\"n\">pred</span><span class=\"p\">[</span><span class=\"n\">b</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">a</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">pred</span><span class=\"p\">.</span><span class=\"nf\">include?</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span>\n        <span class=\"n\">ready</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">a</span>\n      <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">to_do</span><span class=\"p\">.</span><span class=\"nf\">empty?</span>\n      <span class=\"k\">break</span>\n    <span class=\"k\">end</span>\n\n    <span class=\"n\">dst</span> <span class=\"o\">=</span> <span class=\"n\">to_do</span><span class=\"p\">.</span><span class=\"nf\">pop</span>\n    <span class=\"k\">if</span> <span class=\"n\">dst</span> <span class=\"o\">!=</span> <span class=\"n\">loc</span><span class=\"p\">[</span><span class=\"n\">pred</span><span class=\"p\">[</span><span class=\"n\">dst</span><span class=\"p\">]]</span>\n      <span class=\"n\">emit_copy</span><span class=\"o\">.</span><span class=\"p\">(</span><span class=\"n\">dst</span><span class=\"p\">,</span> <span class=\"s2\">\"tmp\"</span><span class=\"p\">)</span>\n      <span class=\"n\">loc</span><span class=\"p\">[</span><span class=\"n\">dst</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s2\">\"tmp\"</span>\n      <span class=\"n\">ready</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">dst</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n  <span class=\"n\">result</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>Leroy’s algorithm, which is shorter, passes almost all the tests—in one test\ncase, it uses one more temporary variable than Boissinot’s does. We haven’t\nspent much time looking at why.</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">move_one</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">src</span><span class=\"p\">,</span> <span class=\"n\">dst</span><span class=\"p\">,</span> <span class=\"n\">status</span><span class=\"p\">,</span> <span class=\"n\">result</span>\n  <span class=\"k\">return</span> <span class=\"k\">if</span> <span class=\"n\">src</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">dst</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n  <span class=\"n\">status</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"ss\">:being_moved</span>\n  <span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"k\">in</span> <span class=\"mi\">0</span><span class=\"o\">...</span><span class=\"p\">(</span><span class=\"n\">src</span><span class=\"p\">.</span><span class=\"nf\">length</span><span class=\"p\">)</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"n\">src</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">dst</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n      <span class=\"k\">case</span> <span class=\"n\">status</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span>\n      <span class=\"k\">when</span> <span class=\"ss\">:to_move</span>\n        <span class=\"n\">move_one</span> <span class=\"n\">j</span><span class=\"p\">,</span> <span class=\"n\">src</span><span class=\"p\">,</span> <span class=\"n\">dst</span><span class=\"p\">,</span> <span class=\"n\">status</span><span class=\"p\">,</span> <span class=\"n\">result</span>\n      <span class=\"k\">when</span> <span class=\"ss\">:being_moved</span>\n        <span class=\"n\">result</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">[</span><span class=\"n\">src</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">],</span> <span class=\"s2\">\"-&gt;\"</span><span class=\"p\">,</span> <span class=\"s2\">\"tmp\"</span><span class=\"p\">]</span>\n        <span class=\"n\">src</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s2\">\"tmp\"</span>\n      <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n  <span class=\"n\">result</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">[</span><span class=\"n\">src</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"s2\">\"-&gt;\"</span><span class=\"p\">,</span> <span class=\"n\">dst</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]]</span>\n  <span class=\"n\">status</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"ss\">:moved</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">leroy_sequentialize</span> <span class=\"n\">copies</span>\n  <span class=\"n\">src</span> <span class=\"o\">=</span> <span class=\"n\">copies</span><span class=\"p\">.</span><span class=\"nf\">map</span> <span class=\"p\">{</span> <span class=\"n\">it</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"p\">}</span>\n  <span class=\"n\">dst</span> <span class=\"o\">=</span> <span class=\"n\">copies</span><span class=\"p\">.</span><span class=\"nf\">map</span> <span class=\"p\">{</span> <span class=\"n\">it</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"p\">}</span>\n  <span class=\"n\">status</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"ss\">:to_move</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">src</span><span class=\"p\">.</span><span class=\"nf\">length</span>\n  <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n  <span class=\"n\">status</span><span class=\"p\">.</span><span class=\"nf\">each_with_index</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">item</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"o\">|</span>\n    <span class=\"k\">if</span> <span class=\"n\">item</span> <span class=\"o\">==</span> <span class=\"ss\">:to_move</span>\n      <span class=\"n\">move_one</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">src</span><span class=\"p\">,</span> <span class=\"n\">dst</span><span class=\"p\">,</span> <span class=\"n\">status</span><span class=\"p\">,</span> <span class=\"n\">result</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n  <span class=\"n\">result</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<h3 id=\"back-to-ssa-resolution\">Back to SSA resolution</h3>\n\n<p>Whatever algorithm you choose, you now have a way to parallel move some\nregisters to some other registers. You have avoided the “swap problem”.</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Function</span>\n  <span class=\"k\">def</span> <span class=\"nf\">resolve_ssa</span> <span class=\"n\">intervals</span><span class=\"p\">,</span> <span class=\"n\">assignments</span>\n    <span class=\"c1\"># ...</span>\n        <span class=\"c1\"># predecessor.order_and_insert_moves(mapping)</span>\n        <span class=\"n\">sequence</span> <span class=\"o\">=</span> <span class=\"n\">sequentialize</span><span class=\"p\">(</span><span class=\"n\">mapping</span><span class=\"p\">).</span><span class=\"nf\">map</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"p\">(</span><span class=\"n\">src</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">dst</span><span class=\"p\">)</span><span class=\"o\">|</span>\n          <span class=\"no\">Insn</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"ss\">:mov</span><span class=\"p\">,</span> <span class=\"n\">dst</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">src</span><span class=\"p\">])</span>\n        <span class=\"k\">end</span>\n        <span class=\"c1\"># TODO: insert the moves!</span>\n    <span class=\"c1\"># ...</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>That’s great. You can generate an ordered list of instructions from a tangled\ngraph. But where do you put them? What about the “lost copy” problem?</p>\n\n<p>As it turns out, we still need to handle critical edge splitting. Let’s\nconsider what it means to insert moves at an edge between blocks <code class=\"language-plaintext highlighter-rouge\">A -&gt; B</code> when\nthe surrounding CFG looks a couple of different ways.</p>\n\n<ul>\n  <li>Case 1: <code class=\"language-plaintext highlighter-rouge\">A -&gt; B</code></li>\n  <li>Case 2: <code class=\"language-plaintext highlighter-rouge\">A -&gt; B</code> and <code class=\"language-plaintext highlighter-rouge\">A -&gt; C</code></li>\n  <li>Case 3: <code class=\"language-plaintext highlighter-rouge\">A -&gt; B</code> and <code class=\"language-plaintext highlighter-rouge\">D -&gt; B</code></li>\n  <li>Case 4: <code class=\"language-plaintext highlighter-rouge\">A -&gt; B</code> and <code class=\"language-plaintext highlighter-rouge\">A -&gt; C</code> and <code class=\"language-plaintext highlighter-rouge\">D -&gt; B</code></li>\n</ul>\n\n<p>These are the four (really, three) cases we may come across.</p>\n\n<p>In Case 1, if we only have two neighboring blocks A and B, we can\ninsert the moves into either block. It doesn’t matter: at the end of A or at\nthe beginning of B are both fine.</p>\n\n<p>In Case 2, if A has two successors, then we should insert the moves at the\nbeginning of B. That way we won’t be mucking things up for the edge <code class=\"language-plaintext highlighter-rouge\">A -&gt; C</code>.</p>\n\n<p>In Case 3, if B has two predecessors, then we should insert the moves at the\nend of A. That way we won’t be mucking things up for the edge <code class=\"language-plaintext highlighter-rouge\">D -&gt; B</code>.</p>\n\n<p>Case 4 is the most complicated. There is no extant place in the graph we can\ninsert moves. If we insert in A, we mess things up for <code class=\"language-plaintext highlighter-rouge\">A -&gt; C</code>. If we insert\nin <code class=\"language-plaintext highlighter-rouge\">B</code>, we mess things up for <code class=\"language-plaintext highlighter-rouge\">D -&gt; B</code>. Inserting in <code class=\"language-plaintext highlighter-rouge\">C</code> or <code class=\"language-plaintext highlighter-rouge\">D</code> doesn’t make\nany sense. What is there to do?</p>\n\n<p>As it turns out, Case 4 is called a <em>critical edge</em>. And we have to split it.</p>\n\n<p>We can insert a new block E along the edge <code class=\"language-plaintext highlighter-rouge\">A -&gt; B</code> and put the moves in E!\nThat way they still happen along the edge without affecting any other blocks.\nNeat.</p>\n\n<p>In Ruby code, that looks like:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Function</span>\n  <span class=\"k\">def</span> <span class=\"nf\">resolve_ssa</span> <span class=\"n\">intervals</span><span class=\"p\">,</span> <span class=\"n\">assignments</span>\n    <span class=\"n\">num_predecessors</span> <span class=\"o\">=</span> <span class=\"no\">Hash</span><span class=\"p\">.</span><span class=\"nf\">new</span> <span class=\"mi\">0</span>\n    <span class=\"vi\">@block_order</span><span class=\"p\">.</span><span class=\"nf\">each</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">block</span><span class=\"o\">|</span>\n      <span class=\"n\">block</span><span class=\"p\">.</span><span class=\"nf\">edges</span><span class=\"p\">.</span><span class=\"nf\">each</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">edge</span><span class=\"o\">|</span>\n        <span class=\"n\">num_predecessors</span><span class=\"p\">[</span><span class=\"n\">edge</span><span class=\"p\">.</span><span class=\"nf\">block</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n      <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n    <span class=\"c1\"># ...</span>\n        <span class=\"c1\"># predecessor.order_and_insert_moves(mapping)</span>\n        <span class=\"n\">sequence</span> <span class=\"o\">=</span> <span class=\"o\">...</span>\n        <span class=\"c1\"># If we don't have any moves to insert, we don't have any block to</span>\n        <span class=\"c1\"># insert</span>\n        <span class=\"k\">next</span> <span class=\"k\">if</span> <span class=\"n\">sequence</span><span class=\"p\">.</span><span class=\"nf\">empty?</span>\n        <span class=\"k\">if</span> <span class=\"n\">num_predecessors</span><span class=\"p\">[</span><span class=\"n\">successor</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">num_successors</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span>\n          <span class=\"c1\"># Make a new interstitial block</span>\n          <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">new_block</span>\n          <span class=\"n\">b</span><span class=\"p\">.</span><span class=\"nf\">insert_moves_at_start</span> <span class=\"n\">sequence</span>\n          <span class=\"n\">b</span><span class=\"p\">.</span><span class=\"nf\">instructions</span> <span class=\"o\">&lt;&lt;</span> <span class=\"no\">Insn</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"ss\">:jump</span><span class=\"p\">,</span> <span class=\"kp\">nil</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"no\">Edge</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">successor</span><span class=\"p\">,</span> <span class=\"p\">[])])</span>\n          <span class=\"n\">edge</span><span class=\"p\">.</span><span class=\"nf\">block</span> <span class=\"o\">=</span> <span class=\"n\">b</span>\n        <span class=\"k\">elsif</span> <span class=\"n\">num_successors</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span>\n          <span class=\"c1\"># Insert into the beginning of the block</span>\n          <span class=\"n\">successor</span><span class=\"p\">.</span><span class=\"nf\">insert_moves_at_start</span> <span class=\"n\">sequence</span>\n        <span class=\"k\">else</span>\n          <span class=\"c1\"># Insert into the end of the block... before the terminator</span>\n          <span class=\"n\">predecessor</span><span class=\"p\">.</span><span class=\"nf\">insert_moves_at_end</span> <span class=\"n\">sequence</span>\n        <span class=\"k\">end</span>\n    <span class=\"c1\"># ...</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>Adding a new block invalidates the cached <code class=\"language-plaintext highlighter-rouge\">@block_order</code>, so we also need to\nrecompute that.</p>\n\n<blockquote>\n  <p>We could also avoid that by splitting critical edges earlier, before\nnumbering. Then, when we arrive in <code class=\"language-plaintext highlighter-rouge\">resolve_ssa</code>, we can clean up branches to\nempty blocks!</p>\n</blockquote>\n\n<p>(See also <a href=\"https://nickdesaulniers.github.io/blog/2023/01/27/critical-edge-splitting/\">Nick’s post on critical edge\nsplitting</a>,\nwhich also links to Faddegon’s thesis, which I should at least skim.)</p>\n\n<p>And that’s it, folks. We have gone from virtual registers in SSA form to\nphysical locations. Everything’s all hunky-dory. We can just turn these LIR\ninstructions into their very similar looking machine equivalents, right?</p>\n\n<p>Not so fast…</p>\n\n<h2 id=\"calls\">Calls</h2>\n\n<p>You may have noticed that the original linear scan paper does not mention calls\nor other register constraints. I didn’t really think about it until I wanted to\nmake a function call. The authors of later linear scan papers definitely\nnoticed, though; Wimmer2005 writes the following about Poletto1999:</p>\n\n<blockquote>\n  <p>When a spilled interval is used by an instruction requiring the operand in a\nregister, the interval must be temporarily reloaded to the scratch register.\nAdditionally, register constraints for method calls and instructions\nrequiring fixed registers must be handled separately.</p>\n</blockquote>\n\n<p>Fun. We will start off by handling calls and method parameters separately, we\nwill note that it’s not amazing code, and then we will eventually implement the\nlater papers, which handle register constraints more naturally.</p>\n\n<p>We’ll call this new function <code class=\"language-plaintext highlighter-rouge\">handle_caller_saved_regs</code> after register\nallocation but before SSA resolution. We do it after register allocation so we\nknow where each virtual register goes but before resolution so we can still\ninspect the virtual register operands.</p>\n\n<p>Its goal is to do a couple of things:</p>\n\n<ul>\n  <li>Insert special <code class=\"language-plaintext highlighter-rouge\">push</code> and <code class=\"language-plaintext highlighter-rouge\">pop</code> instructions around <code class=\"language-plaintext highlighter-rouge\">call</code> instructions to\npreserve virtual registers that are used on the other side of the <code class=\"language-plaintext highlighter-rouge\">call</code>. We\nonly care about preserving virtual registers that are stored in physical\nregisters, though; no need to preserve anything that already lives on the\nstack.</li>\n  <li>Do a parallel move of the call arguments into the ABI-specified parameter\nregisters. We need to do a parallel move in case any of the arguments happen\nto already be living in parameter registers. (We’re really getting good\nmileage out of this function.)</li>\n  <li>Make sure that the value returned by the call in the ABI-specified return\nregister ends up in in the location allocated to the output of the <code class=\"language-plaintext highlighter-rouge\">call</code>\ninstruction.</li>\n</ul>\n\n<p>We’ll also remove the <code class=\"language-plaintext highlighter-rouge\">call</code> operands since we’re placing them in special\nregisters explicitly now.</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Function</span>\n  <span class=\"k\">def</span> <span class=\"nf\">handle_caller_saved_regs</span> <span class=\"n\">intervals</span><span class=\"p\">,</span> <span class=\"n\">assignments</span><span class=\"p\">,</span> <span class=\"n\">return_reg</span><span class=\"p\">,</span> <span class=\"n\">param_regs</span>\n    <span class=\"vi\">@block_order</span><span class=\"p\">.</span><span class=\"nf\">each</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">block</span><span class=\"o\">|</span>\n      <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">block</span><span class=\"p\">.</span><span class=\"nf\">instructions</span><span class=\"p\">.</span><span class=\"nf\">flat_map</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">insn</span><span class=\"o\">|</span>\n        <span class=\"k\">if</span> <span class=\"n\">insn</span><span class=\"p\">.</span><span class=\"nf\">name</span> <span class=\"o\">==</span> <span class=\"ss\">:call</span>\n          <span class=\"n\">survivors</span> <span class=\"o\">=</span> <span class=\"n\">intervals</span><span class=\"p\">.</span><span class=\"nf\">select</span> <span class=\"p\">{</span> <span class=\"o\">|</span><span class=\"n\">_vreg</span><span class=\"p\">,</span> <span class=\"n\">interval</span><span class=\"o\">|</span>\n            <span class=\"n\">interval</span><span class=\"p\">.</span><span class=\"nf\">survives?</span><span class=\"p\">(</span><span class=\"n\">insn</span><span class=\"p\">.</span><span class=\"nf\">number</span><span class=\"p\">)</span>\n          <span class=\"p\">}.</span><span class=\"nf\">map</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"ss\">:first</span><span class=\"p\">).</span><span class=\"nf\">select</span> <span class=\"p\">{</span> <span class=\"o\">|</span><span class=\"n\">vreg</span><span class=\"o\">|</span>\n            <span class=\"n\">assignments</span><span class=\"p\">[</span><span class=\"n\">intervals</span><span class=\"p\">[</span><span class=\"n\">vreg</span><span class=\"p\">]].</span><span class=\"nf\">is_a?</span><span class=\"p\">(</span><span class=\"no\">PReg</span><span class=\"p\">)</span>\n          <span class=\"p\">}</span>\n          <span class=\"n\">mov_input</span> <span class=\"o\">=</span> <span class=\"n\">insn</span><span class=\"p\">.</span><span class=\"nf\">out</span>\n          <span class=\"n\">insn</span><span class=\"p\">.</span><span class=\"nf\">out</span> <span class=\"o\">=</span> <span class=\"n\">return_reg</span>\n\n          <span class=\"n\">ins</span> <span class=\"o\">=</span> <span class=\"n\">insn</span><span class=\"p\">.</span><span class=\"nf\">ins</span><span class=\"p\">.</span><span class=\"nf\">drop</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n          <span class=\"k\">raise</span> <span class=\"k\">if</span> <span class=\"n\">ins</span><span class=\"p\">.</span><span class=\"nf\">length</span> <span class=\"o\">&gt;</span> <span class=\"n\">param_regs</span><span class=\"p\">.</span><span class=\"nf\">length</span>\n\n          <span class=\"n\">insn</span><span class=\"p\">.</span><span class=\"nf\">ins</span><span class=\"p\">.</span><span class=\"nf\">replace</span><span class=\"p\">(</span><span class=\"n\">insn</span><span class=\"p\">.</span><span class=\"nf\">ins</span><span class=\"p\">.</span><span class=\"nf\">first</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n\n          <span class=\"n\">mapping</span> <span class=\"o\">=</span> <span class=\"n\">ins</span><span class=\"p\">.</span><span class=\"nf\">zip</span><span class=\"p\">(</span><span class=\"n\">param_regs</span><span class=\"p\">).</span><span class=\"nf\">to_h</span>\n          <span class=\"n\">sequence</span> <span class=\"o\">=</span> <span class=\"n\">sequentialize</span><span class=\"p\">(</span><span class=\"n\">mapping</span><span class=\"p\">).</span><span class=\"nf\">map</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"p\">(</span><span class=\"n\">src</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">dst</span><span class=\"p\">)</span><span class=\"o\">|</span>\n            <span class=\"no\">Insn</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"ss\">:mov</span><span class=\"p\">,</span> <span class=\"n\">dst</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">src</span><span class=\"p\">])</span>\n          <span class=\"k\">end</span>\n\n          <span class=\"n\">survivors</span><span class=\"p\">.</span><span class=\"nf\">map</span> <span class=\"p\">{</span> <span class=\"o\">|</span><span class=\"n\">s</span><span class=\"o\">|</span> <span class=\"no\">Insn</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"ss\">:push</span><span class=\"p\">,</span> <span class=\"kp\">nil</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">])</span> <span class=\"p\">}</span> <span class=\"o\">+</span>\n            <span class=\"n\">sequence</span> <span class=\"o\">+</span>\n            <span class=\"p\">[</span><span class=\"n\">insn</span><span class=\"p\">,</span> <span class=\"no\">Insn</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"ss\">:mov</span><span class=\"p\">,</span> <span class=\"n\">mov_input</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">return_reg</span><span class=\"p\">])]</span> <span class=\"o\">+</span>\n            <span class=\"n\">survivors</span><span class=\"p\">.</span><span class=\"nf\">map</span> <span class=\"p\">{</span> <span class=\"o\">|</span><span class=\"n\">s</span><span class=\"o\">|</span> <span class=\"no\">Insn</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"ss\">:pop</span><span class=\"p\">,</span> <span class=\"kp\">nil</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">])</span> <span class=\"p\">}.</span><span class=\"nf\">reverse</span>\n        <span class=\"k\">else</span>\n          <span class=\"n\">insn</span>\n        <span class=\"k\">end</span>\n      <span class=\"k\">end</span>\n      <span class=\"n\">block</span><span class=\"p\">.</span><span class=\"nf\">instructions</span><span class=\"p\">.</span><span class=\"nf\">replace</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>(Unfortunately, this sidesteps handling the less-fun bit of calls in ABIs where\nafter the 6th parameter, they are expected on the stack. It also completely\nignores ABI size constraints.)</p>\n\n<p>Now, you may have noticed that we don’t do anything special for the incoming\nparams of the function we’re compiling! That’s another thing we have to handle.\nThankfully, we can handle it with yet another parallel move (wow!) at the end\nof <code class=\"language-plaintext highlighter-rouge\">resolve_ssa</code>.</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Function</span>\n  <span class=\"k\">def</span> <span class=\"nf\">resolve_ssa</span> <span class=\"n\">intervals</span><span class=\"p\">,</span> <span class=\"n\">assignments</span>\n    <span class=\"c1\"># ...</span>\n    <span class=\"c1\"># We're typically going to have more param regs than block parameters</span>\n    <span class=\"c1\"># When we zip the param regs with block params, we'll end up with param</span>\n    <span class=\"c1\"># regs mapping to nil. We filter those away by selecting for tuples</span>\n    <span class=\"c1\"># that have a truthy second value</span>\n    <span class=\"c1\"># [[x, y], [z, nil]].select(&amp;:last) (reject the second tuple)</span>\n    <span class=\"n\">mapping</span> <span class=\"o\">=</span> <span class=\"n\">param_regs</span><span class=\"p\">.</span><span class=\"nf\">zip</span><span class=\"p\">(</span><span class=\"n\">entry_block</span><span class=\"p\">.</span><span class=\"nf\">parameters</span><span class=\"p\">).</span><span class=\"nf\">select</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"ss\">:last</span><span class=\"p\">).</span><span class=\"nf\">to_h</span>\n    <span class=\"n\">sequence</span> <span class=\"o\">=</span> <span class=\"n\">sequentialize</span><span class=\"p\">(</span><span class=\"n\">mapping</span><span class=\"p\">).</span><span class=\"nf\">map</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"p\">(</span><span class=\"n\">src</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">dst</span><span class=\"p\">)</span><span class=\"o\">|</span>\n      <span class=\"no\">Insn</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"ss\">:mov</span><span class=\"p\">,</span> <span class=\"n\">dst</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">src</span><span class=\"p\">])</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">entry_block</span><span class=\"p\">.</span><span class=\"nf\">insert_moves_at_start</span><span class=\"p\">(</span><span class=\"n\">sequence</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>Again, this is yet another kind of thing where some of the later papers have\nmuch better ergonomics and also much better generated code.</p>\n\n<p>But this is really cool! If you have arrived at this point with me, we have\nsuccessfully made it to 1997 and that is nothing to sneeze at. We have even\nadapted research from 1997 to work with SSA, avoiding several significant\nclasses of bugs along the way.</p>\n\n<!--\n## Instruction selection and instruction splitting\n\n## Interval splitting\n\n## Register hints\n\nWhat is this iterated linear scan thing? Appears in JSC\n\nwhile (true) {\n  linearscan();\n  if (!would_spill) { break; }\n  interval = pick_an_interval_to_spill();\n  spill(interval);\n  remove_interval(interval);\n}\n-->\n\n<h2 id=\"validation-by-abstract-interpretation\">Validation by abstract interpretation</h2>\n\n<p>We have just built an enormously complex machine. Even out the gate, with the\noriginal linear scan, there is a lot of machinery. It’s possible to write tests\nthat spot check sample programs of all shapes and sizes but it’s <em>very</em>\ndifficult to anticipate every possible edge case that will appear in the real\nworld.</p>\n\n<p>Even if the original algorithm you’re using has been proven correct, your\nimplementation may have subtle bugs due to (for example) having slightly\ndifferent invariants or even transcription errors.</p>\n\n<p>We have all these proof tools at our disposal: we can write an abstract\ninterpreter that verifies properties of <em>one</em> graph, but it’s very hard\n(impossible?) to scale that to sets of graphs.</p>\n\n<p>Maybe that’s enough, though. In one of my favorite blog posts, Chris Fallin\n<a href=\"https://cfallin.org/blog/2021/03/15/cranelift-isel-3/\">writes about</a> writing a\nregister allocation verifier based on abstract interpretation. It can verify\none concrete LIR function at a time. It’s fast enough that it can be left on in\ndebug builds. This means that a decent chunk of the time (tests, CI, maybe a\nproduction cluster) we can get a very clear signal that every register\nassignment that passes through the verifier satisfies some invariants.</p>\n\n<p>Furthermore, we are not limited to Real World Code. With the advent of fuzzing,\none can imagine an always-on fuzzer that tries to break the register allocator.\nA verifier can then catch bugs that come from exploring this huge search space.</p>\n\n<p>Some time after finding Chris’s blog post, I also stumbled across <a href=\"https://github.com/v8/v8/blob/cac6de03372c25987c6cbea49b4b39d9da437978/src/compiler/backend/register-allocator-verifier.h\">the very same\nthing in\nV8</a>!</p>\n\n<p>I find this stuff so cool. I’ll also mention Boissinot’s <a href=\"https://github.com/bboissin/thesis_bboissin\">Rust\ncode</a> again because it does\nsomething similar for parallel moves.</p>\n\n<h2 id=\"see-also\">See also</h2>\n\n<p>It’s possible to do linear scan allocation in reverse, at least on traces\nwithout control-flow. See for example <a href=\"https://www.mattkeeter.com/blog/2022-10-04-ssra/\">The Solid-State Register\nAllocator</a>, the <a href=\"https://github.com/LuaJIT/LuaJIT/blob/5e3c45c43bb0e0f1f2917d432e9d2dba12c42a6e/src/lj_asm.c#L198\">LuaJIT\nregister allocator</a>, and <a href=\"https://brrt-to-the-future.blogspot.com/2019/03/reverse-linear-scan-allocation-is.html\">Reverse Linear Scan Allocation is\nprobably a good idea</a>.\nBy doing linear scan this way, it is also possible to avoid computing liveness\nand intervals. I am not sure if this works on programs with control-flow,\nthough.</p>\n\n<h2 id=\"wrapping-up\">Wrapping up</h2>\n\n<p>We built a register allocator that works on SSA. Hopefully next time we will\nadd features such as lifetime holes, interval splitting, and register hints.</p>\n\n<p>The full Ruby code listing is <del>not (yet?) public</del> <a href=\"https://github.com/tenderworks/regalloc\">available under the Apache\n2 license</a>.</p>\n\n<p>UPDATE: See the post on <a href=\"/blog/linear-scan-lifetime-holes/\">lifetime holes</a>.</p>\n\n<h2 id=\"thanks\">Thanks</h2>\n\n<p>Thanks to <a href=\"https://waleedkhan.name/\">Waleed Khan</a> and <a href=\"https://mstdn.ca/@iainireland\">Iain\nIreland</a> for giving feedback on this post.</p>\n<div class=\"footnotes\">\n  <ol>\n    <li id=\"fn:calendaring\">\n      <p>It’s not just about registers, either. In 2016, Facebook\nengineer Dave <a href=\"https://blog.waleedkhan.name/will-i-ever-use-this/\">legendarily used linear-scan register allocation to book\nmeeting rooms</a>. <a class=\"reversefootnote\" href=\"#fnref:calendaring\">&#8617;</a></p>\n    </li>\n    <li id=\"fn:everyone\">\n      <p>Well. As I said on one of the social media sites earlier this\nyear, “All AOT compilers are alike; each JIT compiler is fucked up in its\nown way.”</p>\n\n      <p>JavaScript:</p>\n\n      <!-- * V8's Maglev uses -->\n      <ul>\n        <li>V8’s TurboFan uses <a href=\"https://github.com/v8/v8/blob/12fa27f2f4d999320c524776ed29810c8694bafc/src/compiler/backend/register-allocator.h#L1545\">linear scan</a></li>\n        <li>SpiderMonkey uses a <a href=\"https://searchfox.org/mozilla-central/rev/c85c168374483a3c37aab49d7f587ea74a516492/js/src/jit/BacktrackingAllocator.h#28-31\">backtracking allocator</a>\nbased on <a href=\"https://blog.llvm.org/2011/09/greedy-register-allocation-in-llvm-30.html\">LLVM’s</a></li>\n        <li>JavaScriptCore uses <a href=\"https://github.com/WebKit/WebKit/blob/f5a9393bdeff7c89685de21aa9f2df392139cc07/Source/JavaScriptCore/b3/air/AirAllocateRegistersAndStackByLinearScan.h#L37\">linear scan “for\noptLevel&lt;2”</a>\nand <a href=\"https://github.com/WebKit/WebKit/blob/f5a9393bdeff7c89685de21aa9f2df392139cc07/Source/JavaScriptCore/b3/air/AirAllocateRegistersByGraphColoring.h\">graph coloring otherwise</a>\n          <ul>\n            <li>There’s also a “cssjit” with its own register allocator…</li>\n          </ul>\n        </li>\n      </ul>\n\n      <p>Java:</p>\n\n      <ul>\n        <li>HotSpot C1 uses (naturally) <a href=\"https://github.com/openjdk/jdk/blob/87d734012e3130501bfd37b23cee7f5e0a3a476f/src/hotspot/share/c1/c1_LinearScan.hpp\">Wimmer2010 linear scan</a></li>\n        <li>HotSpot C2 uses <a href=\"https://github.com/openjdk/jdk/blob/87d734012e3130501bfd37b23cee7f5e0a3a476f/src/hotspot/share/opto/regalloc.hpp\">Chaitin-Briggs-Click graph coloring</a></li>\n        <li>GraalVM uses <a href=\"https://github.com/oracle/graal/blob/e482f988939235ce94ee4a756c6bcc1d3df2bab2/compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/lir/alloc/lsra/LinearScan.java\">linear scan</a></li>\n        <li>\n          <!-- Dalvik, ART -->\n        </li>\n      </ul>\n\n      <p>Python:</p>\n\n      <!-- * PyPy uses -->\n      <ul>\n        <li>Cinder uses <a href=\"https://github.com/facebookincubator/cinderx/blob/5cf14ad8a68b6f04c1ca1cb99947da7d8d09c28b/cinderx/Jit/lir/regalloc.h\">Wimmer2010 linear scan</a></li>\n        <li>S6 uses a <a href=\"https://github.com/google-deepmind/s6/blob/69cac9c981fbd3217ed117c3898382cfe094efc0/src/code_generation/trace_register_allocator.h\">trace register allocator</a>\n          <ul>\n            <li>This is a different thing than a tracing JIT; see <a href=\"/assets/img/trace-ra.pdf\">Josef Eisl’s thesis</a> (PDF, 2018)</li>\n          </ul>\n        </li>\n      </ul>\n\n      <p>Ruby:</p>\n\n      <ul>\n        <li>YJIT uses <a href=\"https://github.com/ruby/ruby/blob/231407c251d82573f578caf569a934c0ebb344e5/yjit/src/backend/ir.rs#L1388\">linear scan</a></li>\n        <li>ZJIT uses more or less the same backend, so also linear scan</li>\n      </ul>\n\n      <p>PHP:</p>\n\n      <ul>\n        <li>PHP uses <a href=\"https://github.com/php/php-src/blob/77dace78c324ef731e60fa98b4b8008cd7df1657/ext/opcache/jit/ir/ir_ra.c#L3479\">linear scan</a></li>\n        <li>HHVM uses <a href=\"https://github.com/facebook/hhvm/blob/e7bca518648e16bdb7c08e91d02f8c158d8e6c6f/hphp/runtime/vm/jit/vasm-xls.cpp#L1448\">extended linear scan</a></li>\n      </ul>\n\n      <p>Lua:</p>\n\n      <ul>\n        <li>LuaJIT uses <a href=\"https://github.com/LuaJIT/LuaJIT/blob/5e3c45c43bb0e0f1f2917d432e9d2dba12c42a6e/src/lj_asm.c#L198\">reverse linear scan</a></li>\n      </ul>\n      <p><a class=\"reversefootnote\" href=\"#fnref:everyone\">&#8617;</a></p>\n    </li>\n    <li id=\"fn:allocate-on-ssa\">\n      <p><a href=\"/assets/img/linear-scan-ra-context-ssa.pdf\">Linear Scan Register Allocation in the Context of SSA Form\nand Register Constraints</a> (PDF, 2002) by Mössenböck and\nPfeiffer notes:</p>\n\n      <blockquote>\n        <p>Our allocator relies on static single assignment form, which simplifies\ndata flow analysis and tends to produce short live intervals.</p>\n      </blockquote>\n\n      <p><a href=\"/assets/img/ra-programs-ssa.pdf\">Register allocation for programs in SSA-form</a> (PDF, 2006)\nby Hack, Grund, and Goos notes that interference graphs for SSA programs\nare chordal and can be optimally colored in quadratic time.</p>\n\n      <p><a href=\"/assets/img/ssa-elimination-after-ra.pdf\">SSA Elimination after Register Allocation</a> (PDF, 2008)\nby Pereira and Palsberg notes:</p>\n\n      <blockquote>\n        <p>One of the main advantages of SSA based register allocation is the\nseparation of phases between spilling and register assignment.</p>\n      </blockquote>\n\n      <p>Cliff Click (private communication, 2025) notes:</p>\n\n      <blockquote>\n        <p>It’s easier. Got it already, why lose it […] spilling always uses\nuse/def and def/use edges.</p>\n      </blockquote>\n      <p><a class=\"reversefootnote\" href=\"#fnref:allocate-on-ssa\">&#8617;</a></p>\n    </li>\n    <li id=\"fn:rsms\">\n      <p>This is inspired by <a href=\"https://rsms.me/\">Rasmus Andersson</a>’s graph\ncoloring <a href=\"https://rsms.me/projects/chaitin/\">visualization</a> that I saw some\nyears ago. <a class=\"reversefootnote\" href=\"#fnref:rsms\">&#8617;</a></p>\n    </li>\n    <li id=\"fn:thesis-correction\">\n      <p>The example in the thesis is to sequentialize the\nfollowing parallel copy:</p>\n\n      <ul>\n        <li>a → b</li>\n        <li>b → c</li>\n        <li>c → a</li>\n        <li>c → d</li>\n      </ul>\n\n      <p>The solution in the thesis is:</p>\n\n      <ol>\n        <li>c → d (c now lives in d)</li>\n        <li>a → c (a now lives in c)</li>\n        <li>b → a (b now lives in a)</li>\n        <li>d → b (why are we copying c to b?)</li>\n      </ol>\n\n      <p>but we think this is incorrect. Solving manually, Aaron and I got:</p>\n\n      <ol>\n        <li>c → d (because d is not read from anywhere)</li>\n        <li>b → c (because c is “freed up”; now in d)</li>\n        <li>a → b (because b is “freed up”; now in c)</li>\n        <li>d → a (because c is now in d, so d → a is equivalent to old_c → a)</li>\n      </ol>\n\n      <p>which is what the code gives us, too. <a class=\"reversefootnote\" href=\"#fnref:thesis-correction\">&#8617;</a></p>\n    </li>\n  </ol>\n</div>",
  "id": "https://bernsteinbear.com/blog/linear-scan/"
}