{
  "title": "Go Protobuf: The new Opaque API",
  "link": "https://michael.stapelberg.ch/posts/2024-12-21-go-protobuf-opaque/",
  "published": "2024-12-21T11:06:00+01:00",
  "summary": "<aside class=\"admonition note\">\n  <div class=\"note-container\">\n    <div class=\"note-icon\" style=\"width: 20px; height: 20px;\">\n      <svg height=\"100%\" id=\"exclamation-icon\" version=\"1.1\" viewBox=\"0 0 24 24\" width=\"100%\" xml:space=\"preserve\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <path d=\"M0,0L24,0L24,24L0,24L0,0Z\">\n    <g transform=\"matrix(1.2,0,0,1.2,-2.4,-2.4)\">\n        <path d=\"M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2ZM13,17L11,17L11,15L13,15L13,17ZM13,13L11,13L11,7L13,7L13,13Z\">\n    </g>\n</svg>\n\n    </div>\n    <div class=\"admonition-content\">I originally published this post in <a href=\"https://go.dev/blog\">the Go blog</a>, but am\npublishing this copy of it in my own blog as well for readers who donâ€™t follow\nthe Go blog.</div>\n  </div>\n</aside>\n\n<p>[<a href=\"https://en.wikipedia.org/wiki/Protocol_Buffers\">Protocol Buffers (Protobuf)</a>\nis Google&rsquo;s language-neutral data interchange format. See\n<a href=\"https://protobuf.dev/\">protobuf.dev</a>.]</p>\n<p>Back in March 2020, we released <a href=\"https://go.dev/blog/protobuf-apiv2\">a major overhaul of the Go Protobuf\nAPI</a>. The <code>google.golang.org/protobuf</code>\npackage introduced first-class <a href=\"https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect\">support for\nreflection</a>,\na <a href=\"https://pkg.go.dev/google.golang.org/protobuf/types/dynamicpb\"><code>dynamicpb</code></a>\nimplementation and the\n<a href=\"https://pkg.go.dev/google.golang.org/protobuf/testing/protocmp\"><code>protocmp</code></a>\npackage for easier testing.</p>\n<p>That release introduced a new protobuf module with a new API. Today, we are\nreleasing an additional API for generated code, meaning the Go code in the\n<code>.pb.go</code> files created by the protocol compiler (<code>protoc</code>). This blog post\nexplains our motivation for creating a new API and shows you how to use it in\nyour projects.</p>\n<p>To be clear: We are not removing anything. We will continue to support the\nexisting API for generated code, just like we still support the older protobuf\nmodule (by wrapping the <code>google.golang.org/protobuf</code> implementation). Go is\n<a href=\"https://go.dev/blog/compat\">committed to backwards compatibility</a> and this\napplies to Go Protobuf, too!</p>\n<h2 id=\"background\">Background: the (existing) Open Struct API</h2>\n<p>We now call the existing API the Open Struct API, because generated struct types\nare open to direct access. In the next section, we will see how it differs from\nthe new Opaque API.</p>\n<p>To work with protocol buffers, you first create a <code>.proto</code> definition file like\nthis one:</p>\n<pre><code>edition = &quot;2023&quot;;  // successor to proto2 and proto3\n\npackage log;\n\nmessage LogEntry {\n  string backend_server = 1;\n  uint32 request_size = 2;\n  string ip_address = 3;\n}\n</code></pre>\n<p>Then, you <a href=\"https://protobuf.dev/getting-started/gotutorial/\">run the protocol compiler\n(<code>protoc</code>)</a> to generate code\nlike the following (in a <code>.pb.go</code> file):</p>\n<pre><code>package logpb\n\ntype LogEntry struct {\n  BackendServer *string\n  RequestSize   *uint32\n  IPAddress     *string\n  // â€¦internal fields elidedâ€¦\n}\n\nfunc (l *LogEntry) GetBackendServer() string { â€¦ }\nfunc (l *LogEntry) GetRequestSize() uint32   { â€¦ }\nfunc (l *LogEntry) GetIPAddress() string     { â€¦ }\n</code></pre>\n<p>Now you can import the generated <code>logpb</code> package from your Go code and call\nfunctions like\n<a href=\"https://pkg.go.dev/google.golang.org/protobuf/proto#Marshal\"><code>proto.Marshal</code></a>\nto encode <code>logpb.LogEntry</code> messages into protobuf wire format.</p>\n<p>You can find more details in the <a href=\"https://protobuf.dev/reference/go/go-generated/\">Generated Code API\ndocumentation</a>.</p>\n<h3 id=\"presence\">(Existing) Open Struct API: Field Presence</h3>\n<p>An important aspect of this generated code is how <em>field presence</em> (whether a\nfield is set or not) is modeled. For instance, the above example models presence\nusing pointers, so you could set the <code>BackendServer</code> field to:</p>\n<ol>\n<li><code>proto.String(&quot;zrh01.prod&quot;)</code>: the field is set and contains &ldquo;zrh01.prod&rdquo;</li>\n<li><code>proto.String(&quot;&quot;)</code>: the field is set (non-<code>nil</code> pointer) but contains an\nempty value</li>\n<li><code>nil</code> pointer: the field is not set</li>\n</ol>\n<p>If you are used to generated code not having pointers, you are probably using\n<code>.proto</code> files that start with <code>syntax = &quot;proto3&quot;</code>. The field presence behavior\nchanged over the years:</p>\n<ul>\n<li><code>syntax = &quot;proto2&quot;</code> uses <em>explicit presence</em> by default</li>\n<li><code>syntax = &quot;proto3&quot;</code> used <em>implicit presence</em> by default (where cases 2 and 3\ncannot be distinguished and are both represented by an empty string), but was\nlater extended to allow <a href=\"https://protobuf.dev/programming-guides/proto3/#field-labels\">opting into explicit presence with the <code>optional</code>\nkeyword</a></li>\n<li><code>edition = &quot;2023&quot;</code>, the <a href=\"https://protobuf.dev/editions/overview/\">successor to both proto2 and\nproto3</a>, uses <a href=\"https://protobuf.dev/programming-guides/field_presence/\"><em>explicit\npresence</em></a> by default</li>\n</ul>\n<h2 id=\"opaqueapi\">The new Opaque API</h2>\n<p>We created the new <em>Opaque API</em> to uncouple the <a href=\"https://protobuf.dev/reference/go/go-generated/\">Generated Code\nAPI</a> from the underlying\nin-memory representation. The (existing) Open Struct API has no such separation:\nit allows programs direct access to the protobuf message memory. For example,\none could use the <code>flag</code> package to parse command-line flag values into protobuf\nmessage fields:</p>\n<pre><code>var req logpb.LogEntry\nflag.StringVar(&amp;req.BackendServer, &quot;backend&quot;, os.Getenv(&quot;HOST&quot;), &quot;â€¦&quot;)\nflag.Parse() // fills the BackendServer field from -backend flag\n</code></pre>\n<p>The problem with such a tight coupling is that we can never change how we lay\nout protobuf messages in memory. Lifting this restriction enables many\nimplementation improvements, which we&rsquo;ll see below.</p>\n<p>What changes with the new Opaque API? Here is how the generated code from the\nabove example would change:</p>\n<pre><code>package logpb\n\ntype LogEntry struct {\n  xxx_hidden_BackendServer *string // no longer exported\n  xxx_hidden_RequestSize   uint32  // no longer exported\n  xxx_hidden_IPAddress     *string // no longer exported\n  // â€¦internal fields elidedâ€¦\n}\n\nfunc (l *LogEntry) GetBackendServer() string { â€¦ }\nfunc (l *LogEntry) HasBackendServer() bool   { â€¦ }\nfunc (l *LogEntry) SetBackendServer(string)  { â€¦ }\nfunc (l *LogEntry) ClearBackendServer()      { â€¦ }\n// â€¦\n</code></pre>\n<p>With the Opaque API, the struct fields are hidden and can no longer be\ndirectly accessed. Instead, the new accessor methods allow for getting, setting,\nor clearing a field.</p>\n<h3 id=\"lessmemory\">Opaque structs use less memory</h3>\n<p>One change we made to the memory layout is to model field presence for\nelementary fields more efficiently:</p>\n<ul>\n<li>The (existing) Open Struct API uses pointers, which adds a 64-bit word to the\nspace cost of the field.</li>\n<li>The Opaque API uses <a href=\"https://en.wikipedia.org/wiki/Bit_field\">bit\nfields</a>, which require one bit per\nfield (ignoring padding overhead).</li>\n</ul>\n<p>Using fewer variables and pointers also lowers load on the allocator and on the\ngarbage collector.</p>\n<p>The performance improvement depends heavily on the shapes of your protocol\nmessages: The change only affects elementary fields like integers, bools, enums,\nand floats, but not strings, repeated fields, or submessages (because it is\n<a href=\"https://protobuf.dev/reference/go/opaque-faq/#memorylayout\">less\nprofitable</a>\nfor those types).</p>\n<p>Our benchmark results show that messages with few elementary fields exhibit\nperformance that is as good as before, whereas messages with more elementary\nfields are decoded with significantly fewer allocations:</p>\n<pre><code>             â”‚ Open Struct API â”‚             Opaque API             â”‚\n             â”‚    allocs/op    â”‚  allocs/op   vs base               â”‚\nProd#1          360.3k Â± 0%       360.3k Â± 0%  +0.00% (p=0.002 n=6)\nSearch#1       1413.7k Â± 0%       762.3k Â± 0%  -46.08% (p=0.002 n=6)\nSearch#2        314.8k Â± 0%       132.4k Â± 0%  -57.95% (p=0.002 n=6)\n</code></pre>\n<p>Reducing allocations also makes decoding protobuf messages more efficient:</p>\n<pre><code>             â”‚ Open Struct API â”‚             Opaque API            â”‚\n             â”‚   user-sec/op   â”‚ user-sec/op  vs base              â”‚\nProd#1         55.55m Â± 6%        55.28m Â± 4%  ~ (p=0.180 n=6)\nSearch#1       324.3m Â± 22%       292.0m Â± 6%  -9.97% (p=0.015 n=6)\nSearch#2       67.53m Â± 10%       45.04m Â± 8%  -33.29% (p=0.002 n=6)\n</code></pre>\n<p>(All measurements done on an AMD Castle Peak Zen 2. Results on ARM and Intel\nCPUs are similar.)</p>\n<p>Note: proto3 with implicit presence similarly does not use pointers, so you will\nnot see a performance improvement if you are coming from proto3. If you were\nusing implicit presence for performance reasons, forgoing the convenience of\nbeing able to distinguish empty fields from unset ones, then the Opaque API now\nmakes it possible to use explicit presence without a performance penalty.</p>\n<h3 id=\"lazydecoding\">Motivation: Lazy Decoding</h3>\n<p>Lazy decoding is a performance optimization where the contents of a submessage\nare decoded when first accessed instead of during\n<a href=\"https://pkg.go.dev/google.golang.org/protobuf/proto#Unmarshal\"><code>proto.Unmarshal</code></a>. Lazy\ndecoding can improve performance by avoiding unnecessarily decoding fields which\nare never accessed.</p>\n<p>Lazy decoding can&rsquo;t be supported safely by the (existing) Open Struct API. While\nthe Open Struct API provides getters, leaving the (un-decoded) struct fields\nexposed would be extremely error-prone. To ensure that the decoding logic runs\nimmediately before the field is first accessed, we must make the field private\nand mediate all accesses to it through getter and setter functions.</p>\n<p>This approach made it possible to implement lazy decoding with the Opaque\nAPI. Of course, not every workload will benefit from this optimization, but for\nthose that do benefit, the results can be spectacular: We have seen logs\nanalysis pipelines that discard messages based on a top-level message condition\n(e.g. whether <code>backend_server</code> is one of the machines running a new Linux kernel\nversion) and can skip decoding deeply nested subtrees of messages.</p>\n<p>As an example, here are the results of the micro-benchmark we included,\ndemonstrating how lazy decoding saves over 50% of the work and over 87% of\nallocations!</p>\n<pre><code>                  â”‚   nolazy    â”‚                lazy                â”‚\n                  â”‚   sec/op    â”‚   sec/op     vs base               â”‚\nUnmarshal/lazy-24   6.742Âµ Â± 0%   2.816Âµ Â± 0%  -58.23% (p=0.002 n=6)\n\n                  â”‚    nolazy    â”‚                lazy                 â”‚\n                  â”‚     B/op     â”‚     B/op      vs base               â”‚\nUnmarshal/lazy-24   3.666Ki Â± 0%   1.814Ki Â± 0%  -50.51% (p=0.002 n=6)\n\n                  â”‚   nolazy    â”‚               lazy                â”‚\n                  â”‚  allocs/op  â”‚ allocs/op   vs base               â”‚\nUnmarshal/lazy-24   64.000 Â± 0%   8.000 Â± 0%  -87.50% (p=0.002 n=6)\n</code></pre>\n<h3 id=\"pointercomparison\">Motivation: reduce pointer comparison mistakes</h3>\n<p>Modeling field presence with pointers invites pointer-related bugs.</p>\n<p>Consider an enum, declared within the <code>LogEntry</code> message:</p>\n<pre><code>message LogEntry {\n  enum DeviceType {\n    DESKTOP = 0;\n    MOBILE = 1;\n    VR = 2;\n  };\n  DeviceType device_type = 1;\n}\n</code></pre>\n<p>A simple mistake is to compare the <code>device_type</code> enum field like so:</p>\n<pre><code>if cv.DeviceType == logpb.LogEntry_DESKTOP.Enum() { // incorrect!\n</code></pre>\n<p>Did you spot the bug? The condition compares the memory address instead of the\nvalue. Because the <code>Enum()</code> accessor allocates a new variable on each call, the\ncondition can never be true. The check should have read:</p>\n<pre><code>if cv.GetDeviceType() == logpb.LogEntry_DESKTOP {\n</code></pre>\n<p>The new Opaque API prevents this mistake: Because fields are hidden, all access\nmust go through the getter.</p>\n<h3 id=\"accidentalsharing\">Motivation: reduce accidental sharing mistakes</h3>\n<p>Let&rsquo;s consider a slightly more involved pointer-related bug. Assume you are\ntrying to stabilize an RPC service that fails under high load. The following\npart of the request middleware looks correct, but still the entire service goes\ndown whenever just one customer sends a high volume of requests:</p>\n<pre><code>logEntry.IPAddress = req.IPAddress\nlogEntry.BackendServer = proto.String(hostname)\n// The redactIP() function redacts IPAddress to 127.0.0.1,\n// unexpectedly not just in logEntry *but also* in req!\ngo auditlog(redactIP(logEntry))\nif quotaExceeded(req) {\n\t// BUG: All requests end up here, regardless of their source.\n\treturn fmt.Errorf(&quot;server overloaded&quot;)\n}\n</code></pre>\n<p>Did you spot the bug? The first line accidentally copied the pointer (thereby\nsharing the pointed-to variable between the <code>logEntry</code> and <code>req</code> messages)\ninstead of its value. It should have read:</p>\n<pre><code>logEntry.IPAddress = proto.String(req.GetIPAddress())\n</code></pre>\n<p>The new Opaque API prevents this problem as the setter takes a value\n(<code>string</code>) instead of a pointer:</p>\n<pre><code>logEntry.SetIPAddress(req.GetIPAddress())\n</code></pre>\n<h3 id=\"reflection\">Motivation: Fix Sharp Edges: reflection</h3>\n<p>To write code that works not only with a specific message type\n(e.g. <code>logpb.LogEntry</code>), but with any message type, one needs some kind of\nreflection. The previous example used a function to redact IP addresses. To work\nwith any type of message, it could have been defined as <code>func redactIP(proto.Message) proto.Message { â€¦ }</code>.</p>\n<p>Many years ago, your only option to implement a function like <code>redactIP</code> was to\nreach for <a href=\"https://go.dev/blog/laws-of-reflection\">Go&rsquo;s <code>reflect</code> package</a>,\nwhich resulted in very tight coupling: you had only the generator output and had\nto reverse-engineer what the input protobuf message definition might have looked\nlike. The <a href=\"https://go.dev/blog/protobuf-apiv2\"><code>google.golang.org/protobuf</code> module\nrelease</a> (from March 2020) introduced\n<a href=\"https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect\">Protobuf\nreflection</a>,\nwhich should always be preferred: Go&rsquo;s <code>reflect</code> package traverses the data\nstructure&rsquo;s representation, which should be an implementation detail. Protobuf\nreflection traverses the logical tree of protocol messages without regard to its\nrepresentation.</p>\n<p>Unfortunately, merely <em>providing</em> protobuf reflection is not sufficient and\nstill leaves some sharp edges exposed: In some cases, users might accidentally\nuse Go reflection instead of protobuf reflection.</p>\n<p>For example, encoding a protobuf message with the <code>encoding/json</code> package (which\nuses Go reflection) was technically possible, but the result is not <a href=\"https://protobuf.dev/programming-guides/proto3/#json\">canonical\nProtobuf JSON\nencoding</a>. Use the\n<a href=\"https://pkg.go.dev/google.golang.org/protobuf/encoding/protojson\"><code>protojson</code></a>\npackage instead.</p>\n<p>The new Opaque API prevents this problem because the message struct fields are\nhidden: accidental usage of Go reflection will see an empty message. This is\nclear enough to steer developers towards protobuf reflection.</p>\n<h3 id=\"idealmemory\">Motivation: Making the ideal memory layout possible</h3>\n<p>The benchmark results from the <a href=\"#lessmemory\">More Efficient Memory\nRepresentation</a> section have already shown that protobuf\nperformance heavily depends on the specific usage: How are the messages defined?\nWhich fields are set?</p>\n<p>To keep Go Protobuf as fast as possible for <em>everyone</em>, we cannot implement\noptimizations that help only one program, but hurt the performance of other\nprograms.</p>\n<p>The Go compiler used to be in a similar situation, up until <a href=\"https://go.dev/blog/go1.20\">Go 1.20 introduced\nProfile-Guided Optimization (PGO)</a>. By recording the\nproduction behavior (through <a href=\"https://go.dev/blog/pprof\">profiling</a>) and feeding\nthat profile back to the compiler, we allow the compiler to make better\ntrade-offs <em>for a specific program or workload</em>.</p>\n<p>We think using profiles to optimize for specific workloads is a promising\napproach for further Go Protobuf optimizations. The Opaque API makes those\npossible: Program code uses accessors and does not need to be updated when the\nmemory representation changes, so we could, for example, move rarely set fields\ninto an overflow struct.</p>\n<h2 id=\"migration\">Migration</h2>\n<p>You can migrate on your own schedule, or even not at allâ€”the (existing) Open\nStruct API will not be removed. But, if youâ€™re not on the new Opaque API, you\nwonâ€™t benefit from its improved performance, or future optimizations that target\nit.</p>\n<p>We recommend you select the Opaque API for new development. Protobuf Edition\n2024 (see <a href=\"https://protobuf.dev/editions/overview/\">Protobuf Editions Overview</a>\nif you are not yet familiar) will make the Opaque API the default.</p>\n<h3 id=\"hybridapi\">The Hybrid API</h3>\n<p>Aside from the Open Struct API and Opaque API, there is also the Hybrid API,\nwhich keeps existing code working by keeping struct fields exported, but also\nenabling migration to the Opaque API by adding the new accessor methods.</p>\n<p>With the Hybrid API, the protobuf compiler will generate code on two API levels:\nthe <code>.pb.go</code> is on the Hybrid API, whereas the <code>_protoopaque.pb.go</code> version is\non the Opaque API and can be selected by building with the <code>protoopaque</code> build\ntag.</p>\n<h3 id=\"rewriting\">Rewriting Code to the Opaque API</h3>\n<p>See the <a href=\"https://protobuf.dev/reference/go/opaque-migration/\">migration\nguide</a>\nfor detailed instructions. The high-level steps are:</p>\n<ol>\n<li>Enable the Hybrid API.</li>\n<li>Update existing code using the <code>open2opaque</code> migration tool.</li>\n<li>Switch to the Opaque API.</li>\n</ol>\n<h3 id=\"publishing\">Advice for published generated code: Use Hybrid API</h3>\n<p>Small usages of protobuf can live entirely within the same repository, but\nusually, <code>.proto</code> files are shared between different projects that are owned by\ndifferent teams. An obvious example is when different companies are involved: To\ncall Google APIs (with protobuf), use the <a href=\"https://github.com/googleapis/google-cloud-go\">Google Cloud Client Libraries for\nGo</a> from your project. Switching\nthe Cloud Client Libraries to the Opaque API is not an option, as that would be\na breaking API change, but switching to the Hybrid API is safe.</p>\n<p>Our advice for such packages that publish generated code (<code>.pb.go</code> files) is to\nswitch to the Hybrid API please! Publish both the <code>.pb.go</code> and the\n<code>_protoopaque.pb.go</code> files, please. The <code>protoopaque</code> version allows your\nconsumers to migrate on their own schedule.</p>\n<h3 id=\"enablelazy\">Enabling Lazy Decoding</h3>\n<p>Lazy decoding is available (but not enabled) once you migrate to the Opaque API!\nðŸŽ‰</p>\n<p>To enable: in your <code>.proto</code> file, annotate your message-typed fields with the\n<code>[lazy = true]</code> annotation.</p>\n<p>To opt out of lazy decoding (despite <code>.proto</code> annotations), the <a href=\"https://pkg.go.dev/google.golang.org/protobuf/runtime/protolazy\"><code>protolazy</code>\npackage\ndocumentation</a>\ndescribes the available opt-outs, which affect either an individual Unmarshal\noperation or the entire program.</p>\n<h2 id=\"nextsteps\">Next Steps</h2>\n<p>By using the open2opaque tool in an automated fashion over the last few years,\nwe have converted the vast majority of Googleâ€™s <code>.proto</code> files and Go code to\nthe Opaque API. We continuously improved the Opaque API implementation as we\nmoved more and more production workloads to it.</p>\n<p>Therefore, we expect you should not encounter problems when trying the Opaque\nAPI. In case you do encounter any issues after all, please <a href=\"https://github.com/golang/protobuf/issues/\">let us know on the\nGo Protobuf issue tracker</a>.</p>\n<p>Reference documentation for Go Protobuf can be found on <a href=\"https://protobuf.dev/reference/go/\">protobuf.dev â†’ Go\nReference</a>.</p>",
  "id": "https://michael.stapelberg.ch/posts/2024-12-21-go-protobuf-opaque/"
}