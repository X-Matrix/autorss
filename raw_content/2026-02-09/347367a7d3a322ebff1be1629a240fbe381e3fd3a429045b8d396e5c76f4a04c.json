{
  "title": "Random notes on improving the Redis LRU algorithm",
  "link": "http://antirez.com/news/109",
  "published": "Fri, 29 Jul 2016 10:04:12 +0200",
  "summary": "Redis is often used for caching, in a setup where a fixed maximum memory to use is specified. When new data arrives, we need to make space by removing old data. The efficiency of Redis as a cache is related to how good decisions it makes about what data to evict: deleting data that is going to be needed soon is a poor strategy, while deleting data that is unlikely to be requested again is a good one.\n<br />\n<br />In other terms every cache has an hits/misses ratio, which is, in qualitative terms, just the percentage of read queries that the cache is able to serve. Accesses to the keys of a cache are not distributed evenly among the data set in most workloads. Often a small percentage of keys get a very large percentage of all the accesses. Moreover the access pattern often changes over time, which means that as time passes certain keys that were very requested may no longer be accessed often, and conversely, keys that once were not popular may turn into the most accessed keys.\n<br />\n<br />So in general what a cache should try to do is to retain the keys that have the highest probability of being accessed in the future. From the point of view of an eviction policy (the policy used to make space to allow new data to enter) this translates into the contrary: the key with the least probability of being accessed in the future should be removed from the data set. There is only one problem: Redis and other caches are not able to predict the future.\n<br />\n<br />The LRU algorithm\n<br />===\n<br />\n<br />While caches can’t predict the future, they can reason in the following way: keys that are likely to be requested again are keys that were recently requested often. Since usually access patterns don’t change very suddenly, this is an effective strategy. However the notion of “recently requested often” is more insidious that it may look at a first glance (we’ll return shortly on this). So this concept is simplified into an algorithm that is called LRU, which instead just tracks the *last time* a key was requested. Keys that are accessed with an higher frequency have a greater probability of being idle (not accessed) for a shorter time compared to keys that are rarely accessed.\n<br />\n<br />For instance this is a representation of four different keys accesses over time. Each “~” character is one second, while the “|” line at the end is the current instant.\n<br />\n<br />~~~~~A~~~~~A~~~~~A~~~~A~~~~~A~~~~~A~~|\n<br />~~B~~B~~B~~B~~B~~B~~B~~B~~B~~B~~B~~B~|\n<br />~~~~~~~~~~C~~~~~~~~~C~~~~~~~~~C~~~~~~|\n<br />~~~~~D~~~~~~~~~~D~~~~~~~~~D~~~~~~~~~D|\n<br />\n<br />Key A is accessed one time every 5 seconds, key B once every 2 seconds\n<br />and key C and D are both accessed every 10 seconds.\n<br />\n<br />Given the high frequency of accesses of key B, it has among the lowest idle\n<br />times, which means its last access time is the second most recent among all the\n<br />four keys.\n<br />\n<br />Similarly A and C idle time of 2 and 6 seconds well reflect the access\n<br />frequency of both those keys. However as you can see this trick does not\n<br />always work: key D is accessed every 10 seconds, however it has the most\n<br />recent access time of all the keys.\n<br />\n<br />Still, in the long run, this algorithm works well enough. Usually keys\n<br />with a greater access frequency have a smaller idle time. The LRU\n<br />algorithm evicts the Least Recently Used key, which means the one with\n<br />the greatest idle time. It is simple to implement because all we need to\n<br />do is to track the last time a given key was accessed, or sometimes\n<br />this is not even needed: we may just have all the objects we want to\n<br />evict linked in a linked list. When an object is accessed we move it\n<br />to the top of the list. When we want to evict objects, we evict from\n<br />the tail of the list. Tada! Win.\n<br />\n<br />LRU in Redis: the genesis\n<br />===\n<br />\n<br />Initially Redis had no support for LRU eviction. It was added later, when memory efficiency was a big concern. By modifying a bit the Redis Object structure I was able to make 24 bits of space. There was no room for linking the objects in a linked list (fat pointers!), moreover the implementation needed to be efficient, since the server performance should not drop too much because of the selection of the key to evict.\n<br />\n<br />The 24 bits in the object are enough to store the least significant\n<br />bits of the current unix time in seconds. This representation, called\n<br />“LRU clock” inside the source code of Redis, takes 194 days to overflow. Keys metadata are updated much often, so this was good enough.\n<br />\n<br />However there was another more complex problem to solve, how to select\n<br />the key with the greatest idle time in order to evict it? The Redis\n<br />key space is represented via a flat hash table. To add another data\n<br />structure to take this metadata was not an option, however since\n<br />LRU is itself an approximation of what we want to achieve, what\n<br />about approximating LRU itself?\n<br />\n<br />The initial Redis algorithm was as simple as that: when there is to evict\n<br />a key, select 3 random keys, and evict the one with the highest\n<br />idle time. Basically we do random sampling over the key space and evict\n<br />the key that happens to be the better. Later this “3 random keys”\n<br />was turned into a configurable “N random keys” and the algorithm\n<br />speed was improved so that the default was raised to 5 keys sampling\n<br />without losing performances. Considering how naive it was, it worked\n<br />well, very well actually. If you think at it, you always never do\n<br />the best decision with this algorithm, but is very unlikely to do\n<br />a very bad decision too. If there is a subset of very frequently accessed\n<br />keys in the data set, out of 5 keys it is hard to be so unlucky to\n<br />only sample keys with a very short idle time.\n<br />\n<br />However if you think at this algorithm *across* its executions, you\n<br />can see how we are trashing a lot of interesting data. Maybe when\n<br />sampling the N keys, we encounter a lot of good candidates, but\n<br />we then just evict the best, and start from scratch again the next\n<br />cycle.\n<br />\n<br />First rule of Fight Club is: observe your algorithms with naked eyes\n<br />===\n<br />\n<br />At some point I was in the middle of working at the upcoming Redis\n<br />3.0 release. Redis 2.8 was actively used as an LRU cache in multiple\n<br />environments, and people didn’t complained too much about the\n<br />precision of the eviction in Redis, but it was clear that it could\n<br />be improved even without using a noticeable amount of additional CPU\n<br />time, and not a single bit of additional space.\n<br />\n<br />However in order to improve something, you have to look at it. There\n<br />are different ways to look at LRU algorithms. You can write, for example,\n<br />tools that simulate different workloads, and check the hit/miss ratio\n<br />at the end. This is what I did, however the hit/miss ratio depends\n<br />a lot on the access pattern, so additionally to this information I\n<br />wrote an utility that actually displayed the algorithm quality in a\n<br />visual way.\n<br />\n<br />The program was very simple: it added a given number of keys, then\n<br />accessed the keys sequentially so that each had a decreasing\n<br />idle time. Finally 50% more keys were added (the green ones in the\n<br />picture), so that half of the old keys needed to be evicted.\n<br />\n<br />In a perfect LRU implementation no key from the new added keys are evicted, and the initial 50% of the old dataset is evicted.\n<br />\n<br />This is the representation produced by the program for different\n<br />versions of Redis and different settings:\n<br />\n<br />http://redis.io/images/redisdoc/lru_comparison.png\n<br />\n<br />When looking at the graph remember that the implementation we\n<br />discussed so far is the one of Redis 2.8. The improvement you\n<br />see in Redis 3.0 is explained in the next section.\n<br />\n<br />LRU V2: don’t trash away important information\n<br />===\n<br />\n<br />With the new visual tool, I was able to try new approaches and\n<br />test them in a matter of minutes. The most obvious way to improve\n<br />the vanilla algorithm used by Redis was to accumulate the otherwise\n<br />trashed information in a “pool” of good candidates for eviction.\n<br />\n<br />Basically when the N keys sampling was performed, it was used to\n<br />populate a larger pool of keys (just 16 keys by default).\n<br />This pool has the keys sorted by idle time, so new keys only enter\n<br />the pool when they have an idle time greater than one key in the\n<br />pool or when there is empty space in the pool.\n<br />\n<br />This small change improved the performances of the algorithm\n<br />dramatically as you can see in the image I linked above and\n<br />the implementation was not so complex. A couple memmove() here\n<br />and there and a few profiling efforts, but I don’t remember\n<br />major bugs in this area.\n<br />\n<br />At the same time, a new redis-cli mode to test the LRU precision\n<br />was added (see the —lru-test option), so I had another way to\n<br />check the performances of the LRU code with a power-law access\n<br />pattern. This tool was used to validate with a different test that\n<br />the new algorithm worked better with a more real-world-ish workload.\n<br />It also uses pipelining and displays the accesses per second, so\n<br />can be used in order to benchmark different implementations, at least\n<br />to check obvious speed regressions.\n<br />\n<br />Least Frequently Used\n<br />===\n<br />\n<br />The reason I’m writing this blog post right now is because a couple\n<br />of days ago I worked at a partial reimplementation and to different\n<br />improvements to the Redis cache eviction code.\n<br />\n<br />Everything started from an open issue: when you have multiple databases\n<br />with Redis 3.2, the algorithm evicts making local choices. So\n<br />if for example you have all keys with a small idle time in DB number 0,\n<br />and all keys with large idle time in DB number 1, Redis will evict\n<br />one key from each DB. A more rational choice is of course to start\n<br />evicting keys from DB number 1, and only later to evict the other keys.\n<br />\n<br />This is usually not a big deal, when Redis is used as a cache it is\n<br />rarely used with different DBs, however this is how I started to work\n<br />at the eviction code again. Eventually I was able to modify the pool\n<br />to include the database ID, and to use a single pool for all the DBs\n<br />instead of using multiple pools. It was slower, but by profiling and\n<br />tuning the code, eventually it was faster than the original\n<br />implementation by around 20%.\n<br />\n<br />However my curiosity for this subsystem of Redis was stimulated again\n<br />at that point, and I wanted to improve it. I spent a couple of days\n<br />trying to improve the LRU implementation: use a bigger pool maybe?\n<br />Account for the time that passes when selecting the best key?\n<br />\n<br />After some time, and after refining my tools, I understood that the\n<br />LRU algorithm was limited by the amount of data sampled in the database\n<br />and was otherwise very good and hard to improve. This is, actually,\n<br />kinda evident from the image showing the different algorithms:\n<br />sampling 10 keys per cycle the algorithm was almost as accurate as\n<br />theoretical LRU.\n<br />\n<br />Since the original algorithm was hard to improve, I started to test\n<br />new algorithms. If we rewind a bit to the start of the blog post, we\n<br />said that LRU is actually kinda a trick. What we really want is to\n<br />retain keys that have the maximum probability of being accessed in the\n<br />future, that are the keys *most frequently accessed*, not the ones with\n<br />the latest access.\n<br />\n<br />The algorithm evicting the keys with the least number of accesses\n<br />is called LFU. It means Least Frequently Used, which is the feature of\n<br />the keys that it attempts to kill to make space for new keys.\n<br />\n<br />In theory LFU is as simple as associating a counter to each key. At\n<br />every access the counter gets incremented, so that we know that a given\n<br />key is accessed more frequently than another key.\n<br />\n<br />Well, there are at least a few more problems, not specific to Redis,\n<br />general issues of LFU implementations:\n<br />\n<br />1. With LFU you cannot use the “move to head” linked list trick used for LRU in order to take elements sorted for eviction in a simple way, since keys must be ordered by number of accesses in “perfect LFU”. Moving the accessed key to the right place can be problematic because there could be many keys with the same score, so the operation can be O(N) in the worst case, even if the key frequency counter changed just a little. Also as we’ll see in point “2” the accesses counter does not always change just a little, there are also sudden large changes.\n<br />\n<br />2. LFU can’t really be as trivial as, just increment the access counter\n<br />on each access. As we said, access patterns change over time, so a key\n<br />with an high score needs to see its score reduced over time if nobody\n<br />keeps accessing it. Our algorithm must be albe to adapt over time.\n<br />\n<br />In Redis the first problems is not a problem: we can just use the trick\n<br />used for LRU: random sampling with the pool of candidates. The second\n<br />problem remains. So normally LFU implementations have some way in order\n<br />to decrement, or halve the access counter from time to time.\n<br />\n<br />Implementing LFU in 24 bits of space\n<br />===\n<br />\n<br />LFU has its implementation peculiarities itself, however in Redis all\n<br />we can use is our 24 bit LRU field in order to model LFU. To implement\n<br />LFU in just 24 bits per objects is a bit more tricky.\n<br />\n<br />What we need to do in 24 bits is:\n<br />\n<br />1. Some kind of access frequency counter.\n<br />2. Enough information to decide when to halve the counter.\n<br />\n<br />My solution was to split the 24 bits into two fields:\n<br />\n<br />           16 bits      8 bits\n<br />      +----------------+--------+\n<br />      + Last decr time | LOG_C  |\n<br />      +----------------+--------+\n<br />\n<br />The 16 bit field is the last decrement time, so that Redis knows the\n<br />last time the counter was decremented, while the 8 bit field is the\n<br />actual access counter.\n<br />\n<br />You are thinking that it’s pretty fast to overflow an 8 bit counter,\n<br />right? Well, the trick is, instead of using just a counter, I used\n<br />a logarithmic counter. This is the function that increments the\n<br />counter during accesses to the keys:\n<br />\n<br />  uint8_t LFULogIncr(uint8_t counter) {\n<br />      if (counter == 255) return 255;\n<br />      double r = (double)rand()/RAND_MAX;\n<br />      double baseval = counter - LFU_INIT_VAL;\n<br />      if (baseval < 0) baseval = 0;\n<br />      double p = 1.0/(baseval*server.lfu_log_factor+1);\n<br />      if (r < p) counter++;\n<br />      return counter;\n<br />  }\n<br />\n<br />Basically the greater is the value of the counter, the less probable\n<br />is that the counter will really be incremented: the code above computes\n<br />a number ‘p’ between 0 and 1 which is smaller and smaller as the counter\n<br />increases. Then it extracts a random number ‘r’ between 0 and 1 and only\n<br />increments the counter if ‘r < p’ is true.\n<br />\n<br />You can configure how much aggressively the counter is implemented\n<br />via redis.conf parameters, but for instance, with the default\n<br />settings, this is what happens:\n<br />\n<br />After 100 hits the value of the counter is 10\n<br />After 1000 is 18\n<br />After 100k is 142\n<br />After 1 million hits it reaches the 255 limit and no longer increments\n<br />\n<br />Now let’s see how this counter is decremented. The 16 bits are used in\n<br />order to store the less significant bits of the UNIX time converted\n<br />to minutes. As Redis performs random sampling scanning the key space\n<br />in search of keys to populate the pool, all keys that are encountered\n<br />are checked for decrement. If the last decrement was performed more than\n<br />N minutes ago (with N configurable), the value of the counter is halved\n<br />if it is an high value, or just decremented if it is a lower value\n<br />(in the hope that we can better discriminate among keys with few\n<br />accesses, given that our counter resolution is very small).\n<br />\n<br />There is yet another problem, new keys need a chance to survive after\n<br />all. In vanilla LFU a just added key has an access score of 0, so it\n<br />is a very good candidate for eviction. In Redis new keys start with\n<br />an LFU value of 5. This initial value is accounted in the increment\n<br />and halving algorithms. Simulations show that with this change keys have\n<br />some time in order to accumulate accesses: keys with a score less than\n<br />5 will be preferred (non active keys for a long time).\n<br />\n<br />Code and performances\n<br />===\n<br />\n<br />The implementation described above can be found in the “unstable” branch\n<br />of Redis. My initial tests show that it outperforms LRU in power-law\n<br />access patterns, while using the same amount of memory per key, however\n<br />real world access patterns may be different: time and space locality\n<br />of accesses may change in very different ways, so I’ll be very happy\n<br />to learn from real world use cases how LFU is performing, and how the\n<br />two parameters that you can tune in the Redis LFU implementation change\n<br />the performances for different workloads.\n<br />\n<br />Also an OBJECT FREQ subcommand was added in order to report the\n<br />frequency counter for a given key, this can be both useful in order\n<br />to observe an application access pattern, and in order to debug the\n<br />LFU implementation.\n<br />\n<br />Note that switching at runtime between LRU and LFU policies will have\n<br />the effect to start with almost random eviction, since the metadata\n<br />accumulated in the 24 bits counter does not match the meaning of the\n<br />newly selected policy. However over time it adapts again.\n<br />\n<br />There are probably many improvements possible.\n<br />\n<br />Ben Manes pointed me to this interesting paper, describing an algorithm\n<br />called TinyLRU (http://arxiv.org/pdf/1512.00727.pdf).\n<br />\n<br />The paper contains a very neat idea: instead of remembering the\n<br />access frequency of the current objects, let’s (probabilistically)\n<br />remember the access frequency of all the objects seen so far, this\n<br />way we can even refuse new keys if, from the name, we believe they\n<br />are likely to get little accesses, so that no eviction is needed at all,\n<br />if evicting a key means to lower the hits/misses ratio.\n<br />\n<br />My feeling is that this technique, while very interesting for plain\n<br />GET/SET LFU caches, is not applicable to the data structure server\n<br />nature of Redis: users expect the key to exist after being created\n<br />at least for a few milliseconds. Refusing the key creation at all\n<br />seems semantically wrong for Redis.\n<br />\n<br />However Redis maintains LFU informations when a key is overwritten, so\n<br />for example after a:\n<br />\n<br />    SET oldkey some_new_value\n<br />\n<br />The 24 bit LFU counter is copied to the new object associated to the\n<br />old key.\n<br />\n<br />The new eviction code of Redis unstable contains other good news:\n<br />\n<br />1. Policies are now “cross DB”. In the past Redis made local choices as explained at the start of this blog post. Now this is fixed for all the policies, not just LRU.\n<br />\n<br />2. The volatile-ttl eviction policy, which is the one that evicts based on the remaining time to live of keys with an expire set, now uses the pool like the other policies.\n<br />\n<br />3. Performances are better by reusing SDS objects in the pool of keys.\n<br />\n<br />This post ended a lot longer than I expected it to be, but I hope it offered a few insights on the new stuff and the improvements to the old things we already had. Redis, more than a “solution” to solve a specific problem, is a generic tool. It’s up to the sensible developer to apply it in the right way. Many people use Redis as a caching solution, so improvements in this area are always investigated from time to time.\n<br />\n<br />Hacker News comments: https://news.ycombinator.com/item?id=12185534\n<a href=\"http://antirez.com/news/109\">Comments</a>",
  "id": "http://antirez.com/news/109"
}