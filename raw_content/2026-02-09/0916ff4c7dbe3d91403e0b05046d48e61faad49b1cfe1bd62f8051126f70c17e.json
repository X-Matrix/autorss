{
  "title": "Intel's $475 million error: the silicon behind the Pentium division bug",
  "link": "http://www.righto.com/2024/12/this-die-photo-of-pentium-shows.html",
  "published": "2024-12-28T10:54:00.000-08:00",
  "summary": "<p>In 1993, Intel released the high-performance Pentium processor, the start of the long-running Pentium line.\nThe Pentium had many improvements over the previous processor, the Intel 486, including a faster floating-point division algorithm.\nA year later, Professor Nicely, a number theory professor,\nwas researching reciprocals of twin prime numbers when he noticed a problem:\nhis Pentium sometimes generated the wrong result when performing floating-point division.\nIntel considered this \"an extremely minor technical problem\", but much to Intel's surprise,\nthe bug became a large media story.\nAfter weeks of criticism, mockery, and bad publicity, Intel agreed to replace everyone's faulty Pentium chips, costing the company $475 million.</p>\n<p>In this article, I discuss the Pentium's division algorithm, show exactly where the bug is on the Pentium chip, take a close look at the circuitry, and explain what went wrong.\nIn brief, the division algorithm uses a lookup table. In 1994, Intel stated that the cause of the bug was\nthat five entries were omitted from the\ntable due to an error in a script. However, my analysis shows that 16 entries were omitted due to a\nmathematical mistake in the definition of the lookup table. Five of the missing entries trigger the bug&mdash;\nalso called the FDIV bug after the floating-point division instruction \"FDIV\"&mdash;while 11 of the missing entries have no effect.</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/fdiv-bug-here.jpg\"><img alt=\"This die photo of the Pentium shows the location of the FDIV bug. Click this image (or any other) for a larger version.\" class=\"hilite\" height=\"453\" src=\"https://static.righto.com/images/pentium-fdiv/fdiv-bug-here-w500.jpg\" title=\"This die photo of the Pentium shows the location of the FDIV bug. Click this image (or any other) for a larger version.\" width=\"500\" /></a><div class=\"cite\">This die photo of the Pentium shows the location of the FDIV bug. Click this image (or any other) for a larger version.</div></p>\n<p>Although Professor Nicely brought attention to the FDIV bug, he wasn't the first to find it.\nIn May 1994, Intel's internal testing of the Pentium revealed that\nvery rarely, floating-point division was slightly inaccurate.<span id=\"fnref:dham\"><a class=\"ref\" href=\"#fn:dham\">1</a></span>\nSince only one in 9 billion values caused the problem, Intel's view was that the problem was trivial:  \"This doesn't even qualify as an errata.\" Nonetheless, Intel quietly revised the Pentium circuitry to fix the problem.</p>\n<p>A few months later, in October, Nicely noticed erroneous results in his prime number computations.<span id=\"fnref:prime\"><a class=\"ref\" href=\"#fn:prime\">2</a></span>\nHe soon determined that 1/824633702441 was wrong on three different Pentium computers, but his older computers gave the right answer.\nHe called Intel tech support but was brushed off, so\nNicely emailed a dozen computer magazines and individuals about the bug.\nOne of the recipients was Andrew Schulman, author of \"Undocumented DOS\". He forwarded the email to Richard Smith, cofounder of a DOS software tools company.\nSmith posted the email on a Compuserve forum, a 1990s version of social media.</p>\n<p>A reporter for the journal <em>Electronic Engineering Times</em> spotted the Compuserve post and wrote about the Pentium bug in the November 7 issue: <a href=\"https://davefaq.com/Opinions/Stupid/Pentium.html\">Intel fixes a Pentium FPU glitch</a>.\nIn the article, Intel explained that the bug was in a component of the chip called a PLA (Programmable Logic Array)\nthat acted as a lookup table for the division operation.\nIntel had fixed the bug in the latest Pentiums and\nwould replace faulty processors for concerned customers.<span id=\"fnref:timeline\"><a class=\"ref\" href=\"#fn:timeline\">3</a></span></p>\n<p>The problem might have quietly ended here, except that Intel decided to restrict which customers could get a replacement.\nIf a customer couldn't convince an Intel engineer that they needed the accuracy, they couldn't get a fixed Pentium.\nUsers were irate to be stuck with faulty chips so they took their complaints to online groups such as <a href=\"https://groups.google.com/g/comp.sys.intel/c/L1KDE1d_ZLA/m/7rydJksrVTcJ\">comp.sys.intel</a>.\nThe controversy spilled over into the offline world on November 22 when CNN reported on the bug.\nPublic awareness of the Pentium bug took off as newspapers wrote about the bug and\nIntel became a punchline on talk shows.<span id=\"fnref:letterman\"><a class=\"ref\" href=\"#fn:letterman\">4</a></span></p>\n<p>The situation became intolerable for Intel on December 12 when IBM announced that it was stopping shipments of Pentium computers.<span id=\"fnref:errata\"><a class=\"ref\" href=\"#fn:errata\">5</a></span>\nOn December 19, less than two months after Nicely first reported the bug, Intel gave in and announced that it would replace the flawed chips for all customers.<span id=\"fnref:apology\"><a class=\"ref\" href=\"#fn:apology\">6</a></span>\nThis recall cost Intel $475 million (over a billion dollars in current dollars).</p>\n<p>Meanwhile, engineers and mathematicians were analyzing the bug, including\nTim Coe, an engineer who had designed floating-point units.<span id=\"fnref:coe\"><a class=\"ref\" href=\"#fn:coe\">7</a></span>\nRemarkably, by studying the Pentium's bad divisions, Coe reverse-engineered the Pentium's division algorithm and determined why it went wrong.\nCoe and others wrote papers describing the mathematics behind the Pentium bug.<span id=\"fnref:papers\"><a class=\"ref\" href=\"#fn:papers\">8</a></span>\nBut until now, nobody has shown how the bug is implemented in the physical chip itself.</p>\n<h2>A quick explanation of floating point numbers</h2>\n<p>At this point, I'll review a few important things about floating point numbers.\nA binary number can have a fractional part, similar to a decimal number.\nFor instance, the binary number 11.1001 has four digits after the binary point.\n(The binary point \".\" is similar to the decimal point, but for a binary number.) The first digit after the binary point represents 1/2, the second represents 1/4, and so forth.\nThus, 11.1001 corresponds to 3 + 1/2 + 1/16 = 3.5625.\nA \"fixed point\" number such as this can express a fractional value, but its range is limited.</p>\n<p>Floating point numbers, on the other hand, include very large numbers such as 6.02&times;10<sup>23</sup> and very small numbers such as 1.055×10<sup>−34</sup>.\nIn decimal, 6.02&times;10<sup>23</sup> has a significand (or mantissa) of 6.02, multiplied by a power of 10 with an exponent of 23.\nIn binary, a floating point number is represented similarly, with a significand and exponent, except the significand is multiplied by a power of 2 rather than 10.</p>\n<p>Computers have used floating point since the early days of computing, especially for scientific computing.\nFor many years, different computers used incompatible formats for floating point numbers.\nEventually, a standard arose when\nIntel developed the 8087 floating point coprocessor chip for use with the 8086/8088 processor.\nThe characteristics of this chip became a standard (IEEE 754) in 1985.<span id=\"fnref:ieee754\"><a class=\"ref\" href=\"#fn:ieee754\">9</a></span>\nSubsequently, most computers, including the Pentium, implemented floating point numbers according to this standard.\nThe result of a basic arithmetic operation is supposed to be accurate up to the last bit of the significand.\nUnfortunately, division on the Pentium was occasionally much, much worse.</p>\n<h2>How SRT division works</h2>\n<p>How does a computer perform division? The straightforward way is similar to grade-school long division, except in binary.\nThat approach was used in the Intel 486 and earlier processors, but the process is slow, taking one clock cycle for each bit of the quotient.\nThe Pentium uses a different approach called SRT,<span id=\"fnref:srt-history\"><a class=\"ref\" href=\"#fn:srt-history\">10</a></span> performing division in base four.\nThus, SRT generates two bits of the quotient per step, rather than one, so division is twice as fast.\nI'll explain SRT in a hand-waving manner with a base-10 example; rigorous explanations are available elsewhere.</p>\n<p>The diagram below shows base-10 long division, with the important parts named.\nThe dividend is divided by the divisor, yielding the quotient.\nIn each step of the long division algorithm, you generate one more digit of the quotient.\nThen you multiply the divisor (1535) by the quotient digit (2) and subtract this from the dividend,\nleaving a partial remainder.\nYou multiply the partial remainder by 10 and then repeat the process, generating a quotient digit and partial remainder at each step.\nThe diagram below stops after two quotient digits, but you can keep going to get as much accuracy as desired.</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/srt-diagram1.jpg\"><img alt=\"Base-10 division, naming the important parts.\" class=\"hilite\" height=\"168\" src=\"https://static.righto.com/images/pentium-fdiv/srt-diagram1-w300.jpg\" title=\"Base-10 division, naming the important parts.\" width=\"300\" /></a><div class=\"cite\">Base-10 division, naming the important parts.</div></p>\n<p>Note that division is more difficult than multiplication since there is no easy way to determine each quotient digit.\nYou have to estimate a quotient digit, multiply it by the divisor, and then check if the quotient digit is correct.\nFor example, you have to check carefully to see if 1535 goes into 4578 two times or three times.</p>\n<p>The SRT algorithm makes it easier to select the quotient digit through an unusual approach: it allows negative digits in the quotient.\nWith this change, the quotient digit does not need to be exact.\nIf you pick a quotient digit that is a bit too large, you can use a negative number for the next digit:\nthis will counteract the too-large digit since the next divisor will be added rather than subtracted.</p>\n<p>The example below shows how this works.\nSuppose you picked 3 instead of 2 as the first quotient digit.\nSince 3 is too big, the partial remainder is negative (-261).\nIn normal division, you'd need to try again with a different quotient digit.\nBut with SRT, you keep going, using a negative digit (-1) for the quotient digit in the next step.\nAt the end, the quotient with positive and negative digits can be converted to the standard form: 3&times;10-1 = 29, the same quotient as before.</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/srt-diagram2.jpg\"><img alt=\"Base-10 division, using a negative quotient digit. The result is the same as the previous example.\" class=\"hilite\" height=\"159\" src=\"https://static.righto.com/images/pentium-fdiv/srt-diagram2-w300.jpg\" title=\"Base-10 division, using a negative quotient digit. The result is the same as the previous example.\" width=\"300\" /></a><div class=\"cite\">Base-10 division, using a negative quotient digit. The result is the same as the previous example.</div></p>\n<p>One nice thing about the SRT algorithm is that since the quotient digit only needs to be close, a lookup table can be used to select the quotient digit.\nSpecifically, the partial remainder and divisor can be truncated to a few digits, making the lookup table a practical size.\nIn this example, you could truncate 1535 and 4578 to 15 and 45, the table says that 15 goes into 45 three times, and you can use 3 as your quotient digit.</p>\n<p>Instead of base 10, the Pentium uses the SRT algorithm in base 4: groups of two bits.\nAs a result, division on the Pentium is twice as fast as standard binary division.\nWith base-4 SRT, each quotient digit can be -2, -1, 0, 1, or 2.\nMultiplying by any of these values is very easy in hardware since multiplying by 2 can be done by a bit shift.\nBase-4 SRT does not require quotient digits of -3 or 3;\nthis is convenient since multiplying by 3 is somewhat difficult.\nTo summarize, base-4 SRT is twice as fast as regular binary division, but it requires more hardware:\na lookup table, circuitry to add or subtract multiples of 1 or 2, and circuitry to convert the\nquotient to the standard form.</p>\n<h2>Structure of the Pentium's lookup table</h2>\n<p>The purpose of the SRT lookup table is to provide the quotient digit.\nThat is, the table takes the partial remainder <em>p</em> and the divisor <em>d</em> as inputs and\nprovides an appropriate quotient digit.\nThe Pentium's lookup table is the cause of the division bug, as was explained in 1994.\nThe table was missing five entries; if the SRT algorithm accesses one of these missing entries, it generates an incorrect result.\nIn this section, I'll discuss the structure of the lookup table and explain what went wrong.</p>\n<p>The Pentium's lookup table contains 2048 entries, as shown below.\nThe table has five regions corresponding to the quotient digits +2, +1, 0, -1, and -2.\nMoreover, the upper and lower regions of the table are unused (due to the mathematics of SRT).\nThe unused entries were filled with 0, which turns out to be very important.\nIn particular, the five red entries need to contain +2 but were erroneously filled with 0.</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/table-labeled.jpg\"><img alt=\"The 2048-entry lookup table used in the Pentium for division. The divisor is along the X-axis, from 1 to 2. The partial remainder is along the Y-axis, from -8 to 8. Click for a larger version.\" class=\"hilite\" height=\"716\" src=\"https://static.righto.com/images/pentium-fdiv/table-labeled-w250.jpg\" title=\"The 2048-entry lookup table used in the Pentium for division. The divisor is along the X-axis, from 1 to 2. The partial remainder is along the Y-axis, from -8 to 8. Click for a larger version.\" width=\"250\" /></a><div class=\"cite\">The 2048-entry lookup table used in the Pentium for division. The divisor is along the X-axis, from 1 to 2. The partial remainder is along the Y-axis, from -8 to 8. Click for a larger version.</div></p>\n<p>When the SRT algorithm uses the table, the partial remainder <em>p</em> and the divisor <em>d</em> are inputs.\nThe divisor (scaled to fall between 1 and 2) provides the X coordinate into the table, while the partial remainder\n(between -8 and 8) provides the Y coordinate.\nThe details of the table coordinates will be important, so I'll go into some detail.\nTo select a cell, the divisor (X-axis) is truncated to a 5-bit binary value 1.dddd.\n(Since the first digit of the divisor is always 1, it is ignored for the table lookup.)\nThe partial remainder (Y-axis) is truncated to a 7-bit signed binary value pppp.ppp.\nThe 11 bits indexing into the table result in a table with 2<sup>11</sup> (2048) entries.\nThe partial remainder is expressed in 2's complement, so values 0000.000 to 0111.111 are non-negative values from 0 to (almost) 8, while values 1000.000 to 1111.111 are negative values from -8 to (almost) 0.\n(To see the binary coordinates for the table, click on the image and zoom in.)</p>\n<h2>The lookup table is implemented in a Programmable Logic Array (PLA)</h2>\n<p>In this section, I'll explain how the lookup table is implemented in hardware in the Pentium.\nThe lookup table has 2048 entries so it could be stored in a ROM with 2048 two-bit outputs.<span id=\"fnref:dimensions\"><a class=\"ref\" href=\"#fn:dimensions\">11</a></span>\n(The sign is not explicitly stored in the table because\nthe quotient digit sign is the same as the partial remainder sign.)\nHowever, because the table is highly structured (and largely empty), the table can be stored more compactly in a structure called a Programmable Logic Array (PLA).<span id=\"fnref:intel-pla\"><a class=\"ref\" href=\"#fn:intel-pla\">12</a></span>\nBy using a PLA, the Pentium stored the table in just 112 rows rather than 2048 rows, saving an enormous amount of space.\nEven so, the PLA is large enough on the chip that it is visible to the naked eye, if you squint a bit.</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/pla-zoom.jpg\"><img alt=\"Zooming in on the PLA and associated circuitry on the Pentium die.\" class=\"hilite\" height=\"514\" src=\"https://static.righto.com/images/pentium-fdiv/pla-zoom-w600.jpg\" title=\"Zooming in on the PLA and associated circuitry on the Pentium die.\" width=\"600\" /></a><div class=\"cite\">Zooming in on the PLA and associated circuitry on the Pentium die.</div></p>\n<p>The idea of a PLA is to provide a dense and flexible way of implementing arbitrary logic functions.\nAny Boolean logic function can be expressed as a \"sum-of-products\", a collection of AND terms (products) that are OR'd together (summed).\nA PLA has a block of circuitry called the AND plane that generates the desired sum terms.\nThe outputs of the AND plane are fed into a second block, the OR plane, which ORs the terms together.\nThe AND plane and the OR plane are organized as grids. Each gridpoint can either have a transistor\nor not, defining the logic functions.\nThe point is that by putting the appropriate pattern of transistors in the grids, you can create any function.\nFor the division PLA, there are has 22 inputs (the 11 bits from the divisor and partial remainder indices, along with their complements) and two outputs, as shown below.<span id=\"fnref:pla\"><a class=\"ref\" href=\"#fn:pla\">13</a></span></p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/pla-structure.jpg\"><img alt=\"A simplified diagram of the division PLA.\" class=\"hilite\" height=\"317\" src=\"https://static.righto.com/images/pentium-fdiv/pla-structure-w400.jpg\" title=\"A simplified diagram of the division PLA.\" width=\"400\" /></a><div class=\"cite\">A simplified diagram of the division PLA.</div></p>\n<p>A PLA is more compact than a ROM if the structure of the function allows it to be expressed with a small number of terms.<span id=\"fnref:rom\"><a class=\"ref\" href=\"#fn:rom\">14</a></span>\nOne difficulty with a PLA is figuring out how to express the function with the minimum number of terms to\nmake the PLA as small as possible.\nIt turns out that this problem is NP-complete in general.\nIntel used a program called Espresso to generate compact PLAs using heuristics.<span id=\"fnref:espresso\"><a class=\"ref\" href=\"#fn:espresso\">15</a></span></p>\n<p>The diagram below shows the division PLA in the Pentium. The PLA has 120 rows, split into two 60-row parts with support circuitry in the middle.<span id=\"fnref:split\"><a class=\"ref\" href=\"#fn:split\">16</a></span>\nThe 11 table input bits go into the AND plane drivers in the middle, which produce the 22 inputs to the PLA (each table input and its complement).\nThe outputs from the AND plane transistors go through output buffers and are fed into the OR plane. \nThe outputs from the OR plane go through additional buffers and logic in the center, producing two\noutput bits, indicating a ±1 or ±2 quotient.\nThe image below shows the updated PLA that fixes the bug; the faulty PLA looks similar except the transistor\npattern is different. In particular, the updated PLA has 46 unused rows at the bottom while the original, faulty\nPLA has 8 unused rows.</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/pla-labeled.jpg\"><img alt=\"The division PLA with the metal layers removed to show the silicon. This image shows the PLA in the updated Pentium, since that photo came out better.\" class=\"hilite\" height=\"802\" src=\"https://static.righto.com/images/pentium-fdiv/pla-labeled-w450.jpg\" title=\"The division PLA with the metal layers removed to show the silicon. This image shows the PLA in the updated Pentium, since that photo came out better.\" width=\"450\" /></a><div class=\"cite\">The division PLA with the metal layers removed to show the silicon. This image shows the PLA in the updated Pentium, since that photo came out better.</div></p>\n<p>The image below shows part of the AND plane of the PLA.\nAt each point in the grid, a transistor can be present or absent.\nThe pattern of transistors in a row determines the logic term for that row.\nThe vertical doped silicon lines (green) are connected to ground. The vertical polysilicon lines (red) are\ndriven with the input bit pattern. If a polysilicon line crosses doped silicon, it forms a\ntransistor (orange) that will pull that row to ground when activated.<span id=\"fnref:demorgan\"><a class=\"ref\" href=\"#fn:demorgan\">17</a></span>\nA metal line connects all the transistor rows in a row to produce the output;\nmost of the metal has been removed, but some metal lines are visible at the right.</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/pla-silicon-right.jpg\"><img alt=\"Part of the AND plane in the fixed Pentium. I colored the first silicon and polysilicon lines green and red respectively.\" class=\"hilite\" height=\"430\" src=\"https://static.righto.com/images/pentium-fdiv/pla-silicon-right-w600.jpg\" title=\"Part of the AND plane in the fixed Pentium. I colored the first silicon and polysilicon lines green and red respectively.\" width=\"600\" /></a><div class=\"cite\">Part of the AND plane in the fixed Pentium. I colored the first silicon and polysilicon lines green and red respectively.</div></p>\n<p>By carefully examining the PLA under a microscope, I extracted the pattern of transistors in\nthe PLA grid. (This was somewhat tedious.) From the transistor pattern, I could\ndetermine the equations for each PLA row, and then generate the contents of the lookup table.\nNote that the transistors in the PLA don't directly map to the table contents (unlike a ROM).\nThus, there is no specific place for transistors corresponding to the 5 missing table entries.</p>\n<p>The left-hand side of the PLA implements the OR planes (below).\nThe OR plane determines if the row output produces a quotient of 1 or 2.\nThe OR plane is oriented 90&deg; relative to the AND plane: the inputs are horizontal polysilicon\nlines (red) while the output lines are vertical.\nAs before, a transistor (orange) is formed where polysilicon crosses doped silicon.\nCuriously, each OR plane has four outputs, even though the PLA itself has two outputs.<span id=\"fnref:outputs\"><a class=\"ref\" href=\"#fn:outputs\">18</a></span></p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/pla-lhs.jpg\"><img alt=\"Part of the OR plane of the division PLA. I removed the metal layers to show the underlying silicon and polysilicon. I drew lines for ground and outputs, showing where the metal lines were.\" class=\"hilite\" height=\"488\" src=\"https://static.righto.com/images/pentium-fdiv/pla-lhs-w450.jpg\" title=\"Part of the OR plane of the division PLA. I removed the metal layers to show the underlying silicon and polysilicon. I drew lines for ground and outputs, showing where the metal lines were.\" width=\"450\" /></a><div class=\"cite\">Part of the OR plane of the division PLA. I removed the metal layers to show the underlying silicon and polysilicon. I drew lines for ground and outputs, showing where the metal lines were.</div></p>\n<p>Next, I'll show exactly how the AND plane produces a term.\nFor the division table, the inputs are the 7 partial remainder bits and 4 divisor bits, as explained\nearlier.\nI'll call the partial remainder bits p<sub>6</sub>p<sub>5</sub>p<sub>4</sub>p<sub>3</sub>.p<sub>2</sub>p<sub>1</sub>p<sub>0</sub> and the divisor bits 1.d<sub>3</sub>d<sub>2</sub>d<sub>1</sub>d<sub>0</sub>.\nThese 11 bits and their complements are fed vertically into the PLA as shown at the top of the diagram below.\nThese lines are polysilicon, so they will form transistor gates, turning on the corresponding transistor when activated.\nThe arrows at the bottom point to nine transistors in the first row.\n(It's tricky to tell if the polysilicon line passes next to doped silicon or over the silicon, so\nthe transistors aren't always obvious.)\nLooking at the transistors and their inputs shows that the first term in the PLA is generated by\np<sub>0</sub>p<sub>1</sub>p<sub>2</sub>p<sub>3</sub>p<sub>4</sub>'p<sub>5</sub>p<sub>6</sub>d<sub>1</sub>d<sub>2</sub>.</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/pla-top-labeled.jpg\"><img alt=\"The first row of the division PLA in a faulty Pentium.\" class=\"hilite\" height=\"175\" src=\"https://static.righto.com/images/pentium-fdiv/pla-top-labeled-w500.jpg\" title=\"The first row of the division PLA in a faulty Pentium.\" width=\"500\" /></a><div class=\"cite\">The first row of the division PLA in a faulty Pentium.</div></p>\n<p>The diagram below is a closeup of the lookup table, showing how this PLA row assigns the value 1 to four table cells (dark blue).\nYou can think of each term of the PLA as pattern-matching to a binary pattern that can include \"don't care\" values.\nThe first PLA term (above) matches the pattern P=110.1111, D=x11x, where the \"don't care\" x values can be either 0 or 1.\nSince one PLA row can implement multiple table cells, the PLA is more efficient than a ROM;\nthe PLA uses 112 rows, while a ROM would require 2048 rows.</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/pla-entry-diagram.jpg\"><img alt=\"The first entry in the PLA assigns the value 1 to the four dark blue cells.\" class=\"hilite\" height=\"242\" src=\"https://static.righto.com/images/pentium-fdiv/pla-entry-diagram-w400.jpg\" title=\"The first entry in the PLA assigns the value 1 to the four dark blue cells.\" width=\"400\" /></a><div class=\"cite\">The first entry in the PLA assigns the value 1 to the four dark blue cells.</div></p>\n<p>Geometrically, you can think of each PLA term (row) as covering a rectangle or rectangles in the table.\nHowever, the rectangle can't be arbitrary, but must be aligned on a bit boundary.\nNote that each \"bump\" in the table boundary (magenta) requires a separate rectangle and thus a separate PLA row.\n(This will be important later.)</p>\n<p>One PLA row can generate a large rectangle, filling in many table cells at once,\nif the region happens to be aligned nicely.\nFor instance, the third term in the PLA matches d=xxxx, p=11101xx.\nThis single PLA row efficiently fills in\n64 table cells as shown below, replacing the 64 rows that would be required in a ROM.</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/pla-entry-diagram2.jpg\"><img alt=\"The third entry in the PLA assigns the value 1 to the 64 dark blue cells.\" class=\"hilite\" height=\"238\" src=\"https://static.righto.com/images/pentium-fdiv/pla-entry-diagram2-w400.jpg\" title=\"The third entry in the PLA assigns the value 1 to the 64 dark blue cells.\" width=\"400\" /></a><div class=\"cite\">The third entry in the PLA assigns the value 1 to the 64 dark blue cells.</div></p>\n<p>To summarize, the pattern of transistors in the PLA implements a set of equations, which define\nthe contents of the table, setting the quotient to 1 or 2 as appropriate.\nAlthough the table has 2048 entries, the PLA represents the contents in just 112 rows.\nBy carefully examining the transistor pattern, I determined the table contents in a faulty Pentium and\na fixed Pentium.</p>\n<h2>The mathematical bounds of the lookup table</h2>\n<p>As shown earlier, the lookup table has regions corresponding to quotient digits of +2, +1, 0, -1, and -2.\nThese regions have irregular, slanted shapes, defined by mathematical bounds.\nIn this section, I'll explain these mathematical bounds since\nthey are critical to understanding how the Pentium bug occurred.</p>\n<p>The essential step of the division algorithm is to divide\nthe partial remainder <em>p</em> by the divisor <em>d</em> to get the quotient digit.\nThe following diagram shows how <em>p/d</em> determines the quotient digit. The ratio <em>p/d</em> will define a point on\nthe line at the top. (The point will be in the range [-8/3, 8/3] for mathematical reasons.)\nThe point will fall into one of the five lines below, defining the quotient digit <em>q</em>. However, the five quotient\nregions overlap; if <em>p/d</em> is in one of the green segments, there are two possible quotient digits.\nThe next part of the diagram illustrates how subtracting\n<em>q*d</em> from the partial remainder <em>p</em> shifts <em>p/d</em> into the middle, between -2/3 and 2/3.\nFinally, the result is multiplied by 4 (shifted left by two bits), expanding<span id=\"fnref:chaos\"><a class=\"ref\" href=\"#fn:chaos\">19</a></span> the interval back to [-8/3, 8/3], which is the same size as the original interval.\nThe 8/3 bound may seem arbitrary, but the motivation is that\nit ensures that the new interval is the same size as the original interval, so the process can be repeated.\n(The bounds are all thirds for algebraic reasons; the value 3 comes from base 4 minus 1.<span id=\"fnref:bound\"><a class=\"ref\" href=\"#fn:bound\">20</a></span>)</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/intervals.jpg\"><img alt=\"The input to a division step is processed, yielding the input to the next step.\" class=\"hilite\" height=\"335\" src=\"https://static.righto.com/images/pentium-fdiv/intervals-w550.jpg\" title=\"The input to a division step is processed, yielding the input to the next step.\" width=\"550\" /></a><div class=\"cite\">The input to a division step is processed, yielding the input to the next step.</div></p>\n<p>Note that the SRT algorithm has some redundancy, but cannot handle <em>q</em> values that are \"too wrong\".\nSpecifically, if <em>p/d</em> is in a green region,\nthen either of two <em>q</em> values can be selected.\nHowever, the algorithm cannot recover from a bad <em>q</em> value in general.\nThe relevant case is that if <em>q</em> is supposed to be 2 but 0 is selected,\nthe next partial remainder will be outside the interval and the algorithm can't recover.\nThis is what causes the FDIV bug.</p>\n<p>The diagram below shows the structure of the SRT lookup table (also called the P-D table since the axes are <em>p</em> and <em>d</em>).\nEach bound in the diagram above turns into a line in the table.\nFor instance, the green segment above with <em>p/d</em> between 4/3 and 5/3 turns into a green region in the\ntable below with <em>4/3 d ≤ p ≤ 5/3 d</em>.\nThese slanted lines show the regions in which a particular quotient digit <em>q</em> can be used.</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/pd-table.jpg\"><img alt=\"The P-D table specifies the quotient digit for a partial remainder (Y-axis) and divisor (X-axis).\" class=\"hilite\" height=\"686\" src=\"https://static.righto.com/images/pentium-fdiv/pd-table-w350.jpg\" title=\"The P-D table specifies the quotient digit for a partial remainder (Y-axis) and divisor (X-axis).\" width=\"350\" /></a><div class=\"cite\">The P-D table specifies the quotient digit for a partial remainder (Y-axis) and divisor (X-axis).</div></p>\n<p>The lookup table in the Pentium is based on the above table, quantized with a <em>q</em> value in each cell.\nHowever, there is one more constraint to discuss.</p>\n<h2>Carry-save and carry-lookahead adders</h2>\n<p>The Pentium's division circuitry uses a special circuit to perform addition and subtraction efficiently:\nthe carry-save adder.\nOne consequence of this adder is that each access to the lookup table may go to the cell just below\nthe \"right\" cell. This is expected and should be fine, but in very rare and complicated circumstances,\nthis behavior causes an access to one of the Pentium's five missing cells, triggering the division bug.\nIn this section, I'll discuss why the division circuitry uses a carry-save adder, how the carry-save adder works,\nand how the carry-save adder triggers the FDIV bug.</p>\n<p>The problem with addition is that carries make addition slow.\nConsider calculating 99999+1 by hand.\nYou'll start with 9+1=10, then carry the one, generating another carry, which generates another carry, and so forth, until you go through all the digits.\nComputer addition has the same problem.\nIf you're adding, say, two 64-bit numbers, the low-order bits can generate a carry that then propagates through all 64 bits.\nThe time for the carry signal to go through 64 layers of circuitry is significant and can limit CPU performance.\nAs a result, CPUs use special circuits to make addition faster.</p>\n<p>The Pentium's division circuitry uses an unusual adder circuit called a carry-save adder to add (or subtract) the divisor and the partial remainder.\nA carry-save adder speeds up addition if you are performing a bunch of additions, as happens during division.\nThe idea is that instead of adding a carry to each digit as it happens, you hold onto the carries in a separate word.\nAs a decimal example, 499+222 would be 611 with carries 011; you don't carry the one to the second digit, but hold onto it.\nThe next time you do an addition, you add in the carries you saved previously, and again save any new carries.\nThe advantage of the carry-save adder is that the sum and carry at each digit position can be computed in parallel, which is fast.\nThe disadvantage is that you need to do a slow addition at the end of the sequence of additions to add in the remaining carries to get the final answer.\nBut if you're performing multiple additions (as for division), the carry-save adder is faster overall.</p>\n<p>The carry-save adder creates a problem for the lookup table.\nWe need to use the partial remainder as an index into the lookup table.\nBut the carry-save adder splits the partial remainder into two parts: the sum bits and the carry bits.\nTo get the table index, we need to add the sum bits and carry bits together.\nSince this addition needs to happen for every step of the division, it seems like we're back to using a slow adder and the carry-save adder has just made things worse.</p>\n<p>The trick is that we only need 7 bits of the partial remainder for the table index, so we can use\na different type of adder&mdash;a carry-lookahead adder&mdash;that calculates each carry in parallel using brute force logic.\nThe logic in a carry-lookahead adder gets more and more complex for each bit so a carry-lookahead adder is impractical for large words, but it is practical for a 7-bit value.</p>\n<p>The photo below shows the carry-lookahead adder used by the divider.\nCuriously, the adder is an 8-bit adder but only 7 bits are used;\nperhaps the 8-bit adder was a standard logic block at Intel.<span id=\"fnref:8bit\"><a class=\"ref\" href=\"#fn:8bit\">21</a></span>\nI'll just give a quick summary of the adder here, and leave the details for another post.\nAt the top, logic gates compute signals in parallel for each of the 8 pairs of inputs: sum, carry generate, and carry propagate.\nNext, the complex carry-lookahead logic determines in parallel if there will be a carry at each position.\nFinally, XOR gates apply the carry to each bit.\nThe circuitry in the middle is used for testing; see the footnote.<span id=\"fnref:testing\"><a class=\"ref\" href=\"#fn:testing\">22</a></span>\nAt the bottom, the drivers amplify control signals for various parts of the adder and send the PLA output to other parts of the chip.<span id=\"fnref:bicmos\"><a class=\"ref\" href=\"#fn:bicmos\">23</a></span>\nBy counting the blocks of repeated circuitry, you can see which blocks are 8 bits wide, 11, bits wide, and so forth.\nThe carry-lookahead logic is different for each bit, so there is no repeated structure.</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/adder-silicon.jpg\"><img alt=\"The carry-lookahead adder that feeds the lookup table. This block of circuitry is just above the PLA on the die. I removed the metal layers, so this photo shows the doped silicon (dark) and the polysilicon (faint gray).\" class=\"hilite\" height=\"859\" src=\"https://static.righto.com/images/pentium-fdiv/adder-silicon-w600.jpg\" title=\"The carry-lookahead adder that feeds the lookup table. This block of circuitry is just above the PLA on the die. I removed the metal layers, so this photo shows the doped silicon (dark) and the polysilicon (faint gray).\" width=\"600\" /></a><div class=\"cite\">The carry-lookahead adder that feeds the lookup table. This block of circuitry is just above the PLA on the die. I removed the metal layers, so this photo shows the doped silicon (dark) and the polysilicon (faint gray).</div></p>\n<p>The carry-save and carry-lookahead adders may seem like implementation trivia, but they are\na critical part of the FDIV bug because they change the constraints on the table.\nThe cause is that the partial remainder is 64 bits,<span id=\"fnref:64-bits\"><a class=\"ref\" href=\"#fn:64-bits\">24</a></span> but the adder that computes the table\nindex is 7 bits.\nSince the rest of the bits are truncated before the sum, the partial remainder sum for the table index\ncan be slightly lower than the real partial remainder.\nSpecifically, the table index can be one cell lower than the correct cell, an offset of 1/8.\nRecall the earlier diagram with diagonal lines separating the regions.\nSome (but not all) of these lines must be shifted down by 1/8 to account for the carry-save effect,\nbut Intel made the wrong adjustment, which is the root cause of the FDIV error.\n(This effect was well-known at the time and mentioned in papers on SRT division, so Intel shouldn't have gotten it wrong.)</p>\n<p>An interesting thing about the FDIV bug is how extremely rare it is.\nWith 5 bad table entries out of 2048, you'd expect erroneous divides to be very common.\nHowever, for complicated mathematical reasons involving the carry-save adder\nthe missing table entries are almost never encountered:\nonly about 1 in 9 billion random divisions will encounter a problem.\nTo hit a missing table entry, you need an \"unlucky\" result from the carry-save adder multiple\ntimes in a row, making the odds similar to winning the lottery, if the lottery prize were a division error.<span id=\"fnref:heatmaps\"><a class=\"ref\" href=\"#fn:heatmaps\">25</a></span></p>\n<h2>What went wrong in the lookup table</h2>\n<p>I consider the diagram below to be the \"smoking gun\" that explains how the FDIV bug happens:\nthe top magenta line should be above the sloping black line, but it crosses the black line repeatedly.\nThe magenta line carefully stays above the gray line, but that's the wrong line.\nIn other words, Intel picked the wrong bounds line when defining the +2 region of the table.\nIn this section, I'll explain why that causes the bug.</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/bounds2.jpg\"><img alt=\"The top half of the lookup table, explaining the root of the FDIV bug.\" class=\"hilite\" height=\"469\" src=\"https://static.righto.com/images/pentium-fdiv/bounds2-w500.jpg\" title=\"The top half of the lookup table, explaining the root of the FDIV bug.\" width=\"500\" /></a><div class=\"cite\">The top half of the lookup table, explaining the root of the FDIV bug.</div></p>\n<p>The diagram is colored according to the quotient values stored in the Pentium's lookup table: yellow is +2,\nblue is +1, and white is 0, with magenta lines showing the boundaries between different values.\nThe diagonal black lines are the mathematical constraints on the table, defining the region that\nmust be +2, the region that can be +1 or +2, the region that must be +1, and so forth.\nFor the table to be correct, each cell value in the table must satisfy these constraints.\nThe middle magenta line is valid:\nit remains between the two black lines (the redundant +1 or +2 region), so all the cells that need\nto be +1 are +1 and all the cells that need to be +2 are +2, as required.\nLikewise, the bottom magenta line remains between the black lines.\nHowever, the top magenta line is faulty: it must remain above the top black line, but it crosses\nthe black line. The consequence is that some cells that need to be +2 end up holding 0: these are the missing\ncells that caused the FDIV bug.</p>\n<p>Note that the top magenta line stays above the diagonal gray line while following it as closely\nas possible. If the gray line were the correct line, the table would be perfect.\nUnfortunately, Intel picked the wrong constraint line for the table's upper bound when the table was\ngenerated.<span id=\"fnref:bounds\"><a class=\"ref\" href=\"#fn:bounds\">26</a></span></p>\n<p>But why are some diagonal lines lowered by 1/8 and other lines are not lowered?\nAs explained in the previous section, as a consequence of the carry-save adder truncation,\nthe table lookup may end up one cell lower than the actual <em>p</em> value would indicate, i.e. the\n<em>p</em> value for the table index is 1/8 lower than that actual value. \nThus, both the correct cell and the cell below must satisfy the SRT constraints.\nThus, the line moves down if that makes the constraints stricter but does not move down\nif that would expand the redundant area.\nIn particular, the top line must not be move down, but clearly Intel moved the line down and generated the\nfaulty lookup table.</p>\n<!--\nNext, let's look at the design and manufacturing steps between the table and the chip.\nThe lookup table is defined mathematically by the sloping lines that separate its regions.\nThe 2048 cells of the table were assigned according to these lines.\nNext, the table was processed to form the optimized set of PLA entries using the Espresso tool.\nThese entries were loaded into the Pentium's RTL model as well as the layout representation.\nThe layout representation defined the physical layout of the transistors and wiring on the chip.\nThe layout was used to create masks, which were then used to fabricate the integrated circuits.\n\nI don't know all the details of Intel's design automation software, so my list of steps is slightly speculative.\n    -->\n\n<p>Intel, however, has a different explanation for the bug.\nThe Intel white paper states that the problem was in a script that downloaded the table into a PLA: an error caused the script to omit a few entries from the PLA.<span id=\"fnref:script\"><a class=\"ref\" href=\"#fn:script\">27</a></span>\nI don't believe this explanation: the missing terms match a mathematical error, not a copying error.\nI suspect that Intel's statement is technically true but misleading: they ran a C program\n(which they called a script) to generate the table but the program had a mathematical error\nin the bounds.</p>\n<p>In his book \"The Pentium Chronicles\", Robert Colwell, architect of the Pentium Pro, provides\na different explanation of the FDIV bug.\nColwell claims that the Pentium design originally used the same lookup table as the 486,\nbut shortly before release, the engineers were pressured by management to shrink the circuitry to save die space.\nThe engineers optimized the table to make it smaller and\nhad a proof that the optimization would work.\nUnfortunately, the proof was faulty, but the testers trusted the engineers and didn't test the modification thoroughly, causing the Pentium to be released with the bug.\nThe problem with this explanation is that the Pentium was designed from the start with a completely different division algorithm from the 486: the Pentium uses radix-4 SRT, while the 486 uses standard binary division.\nSince the 486 doesn't have a lookup table, the story falls apart.\nMoreover, the PLA could trivially have been made smaller by removing the 8 unused rows, so the engineers clearly weren't trying to shrink it.\nMy suspicion is that since Colwell developed the Pentium Pro in Oregon but the original Pentium was developed in California, Colwell didn't get firsthand information on the Pentium problems.</p>\n<h2>How Intel fixed the bug</h2>\n<p>Intel's fix for the bug was straightforward but also surprising.\nYou'd expect that Intel added the five missing table values to the PLA, and this is what was\nreported at the time.\nThe <a href=\"https://www.nytimes.com/1994/11/24/business/company-news-flaw-undermines-accuracy-of-pentium-chips.html\">New York Times</a> wrote that Intel fixed the flaw by adding several dozen transistors to the chip.\n<a href=\"https://davefaq.com/Opinions/Stupid/Pentium.html\">EE Times</a> wrote that \"The fix entailed adding terms, or additional gate-sequences, to the PLA.\"</p>\n<p>However, the updated PLA (below) shows something entirely different.\nThe updated PLA is exactly the same size as the original PLA. However,\nabout 1/3 of the terms were <em>removed</em> from the PLA, eliminating hundreds of transistors.\nOnly 74 of the PLA's 120 rows are used, and the rest are left empty. (The original PLA had 8 empty rows.)\nHow could removing terms from the PLA fix the problem?</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/new-pla.jpg\"><img alt=\"The updated PLA has 46 unused rows.\" class=\"hilite\" height=\"735\" src=\"https://static.righto.com/images/pentium-fdiv/new-pla-w300.jpg\" title=\"The updated PLA has 46 unused rows.\" width=\"300\" /></a><div class=\"cite\">The updated PLA has 46 unused rows.</div></p>\n<p>The explanation is that\nIntel didn't just fill in the five missing table entries with the correct value of 2.\nInstead, Intel filled <em>all</em> the unused table entries with 2, as shown below.\nThis has two effects.\nFirst, it eliminates any possibility of hitting a mistakenly-empty entry.\nSecond, it makes the PLA equations much simpler.\nYou might think that more entries in the table would make the PLA larger, but the number of\nPLA terms depends on the structure of the data.\nBy filling the unused cells with 2, the jagged borders between the unused regions (white) and the \"2\" regions (yellow) disappear.\nAs explained earlier, a large rectangle can be covered by a single PLA term, but a jagged border requires\na lot of terms.\nThus, the updated PLA is about 1/3 smaller than the original, flawed PLA.\nOne consequence is that the terms in the new PLA are completely different from the terms in the\nold PLA so one can't point to the specific transistors that fixed the bug.</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/old-vs-new.jpg\"><img alt=\"Comparison of the faulty lookup table (left) and the corrected lookup table (right).\" class=\"hilite\" height=\"546\" src=\"https://static.righto.com/images/pentium-fdiv/old-vs-new-w400.jpg\" title=\"Comparison of the faulty lookup table (left) and the corrected lookup table (right).\" width=\"400\" /></a><div class=\"cite\">Comparison of the faulty lookup table (left) and the corrected lookup table (right).</div></p>\n<p>The image below shows the first 14 rows of the faulty PLA and the first 14 rows of the fixed PLA. As you can\nsee, the transistor pattern (and thus the PLA terms) are entirely different.\nThe doped silicon is darkened in the second image due to differences in how I processed the dies to remove\nthe metal layers.</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/comparison.jpg\"><img alt=\"Top of the faulty PLA (left) and the fixed PLA (right). The metal layers were removed to show the silicon of the transistors. (Click for a larger image.)\" class=\"hilite\" height=\"301\" src=\"https://static.righto.com/images/pentium-fdiv/comparison-w700.jpg\" title=\"Top of the faulty PLA (left) and the fixed PLA (right). The metal layers were removed to show the silicon of the transistors. (Click for a larger image.)\" width=\"700\" /></a><div class=\"cite\">Top of the faulty PLA (left) and the fixed PLA (right). The metal layers were removed to show the silicon of the transistors. (Click for a larger image.)</div></p>\n<h2>Impact of the FDIV bug</h2>\n<p>How important is the Pentium bug? This became a highly controversial topic.\nA failure of a random division operation is very rare: about one in 9 billion values will trigger the bug.\nMoreover, an erroneous division is still mostly accurate: the error is usually in the 9th or 10th decimal\ndigit, with rare worst-case error in the 4th significant digit.\nIntel's <a href=\"https://www.ardent-tool.com/CPU/Intel/fdiv/white11.pdf\">whitepaper</a> claimed that a typical user would encounter a problem once every 27,000 years, insignificant compared to other sources of error such as DRAM bit flips.\nIntel said: \"Our overall conclusion is that the flaw in the floating point unit of the Pentium processor is of no concern to the vast majority of users.\nA few users of applications in the scientific/engineering and financial engineering fields may need to employ either an updated processor without the flaw or a software workaround.\"</p>\n<p>However, IBM performed their own analysis,<span id=\"fnref:ibm\"><a class=\"ref\" href=\"#fn:ibm\">29</a></span> suggesting that the problem could hit customers every few days, and IBM suspended Pentium sales. (Coincidentally, IBM had a competing processor, the PowerPC.)\nThe battle made it to major newspapers; the Los Angeles Times split the difference with <a href=\"https://www.latimes.com/archives/la-xpm-1994-12-17-fi-9948-story.html\">Study Finds Both IBM, Intel Off on Error Rate</a>.\nIntel soon gave in and agreed to replace all the Pentiums, making the issue moot.</p>\n<p>I mostly agree with Intel's analysis. It appears that only one person (Professor Nicely) noticed the bug\nin actual use.<span id=\"fnref:legends\"><a class=\"ref\" href=\"#fn:legends\">28</a></span>\nThe IBM analysis seems contrived to hit numbers that trigger the error.\nMost people would never hit the bug and even if they hit it, a small degradation in floating-point accuracy is unlikely to matter to most people.\nLooking at society as a whole, replacing the Pentiums was a huge expense for minimal gain.\nOn the other hand, it's reasonable for customers to expect an accurate processor.</p>\n<p>Note that the Pentium bug is deterministic: if you use a specific divisor and dividend that trigger the problem,\nyou will get the wrong answer 100% of the time.\nPentium engineer Ken Shoemaker suggested that the outcry over the bug was because it was so easy for\ncustomers to reproduce.\nIt was hard for Intel to argue that customers would never encounter the bug when customers could trivially\nsee the bug on their own computer, even if the situation was artificial.</p>\n<h2>Conclusions</h2>\n<p>The FDIV bug is one of the most famous processor bugs.\nBy examining the die, it is possible to see exactly where it is on the chip.\nBut Intel has had other important bugs.\nSome early 386 processors had a 32-bit multiply problem.\nUnlike the deterministic FDIV bug, the 386 would unpredictably produce the wrong results under particular temperature/voltage/frequency conditions.\nThe underlying issue was a layout problem that didn't provide enough electrical margin to handle the worst-case situation.\nIntel sold the faulty chips but restricted them to the 16-bit market; bad chips were labeled \"16 BIT S/W ONLY\", while the good processors were marked with a double sigma.\n Although Intel had to suffer through embarrassing headlines such as <a href=\"https://archive.org/details/bub_gb_mDsEAAAAMBAJ/page/n5/mode/1up?view=theater\">Some 386 Systems Won't Run 32-Bit Software, Intel Says</a>, the bug was soon forgotten.</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/steppings.jpg\"><img alt=\"Bad and good versions of the 386. Note the labels on the bottom line. Photos (L), (R) by Thomas Nguyen, (CC BY-SA 4.0)\" class=\"hilite\" height=\"205\" src=\"https://static.righto.com/images/pentium-fdiv/steppings-w400.jpg\" title=\"Bad and good versions of the 386. Note the labels on the bottom line. Photos (L), (R) by Thomas Nguyen, (CC BY-SA 4.0)\" width=\"400\" /></a><div class=\"cite\">Bad and good versions of the 386. Note the labels on the bottom line. Photos (<a href=\"https://commons.wikimedia.org/wiki/File:Intel_A80386-16_16_bit_SW_Only.jpg\">L</a>), (<a href=\"https://commons.wikimedia.org/wiki/File:Intel_A80386-16_%CE%A3%CE%A3.jpg\">R</a>) by Thomas Nguyen, (<a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.en\">CC BY-SA 4.0</a>)</div></p>\n<p>Another memorable Pentium issue was the \"F00F bug\", a problem where a particular instruction sequence starting with F0 0F would cause the processor to lock up until rebooted.<span id=\"fnref:f00f\"><a class=\"ref\" href=\"#fn:f00f\">30</a></span>\nThe bug was found in 1997 and solved with an operating system update.\nThe bug is presumably in the Pentium's voluminous microcode. The microcode is too complex for me to analyze,\nso don't expect a detailed blog post on this subject. :-)</p>\n<p>You might wonder why Intel needed to release a new revision of the Pentium to fix the FDIV bug, rather than just updating the microcode.\nThe problem was that microcode for the Pentium (and earlier processors) was hard-coded into a ROM and couldn't be modified.\nIntel added patchable microcode to the Pentium Pro (1995), allowing limited modifications to the microcode.\nIntel originally implemented this feature for chip debugging and testing.\nBut after the FDIV bug, Intel realized that patchable microcode was valuable for bug fixes too.<span id=\"fnref:patchable\"><a class=\"ref\" href=\"#fn:patchable\">31</a></span>\nThe Pentium Pro stores microcode in ROM, but it also has a static RAM that holds up to 60 microinstructions.\nDuring boot, the BIOS can load a microcode patch into this RAM.\nIn modern Intel processors, microcode patches have been used for problems ranging from the <a href=\"https://support.microsoft.com/en-us/topic/kb4090007-intel-microcode-updates-3bdf784b-d4ad-d881-cfc1-658095b59638\">Spectre</a> vulnerability to <a href=\"https://community.intel.com/t5/Processors/Microcode-0x129-Update-for-Intel-Core-13th-and-14th-Gen-Desktop/m-p/1622129\">voltage problems</a>.</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/pla-m2.jpg\"><img alt=\"The Pentium PLA with the top metal layer removed, revealing the M2 and M1 layers. The OR and AND planes are at the top and bottom, with drivers and control logic in the middle.\" class=\"hilite\" height=\"872\" src=\"https://static.righto.com/images/pentium-fdiv/pla-m2-w250.jpg\" title=\"The Pentium PLA with the top metal layer removed, revealing the M2 and M1 layers. The OR and AND planes are at the top and bottom, with drivers and control logic in the middle.\" width=\"250\" /></a><div class=\"cite\">The Pentium PLA with the top metal layer removed, revealing the M2 and M1 layers. The OR and AND planes are at the top and bottom, with drivers and control logic in the middle.</div></p>\n<p>As the number of transistors in a processor increased exponentially, as described by Moore's Law,\nprocessors used more complex circuits and algorithms. Division is one example.\nEarly microprocessors such as the Intel 8080 (1974, 6000 transistors) had no hardware support for\ndivision or floating point arithmetic. The Intel 8086 (1978, 29,000 transistors) implemented integer division\nin microcode but required the 8087 coprocessor chip for floating point. The Intel 486 (1989, 1.2 million transistors) added floating-point support on the chip.\nThe Pentium (1993, 3.1 million transistors) moved to the\nfaster but more complicated SRT division algorithm.\nThe Pentium's division PLA alone has roughly 4900 transistor sites, more than a MOS Technology 6502 processor&mdash;one component of the Pentium's division circuitry uses more transistors than an entire 1975 processor.</p>\n<p>The long-term effect of the FDIV bug on Intel is a subject of debate.\nOn the one hand, competitors such as AMD benefitted from Intel's error.\nAMD's <a href=\"https://bsky.app/profile/trevorkevorson.bsky.social/post/3lcnv6h65hc26\">ads</a> poked fun at the Pentium's problems by listing features of AMD's chips such as \"You don't have to double check your math\" and \"Can actually handle the rigors of complex calculations like <em>division</em>.\"\nOn the other hand, Robert Colwell, architect of the Pentium Pro, said that the FDIV bug may have been a net benefit to Intel as it created enormous name recognition for the Pentium, along with a demonstration that Intel was willing to back up its brand name.\nIndustry writers agreed; see <a href=\"https://websrv.cecs.uci.edu/~papers/mpr/MPR/EDITOR/0903ed.pdf\">The Upside of the Pentium Bug</a>.\nIn any case, Intel survived the FDIV bug; time will tell how Intel survives its current problems.</p>\n<p>I plan to write more about the implementation of the Pentium's PLA, the adder, and the test circuitry. Until then, \nyou may enjoy reading about the <a href=\"https://www.righto.com/2024/08/pentium-navajo-fairchild-shiprock.html\">Pentium Navajo rug</a>.\n(The rug represents the P54C variant of the Pentium, so it is safe from the FDIV bug.)\nThanks to Bob Colwell and Ken Shoemaker for helpful discussions.</p>\n<h1>Footnotes and references</h1>\n<div class=\"footnote\">\n<ol>\n<li id=\"fn:dham\">\n<p>The book <a href=\"https://amzn.to/4gcXzVS\">Inside Intel</a> says that Vin Dham, the \"Pentium czar\", found the FDIV problem in May 1994.\nThe book \"The Pentium Chronicles\" says that Patrice Roussel, the floating-point architect for Intel's upcoming Pentium Pro processor, found the FDIV problem in Summer 1994.\nI suspect that the bug was kept quiet inside Intel and was discovered more than once.&#160;<a class=\"footnote-backref\" href=\"#fnref:dham\" title=\"Jump back to footnote 1 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:prime\">\n<p>The divisor being a prime number has nothing to do with the bug. It's just a coincidence that the problem was found during research with prime numbers.&#160;<a class=\"footnote-backref\" href=\"#fnref:prime\" title=\"Jump back to footnote 2 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:timeline\">\n<p>See Nicely's <a href=\"https://faculty.lynchburg.edu/~nicely/#PENT\">FDIV page</a> for more information on the bug and its history.\nOther sources are the books <a href=\"https://amzn.to/4gAD1pM\">Creating the Digital Future</a>, <a href=\"https://amzn.to/4gl8mx9\">The Pentium Chronicles</a>, and <a href=\"https://amzn.to/4gcXzVS\">Inside Intel</a>.\nThe New York Times wrote about the bug: <a href=\"https://www.nytimes.com/1994/11/24/business/company-news-flaw-undermines-accuracy-of-pentium-chips.html\">Flaw Undermines Accuracy of Pentium Chips</a>.\nComputerworld wrote <a href=\"https://books.google.com/books?id=LbKf4ilmW8EC&amp;pg=PA1\">Intel Policy Incites User Threats</a> on threats of a class-action lawsuit.\nIBM's response is described in <a href=\"https://www.nytimes.com/1994/12/13/us/ibm-deals-blow-to-a-rival-as-it-suspends-pentium-sales.html\">IBM Deals Blow to a Rival as it Suspends Pentium Sales</a>&#160;<a class=\"footnote-backref\" href=\"#fnref:timeline\" title=\"Jump back to footnote 3 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:letterman\">\n<p>Talk show host David Letterman <a href=\"http://lists.sigcis.org/pipermail/members-sigcis.org/2020-August/007088.html\">joked</a> about the Pentium on <a href=\"https://groups.google.com/g/comp.sys.intel/c/xivOgqcUrS8/m/sODzYaJZzWMJ\">December 15</a>: \"You know what goes great with those defective Pentium chips? Defective Pentium salsa!\" Although a list of Letterman-style <a href=\"https://groups.google.com/g/aus.jokes/c/72sZitg-bTY/m/LCMN-LRD6egJ\">top ten Pentium slogans</a> circulated, the list was a Usenet creation.\nThere's a <a href=\"https://historyofcomputers.eu/hardware/the-pentium-fdiv-bug-when-math-became-a-stand-up-comedy-act/\">claim</a> that Jay Leno also joked about the Pentium, but I haven't found verification.&#160;<a class=\"footnote-backref\" href=\"#fnref:letterman\" title=\"Jump back to footnote 4 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:errata\">\n<p>Processors have many more bugs than you might expect.\nIntel's 1995 errata list for the Pentium had \"21 errata (including the FDIV problem), 4 changes, 16 clarifications, and 2 documentation changes.\" See <a href=\"https://ardent-tool.com/CPU/docs/Intel/Pentium/spec_update/242480-022.pdf\">Pentium Processor Specification Update</a> and <a href=\"https://websrv.cecs.uci.edu/~papers/mpr/MPR/ARTICLES/090303.pdf\">Intel Releases Pentium Errata List</a>.&#160;<a class=\"footnote-backref\" href=\"#fnref:errata\" title=\"Jump back to footnote 5 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:apology\">\n<p>Intel published full-page newspaper ads apologizing for its handling of the problem, stating: \"What Intel continues to believe is an extremely minor technical problem has taken on a life of its own.\"</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/apology.jpg\"><img alt=\"Intel's apology letter, published in Financial Times. Note the UK country code in the phone number.\" class=\"hilite\" height=\"771\" src=\"https://static.righto.com/images/pentium-fdiv/apology-w500.jpg\" title=\"Intel's apology letter, published in Financial Times. Note the UK country code in the phone number.\" width=\"500\" /></a><div class=\"cite\">Intel's apology letter, published in <a href=\"https://archive.org/details/FinancialTimes1994UKEnglish/Dec%2022%201994%2C%20Financial%20Times%2C%20%2322%2C%20UK%20%28en%29/page/n4/mode/1up\">Financial Times</a>. Note the UK country code in the phone number.</div></p>\n<p><!-- -->&#160;<a class=\"footnote-backref\" href=\"#fnref:apology\" title=\"Jump back to footnote 6 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:coe\">\n<p>Tim Coe's reverse engineering of the Pentium divider was described on the Usenet group <a href=\"https://groups.google.com/g/comp.sys.intel/c/L1KDE1d_ZLA/m/7rydJksrVTcJ\">comp.sys.intel</a>, archived <a href=\"https://daviddeley.com/pentbug/tim_coe.txt\">here</a>.\nTo summarize, Andreas Kaiser found 23 failing reciprocals.\nTim Coe determined that most of these failing reciprocals were of the form 3*(2^(K+30)) - 1149*(2^(K-(2*J))) - delta*(2^(K-(2*J))).\nHe recognized that the factor of 2 indicated a radix-4 divider.\nThe extremely low probability of error indicated the presence of a carry save adder; the odds of both the sum and carry bits getting long patterns of ones were very low.\nCoe constructed a simulation of the divider that matched the Pentium's behavior and noted which table entries must be faulty.&#160;<a class=\"footnote-backref\" href=\"#fnref:coe\" title=\"Jump back to footnote 7 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:papers\">\n<p>The main papers on the FDIV bug are <a href=\"https://people.cs.vt.edu/~naren/Courses/CS3414/assignments/pentium.pdf\">Computational Aspects of the Pentium Affair</a>, <a href=\"https://doi.org/10.1109/ARITH.1995.465365\">It Takes Six Ones to Reach a Flaw</a>,\n<a href=\"https://www.jstor.org/stable/2133004\">The Mathematics of the Pentium Division Bug</a>, <a href=\"https://web.archive.org/web/20060209005434/http://www.byte.com/art/9503/sec13/art1.htm\">The Truth Behind the Pentium Bug</a>,  <a href=\"http://link.springer.com/10.1007/3-540-59293-8_189\">Anatomy of the Pentium Bug</a>, and <a href=\"http://boole.stanford.edu/pentium.html\">Risk Analysis of the Pentium Bug</a>.\nIntel's whitepaper is <a href=\"https://www.ardent-tool.com/CPU/Intel/fdiv/white11.pdf\">Statistical Analysis of Floating Point Flaw in the Pentium Processor</a>; I archived IBM's study <a href=\"https://righto.com/files/IBM_study.txt\">here</a>.&#160;<a class=\"footnote-backref\" href=\"#fnref:papers\" title=\"Jump back to footnote 8 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:ieee754\">\n<p>The Pentium uses floating point numbers that follow the IEEE 754 standard.\nInternally, floating point numbers are represented with 80 bits: 1 bit for the sign, 15 bits for the exponent, and 64 bits for the significand.\nExternally, floating point numbers are 32-bit single-precision numbers or 64-bit double-precision numbers.\nNote that the number of significand bits limits the accuracy of a floating-point number.&#160;<a class=\"footnote-backref\" href=\"#fnref:ieee754\" title=\"Jump back to footnote 9 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:srt-history\">\n<p>The SRT division algorithm is named after the three people who independently created it in 1957-1958: Sweeney at IBM, Robertson at the University of Illinois, and Tocher at Imperial College London.\nThe SRT algorithm was developed further by Atkins in his <a href=\"https://www.osti.gov/biblio/4157138\">PhD research</a> (1970).</p>\n<p>The SRT algorithm became more practical in the 1980s as chips became denser.\nTaylor <a href=\"https://www.doi.org/10.1109/ARITH.1981.6159293\">implemented</a> the SRT algorithm on a board with 150 chips in 1981. The IEEE floating point standard (1985) led to a market for faster floating point circuitry.\nFor instance, the Weitek 4167 floating-point coprocessor chip (1989) was designed for use with the Intel 486 CPU (<a href=\"http://www.bitsavers.org/components/weitek/dataSheets/4167_Floating-Point_Coprocessor_Jul89.pdf\">datasheet</a>)\nand described in <a href=\"https://www.ece.ucdavis.edu/~vojin/CLASSES/EPFL/Papers/4-Fandrianto_division_ARITH8.pdf\">an influential paper</a>.\nAnother important SRT implementation is the MIPS R3010 (1988), the coprocessor for the R3000 RISC processor.\nThe MIPS R3010 uses radix-4 SRT for division with 9 bits from the partial remainder and 9 bits from the divisor, making for a larger lookup table and adder than the Pentium\n(<a href=\"https://doi.org/10.1109/40.540\">link</a>).</p>\n<p>To summarize, when Intel wanted to\nmake division faster on the Pentium (1993), the SRT algorithm was a reasonable choice.\nCompetitors had already implemented SRT and multiple papers explained how SRT worked.\nThe implementation should have been straightforward and bug-free.&#160;<a class=\"footnote-backref\" href=\"#fnref:srt-history\" title=\"Jump back to footnote 10 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:dimensions\">\n<p>The dimensions of the lookup table can't be selected arbitrarily.\nIn particular, if the table is too small, a cell may need to hold two different q values, which isn't possible.\nNote that constructing the table is only possible due to the redundancy of SRT.\nFor instance, if some values in the call require q=1 and other values require q=1 or 2, then the value q=1 can be assigned to the cell.&#160;<a class=\"footnote-backref\" href=\"#fnref:dimensions\" title=\"Jump back to footnote 11 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:intel-pla\">\n<p>In the white paper, Intel calls the PLA a Programmable Lookup Array, but that's an error; it's a Programmable <em>Logic</em> Array.&#160;<a class=\"footnote-backref\" href=\"#fnref:intel-pla\" title=\"Jump back to footnote 12 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:pla\">\n<p>I'll explain a PLA in a bit more detail in this footnote.\nAn example of a sum-of-products formula with inputs a and b is ab' + a'b + ab.\nThis formula has three sum terms, so it requires three rows in the PLA.\nHowever, this formula can be reduced to a + b, which uses a smaller two-row PLA.\nNote that any formula can be trivially expressed with a\nseparate product term for each 1 output in the truth table.\nThe hard part is optimizing the PLA to use fewer terms. The original PLA patent is probably <a href=\"https://patents.google.com/patent/US3702985A\">MOS Transistor Integrated Matrix</a> from 1969.&#160;<a class=\"footnote-backref\" href=\"#fnref:pla\" title=\"Jump back to footnote 13 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:rom\">\n<p>A ROM and a PLA have many similarities.\nYou can implement a ROM with a PLA by using the AND terms to decode addresses and the OR terms to hold the data.\nAlternatively, you can replace a PLA with a ROM by putting the function's truth table into the ROM.\nROMs are better if you want to hold arbitrary data that doesn't have much structure (such as the microcode ROMs).\nPLAs are better if the functions have a lot of underlying structure.\nThe key theoretical difference between a ROM and a PLA is that a ROM activates exactly one row at a time, corresponding to the address, while a PLA may activate one row, no rows, or multiple rows at a time.\nAnother alternative for representing functions is to use logic gates directly (known as random logic); moving from the 286 to the 386, Intel replaced many small PLAs with logic gates, enabled by improvements in the standard-cell software.\nIntel's design process is described in <a href=\"https://www.researchgate.net/publication/268005718_Coping_with_the_Complexity_of_Microprocessor_Design_at_Intel_-_A_CAD_History\">Coping with the Complexity of Microprocessor Design</a>.&#160;<a class=\"footnote-backref\" href=\"#fnref:rom\" title=\"Jump back to footnote 14 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:espresso\">\n<p>In 1982, Intel developed a program called LOGMIN to automate PLA design.  The original LOGMIN used an\nexhaustive exponential search, limiting its usability.\nSee <a href=\"https://doi.org/10.1109/DAC.1982.1585495\">A Logic Minimizer for VLSI PLA Design</a>.\nFor the <a href=\"https://www.youtube.com/watch?v=LQcLhBZY12g&amp;t=1700s\">386</a>, Intel used <a href=\"https://en.wikipedia.org/wiki/Espresso_heuristic_logic_minimizer\">Espresso</a>, a heuristic PLA minimizer that originated at IBM and was\ndeveloped at UC Berkeley.\nIntel probably used Espresso for the Pentium, but I can't confirm that.&#160;<a class=\"footnote-backref\" href=\"#fnref:espresso\" title=\"Jump back to footnote 15 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:split\">\n<p>The Pentium's PLA is split into a top half and a bottom half, so you might expect the top half would generate a quotient of 1 and the bottom half would generate a quotient of 2.\nHowever, the rows for the two quotients are shuffled together with no apparent pattern.\nI suspect that the PLA minimization software generated the order arbitrarily.&#160;<a class=\"footnote-backref\" href=\"#fnref:split\" title=\"Jump back to footnote 16 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:demorgan\">\n<p>Conceptually, the PLA consists of AND gates feeding into OR gates.\nTo simplify the implementation, both layers of gates are actually NOR gates.\nSpecifically, if any transistor in a row turns on, the row will be pulled to ground, producing\na zero.\nDe Morgan's laws show that the two approaches are the same, if you invert the inputs and outputs.\nI'm ignoring this inversion in the diagrams.</p>\n<p>Note that each square can form a transistor on the left, the right, or both.\nThe image must be examined closely to distinguish these cases. \nSpecifically, if the polysilicon line produces a transistor, horizontal lines are visible in\nthe polysilicon. If there are no horizontal lines, the polysilicon passes by without creating\na transistor.&#160;<a class=\"footnote-backref\" href=\"#fnref:demorgan\" title=\"Jump back to footnote 17 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:outputs\">\n<p>Each OR plane has four outputs, so there are eight outputs in total. These outputs are\ncombined\nwith logic gates to generate the desired two outputs (quotient of 1 or 2).\nI'm not sure why the PLA is implemented in this fashion.\nEach row alternates between an output on the left and an output on the right, but I don't\nthink this makes the layout any denser.\nAs far as I can tell, the extra outputs just waste space.\nOne could imagine combining the outputs in a clever way to reduce the number of terms, but\ninstead the outputs are simply OR'd together.&#160;<a class=\"footnote-backref\" href=\"#fnref:outputs\" title=\"Jump back to footnote 18 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:chaos\">\n<p>The dynamics of the division algorithm are interesting.\nThe computation of a particular division will result in the partial remainder bouncing from\ntable cell to table cell, while remaining in one column of the table.\nI expect this could be analyzed in terms of chaotic dynamics.\nSpecifically, the partial remainder interval is squished down by the subtraction and then\nexpanded when multiplied by 4.\nThis causes low-order bits to percolate upward so the result is exponentially sensitive to initial conditions.\nI think that the division behavior satisfies the definition of chaos in <a href=\"https://mathscinet.ams.org/mathscinet/relay-station?mr=1010233\">Dynamics of Simple Maps</a>, but I haven't investigated this in detail.</p>\n<p>You can see this chaotic behavior with a base-10 division, e.g.\ncompare 1/3.0001 to 1/3.0002:\n<br /><code>1/3.0001=0.333322222592580247325089163694543515216...\n1/3.0002=0.333311112592493833744417038864075728284...</code><br />\nNote that the results start off the same but are completely divergent by 15 digits.\n(The division result itself isn't chaotic, but the sequence of digits is.)</p>\n<p>I tried to make a fractal out of the SRT algorithm and came up with the image below. There\nare 5 bands for convergence, each made up of 5 sub-bands, each made up of 5 sub-sub bands, and so on, corresponding to the 5 q values.</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/fractal.jpg\"><img alt=\"A fractal showing convergence or divergence of SRT division as the scale factor (X-axis) ranges from the normal value of 4 to infinity. The Y-axis is the starting partial remainder. The divisor is (arbitrarily) 1.5. Red indicates convergence; gray is darker as the value diverges faster.\" class=\"hilite\" height=\"500\" src=\"https://static.righto.com/images/pentium-fdiv/fractal-w500.jpg\" title=\"A fractal showing convergence or divergence of SRT division as the scale factor (X-axis) ranges from the normal value of 4 to infinity. The Y-axis is the starting partial remainder. The divisor is (arbitrarily) 1.5. Red indicates convergence; gray is darker as the value diverges faster.\" width=\"500\" /></a><div class=\"cite\">A fractal showing convergence or divergence of SRT division as the scale factor (X-axis) ranges from the normal value of 4 to infinity. The Y-axis is the starting partial remainder. The divisor is (arbitrarily) 1.5. Red indicates convergence; gray is darker as the value diverges faster.</div></p>\n<p><!-- -->&#160;<a class=\"footnote-backref\" href=\"#fnref:chaos\" title=\"Jump back to footnote 19 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:bound\">\n<p>The algebra behind the bound of 8/3 is that <em>p</em> (the partial remainder) needs to be in an interval that stays the same size each step.\nEach step of division computes <em>p<sub>new</sub> =  (p<sub>old</sub> - q*d)*4</em>.\nThus, at the boundary, with <em>q=2</em>, you have <em>p = (p-2*d)*4</em>, so <em>3p=8d</em> and thus <em>p/d</em> = 8/3.\nSimilarly, the other boundary, with <em>q=-2</em>, gives you <em>p/d</em> = -8/3.&#160;<a class=\"footnote-backref\" href=\"#fnref:bound\" title=\"Jump back to footnote 20 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:8bit\">\n<p>I'm not completely happy with the 8-bit carry-lookahead adder.\nCoe's mathematical analysis in 1994 showed that the carry-lookahead adder operates on 7 bits.\nThe adder in the Pentium has two 8-bit inputs connected to another part of the division circuit.\nHowever, the adder's bottom output bit is not connected to anything.\nThat would suggest that the adder is adding 8 bits and then truncating to 7 bits, which would\nreduce the truncation error compared to a 7-bit adder.\nHowever, when I simulate the division algorithm this way, the FDIV bug doesn't occur.\nWiring the bottom input bits to 0 would explain the behavior, but that seems pointless.\nI haven't examined the circuitry that feeds the adder, so I don't have a conclusive answer.&#160;<a class=\"footnote-backref\" href=\"#fnref:8bit\" title=\"Jump back to footnote 21 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:testing\">\n<p>Half of the circuitry in the adder block is used to test the lookup table.\nThe reason is that\na chip such as the Pentium is very difficult to test: if one out of 3.1 million transistors goes bad, how do you detect it?  For a simple processor like the 8080, you can run through the instruction set and be fairly confident that any problem would turn up.\nBut with a complex chip, it\nis almost impossible to come up with an instruction sequence that would test every bit of the microcode ROM, every bit of the cache, and so forth.\nStarting with the 386, Intel added circuitry to the processor solely to make testing easier; about 2.7% of the transistors in the 386 were for testing.</p>\n<p>To test a ROM inside the processor, Intel added circuitry to scan the entire ROM and checksum its contents.\nSpecifically, a pseudo-random number generator runs through each address, while another circuit computes a checksum of the ROM output, forming a \"signature\" word.\nAt the end, if the signature word has the right value, the ROM is almost certainly correct.\nBut if there is even a single bit error, the checksum will be wrong and the chip will be rejected.\nThe pseudo-random numbers and the checksum are both implemented with linear feedback shift registers (LFSR), a shift register along with a few XOR gates to feed the output back to the input.\nFor more information on testing circuitry in the 386, see <a href=\"https://doi.org/10.1109/MDT.1987.295165\">Design and Test of the 80386</a>,\nwritten by Pat Gelsinger, who became Intel's CEO years later.\nEven with the test circuitry, 48% of the transistor sites in the 386 were untested.\nThe instruction-level test suite to test the remaining circuitry took almost 800,000 clock cycles to run.\nThe overhead of the test circuitry was about 10% more transistors in the blocks that were tested.</p>\n<p>In the Pentium, the circuitry to test the lookup table PLA is just below the 7-bit adder.\nAn 11-bit LFSR creates the 11-bit input value to the lookup table.\nA 13-bit LFSR hashes the two-bit quotient result from the PLA, forming a 13-bit checksum.\nThe checksum is fed serially to test circuitry elsewhere in the chip, where it is merged with\nother test data and written to a register. If the register is 0 at the end, all the tests pass.\nIn particular, if the checksum is correct, you can be 99.99% sure that the lookup table\nis operating as expected.\nThe ironic thing is that this test circuit was useless for the FDIV bug: it ensured that the lookup table held the intended values, but the intended values were wrong.</p>\n<p>Why did Intel generate test addresses with a pseudo-random sequence instead of a sequential\ncounter?\nIt turns out that a linear feedback shift register (LFSR) is slightly more compact than a\ncounter.\nThis LFSR trick was also used in a <a href=\"https://www.righto.com/2017/08/inside-fake-ram-chip-i-found-something.html\">touch-tone chip</a> and the program counter of the Texas Instruments TMS 1000 microcontroller (1974).\nIn the TMS 1000, the program counter steps through the\nprogram pseudo-randomly rather than sequentially.\nThe program is shuffled appropriately in the ROM to counteract the\nsequence, so the program executes as expected and a few transistors are saved.&#160;<a class=\"footnote-backref\" href=\"#fnref:testing\" title=\"Jump back to footnote 22 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:bicmos\">\n<p>One unusual feature of the Pentium is that it uses BiCMOS technology: both bipolar and CMOS transistors.\nNote the distinctive square boxes in the driver circuitry; these are bipolar transistors, part of the high-speed drivers.</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/bipolar.jpg\"><img alt=\"Three bipolar transistors. These transistors transmit the quotient to the rest of\nthe division circuitry.\" class=\"hilite\" height=\"269\" src=\"https://static.righto.com/images/pentium-fdiv/bipolar-w350.jpg\" title=\"Three bipolar transistors. These transistors transmit the quotient to the rest of\nthe division circuitry.\" width=\"350\" /></a><div class=\"cite\">Three bipolar transistors. These transistors transmit the quotient to the rest of\nthe division circuitry.</div></p>\n<p><!-- -->&#160;<a class=\"footnote-backref\" href=\"#fnref:bicmos\" title=\"Jump back to footnote 23 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:64-bits\">\n<p>I think the partial remainder is actually 67 bits because there are three extra bits\nto handle rounding. Different parts of the floating-point datapath have different widths, depending on\nwhat width is needed at that point.&#160;<a class=\"footnote-backref\" href=\"#fnref:64-bits\" title=\"Jump back to footnote 24 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:heatmaps\">\n<p>In this long footnote, I'll attempt to explain why the FDIV bug is so rare, using heatmaps.\nMy analysis of Intel's lookup table shows several curious factors that almost cancel out, making failures rare but not impossible.\n(For a rigorous explanation, see <a href=\"https://doi.org/10.1109/ARITH.1995.465365\">It Takes Six Ones to Reach a Flaw</a> and \n<a href=\"https://www.jstor.org/stable/2133004\">The Mathematics of the Pentium Division Bug</a>.\nThese papers explain that, among other factors, a bad divisor must have six consecutive ones in positions 5 through 10 and\nthe division process must go through nine specific steps, making a bad result extremely uncommon.)</p>\n<p>The diagram below shows a heatmap of how often each table cell is accessed when simulating\na generic SRT algorithm with a carry-save adder.\nThe black lines show the boundaries of the quotient regions in the Pentium's lookup table.\nThe key point is that the top colored cell in each column is above the black line, so some table cells\nare accessed but are not defined in the Pentium.\nThis shows that the Pentium is missing 16 entries, not just the 5 entries that are usually discussed.\n(For this simulation, I generated the\nquotient digit directly from the SRT bounds, rather than the lookup table, selecting the digit randomly in the redundant regions.)</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/statsn-c-b-18.jpg\"><img alt=\"A heatmap showing the table cells accessed by an SRT simulation.\" class=\"hilite\" height=\"421\" src=\"https://static.righto.com/images/pentium-fdiv/statsn-c-b-18-w350.jpg\" title=\"A heatmap showing the table cells accessed by an SRT simulation.\" width=\"350\" /></a><div class=\"cite\">A heatmap showing the table cells accessed by an SRT simulation.</div></p>\n<p>The diagram is colored with a logarithmic color scale. The blue cells are accessed\napproximately uniformly. The green cells at the boundaries are accessed about 2 orders of\nmagnitude less often. The yellow-green cells are accessed about 3 orders of magnitude less\noften. The point is that it is hard to get to the edge cells since you need to start in\nthe right spot and get the right quotient digit, but it's not extraordinarily hard.</p>\n<p>(The diagram also shows an interesting but ultimately unimportant feature of the Pentium table:\nat the bottom of the diagram, five white cells are above the back line.\nThis shows that the Pentium assigns values to five table cells that can't be accessed.\n(This was also mentioned in \"The Mathematics of the Pentium Bug\".)\nThese cells are in the same columns as the 5 missing cells, so it would be interesting if\nthey were related to the missing cells. But as far as I can tell, the extra cells are due\nto using a bound of \"greater or equals\" rather than \"greater\", unrelated to the\nmissing cells. In any case, the extra cells are harmless.)</p>\n<p>The puzzling factor is that if the Pentium table has 16 missing table cells,\nand the SRT uses these cells fairly often, you'd expect maybe 1 division out of 1000 or so to\nbe wrong. So why are division errors extremely rare?</p>\n<p>It turns out that the structure of the Pentium lookup table makes some table cells inaccessible.\nSpecifically, the table is arbitrarily biased to pick the higher quotient digit rather than the lower\nquotient digit in the redundant regions.\nThis has the effect of subtracting more from the partial remainder, pulling the partial remainder\naway from the table edges.\nThe diagram below shows a simulation using the Pentium's lookup table and\nno carry-save adder.\nNotice that many cells inside the black lines are white,\nindicating that they are never accessed.\nThis is by coincidence, due to arbitrary decisions when constructing in the lookup table.\nImportantly, the missing cells just above the black line are never accessed, so the missing cells\nshouldn't cause a bug.</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/statsn-p-18.jpg\"><img alt=\"A heatmap showing the table cells accessed by an SRT simulation using the Pentium's lookup table but no carry-save adder.\" class=\"hilite\" height=\"422\" src=\"https://static.righto.com/images/pentium-fdiv/statsn-p-18-w350.jpg\" title=\"A heatmap showing the table cells accessed by an SRT simulation using the Pentium's lookup table but no carry-save adder.\" width=\"350\" /></a><div class=\"cite\">A heatmap showing the table cells accessed by an SRT simulation using the Pentium's lookup table but no carry-save adder.</div></p>\n<p>Thus, Intel almost got away with the missing table entries. Unfortunately, the carry-save\nadder makes it possible to reach some of the otherwise inaccessible cells. Because the output from\nthe carry-save adder is truncated, the algorithm can access the table cell below the\n\"right\" cell. In the redundant regions, this can yield a different (but still valid) quotient\ndigit, causing the next partial remainder to end up in a different cell than usual.\nThe heatmap below shows the results.</p>\n<p><a href=\"https://static.righto.com/images/pentium-fdiv/statsn-c-p-merge.jpg\"><img alt=\"A heatmap showing the probability of ending up in each table cell when using the Pentium's division algorithm.\" class=\"hilite\" height=\"419\" src=\"https://static.righto.com/images/pentium-fdiv/statsn-c-p-merge-w350.jpg\" title=\"A heatmap showing the probability of ending up in each table cell when using the Pentium's division algorithm.\" width=\"350\" /></a><div class=\"cite\">A heatmap showing the probability of ending up in each table cell when using the Pentium's division algorithm.</div></p>\n<p>In particular, five cells above the black line can be reached: these are instances of the\nFDIV bug. These cells are orange, indicating that they are about 9 orders of magnitude less\nlikely than the rest of the cells.\nIt's almost impossible to reach these cells, requiring multiple \"unlucky\" values in a row from\nthe carry-save adder.\nTo summarize, the Pentium lookup table has 16 missing cells. Purely by coincidence, the choices\nin the lookup table make many cells inaccessible, which almost counteracts the problem. However,\nthe carry-save adder provides a one-in-a-billion path to five of the missing cells, triggering\nthe FDIV bug.</p>\n<p>One irony is that if division errors were more frequent, Intel would have caught the FDIV bug before shipping.\nBut if division errors were substantially less frequent, no customers would have noticed the bug.\nInconveniently, the frequency of errors fell into the intermediate zone: errors were too rare for Intel to spot them, but frequent enough for a single user to spot them.\n(This makes me wonder what other astronomically infrequent errors may be lurking in processors.)&#160;<a class=\"footnote-backref\" href=\"#fnref:heatmaps\" title=\"Jump back to footnote 25 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:bounds\">\n<p><a href=\"https://link.springer.com/chapter/10.1007/3-540-59293-8_189\">Anatomy of the Pentium Bug</a> reached a similar conclusion, stating \"The [Intel]  White Paper attributes the error to a script that incorrectly copied values; one is nevertheless tempted to wonder whether the rule for lowering thresholds was applied to the 8D/3 boundary, which would be an incorrect application because that boundary is serving to bound a threshold from below.\"\n(That paper also hypothesizes that the table was compressed to 6 columns, a hypothesis that my examination of the die disproves.)&#160;<a class=\"footnote-backref\" href=\"#fnref:bounds\" title=\"Jump back to footnote 26 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:script\">\n<p>The Intel white paper describes the underlying cause of the bug: \"After the quantized P-D plot (lookup table) was numerically generated as in Figure 4-1, a script was written to download the entries into a hardware PLA (Programmable Lookup Array).\nAn error was made in this script that resulted in a few lookup entries (belonging to the positive plane of the P-D plot) being omitted from the PLA.\" The script explanation is repeated in <a href=\"https://web.archive.org/web/20060209005434/http://www.byte.com/art/9503/sec13/art1.htm\">The Truth Behind the Pentium Bug</a>: \"An engineer prepared the lookup table on a computer and wrote a script in C to download it into a PLA (programmable logic array) for inclusion in the Pentium's FPU.\nUnfortunately, due to an error in the script, five of the 1066 table entries were not downloaded.\nTo compound this mistake, nobody checked the PLA to verify the table was copied correctly.\"\nMy analysis suggests that the table was copied correctly; the problem was that the table was\nmathematically wrong.&#160;<a class=\"footnote-backref\" href=\"#fnref:script\" title=\"Jump back to footnote 27 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:legends\">\n<p>It's not hard to find claims of people encountering the Pentium division bug, but these seem\nto be in the \"urban legend\" category. Either the problem is described second-hand, or the problem\nis unrelated to division, or the problem happened much too frequently to be the FDIV bug.\nIt has been <a href=\"https://youtu.be/E2MIpi8pIvY?t=1511\">said</a> that the game Quake would occasionally show the\nwrong part of a level due to the FDIV bug, but I find that implausible. \n<a href=\"https://archive.org/details/1995-01-01_W5YI_Report/page/n8/mode/1up\">The \"Intel Inside&mdash;Don't Divide\" Chipwreck</a> describes how the division bug was blamed for everything from database and application server crashes\nto gibberish text.&#160;<a class=\"footnote-backref\" href=\"#fnref:legends\" title=\"Jump back to footnote 28 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:ibm\">\n<p>IBM's analysis of the error rate seems contrived, coming up with reasons to use numbers that are\nlikely to cause errors.\nIn particular, IBM focuses on slightly truncated numbers, either numbers with two decimal digits or\nhardcoded constants.\nNote that a slightly truncated number is much more likely to hit a problem because\nits binary representation will have multiple 1's in a row, a necessity to trigger the bug.\nAnother paper <a href=\"http://boole.stanford.edu/pentium.html\">Risk Analysis of the Pentium Bug</a> claims a risk of one in every 200 divisions.\nIt depends on \"bruised integers\", such as 4.999999, which are similarly contrived.\nI'll also point out that if you start with numbers that are \"bruised\" or otherwise corrupted, you obviously don't care about floating-point accuracy and shouldn't complain if the Pentium adds slightly more inaccuracy.</p>\n<p>The book \"Inside Intel\" says that \"the IBM analysis was quite wrong\" and \"IBM's intervention in the Pentium affair was not an example of the company on its finest behavior\" (page 364).&#160;<a class=\"footnote-backref\" href=\"#fnref:ibm\" title=\"Jump back to footnote 29 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:f00f\">\n<p>The F00F bug happens when an invalid compare-and-exchange instruction leaves the bus locked.\nThe instruction is supposed to exchange with a memory location, but the invalid instruction specifies a register instead causing unexpected behavior.\nThis is very similar to some undocumented instructions in the 8086 processor where a register is specified when memory is required;\nsee my article <a href=\"https://www.righto.com/2023/07/undocumented-8086-instructions.html\">Undocumented 8086 instructions, explained by the microcode</a>.&#160;<a class=\"footnote-backref\" href=\"#fnref:f00f\" title=\"Jump back to footnote 30 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:patchable\">\n<p>For details on the Pentium Pro's patchable microcode, see <a href=\"https://www.ele.uva.es/~jesman/BigSeti/ftp/Cajon_Desastre/MPR/111204.pdf\">P6 Microcode Can Be Patched</a>.\nBut patchable microcode dates back much earlier.\nThe IBM System/360 mainframes (1964) had microcode that could be updated in the field,\neither to fix bugs or to implement new features.\nThese systems stored microcode on metalized Mylar sheets that could be replaced as necessary.\nIn that era, semiconductor ROMs didn't exist, so Mylar sheets were also a cost-effective way to\nimplement read-only storage.\nSee <a href=\"https://www.righto.com/2019/11/tros-how-ibm-mainframes-stored.html\">TROS: How IBM mainframes stored microcode in transformers</a>.&#160;<a class=\"footnote-backref\" href=\"#fnref:patchable\" title=\"Jump back to footnote 31 in the text\">&#8617;</a></p>\n</li>\n</ol>\n</div>",
  "id": "tag:blogger.com,1999:blog-6264947694886887540.post-639773237179033868"
}