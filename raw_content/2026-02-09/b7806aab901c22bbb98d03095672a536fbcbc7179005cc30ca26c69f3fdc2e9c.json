{
  "title": "ZJIT is now available in Ruby 4.0",
  "link": "https://bernsteinbear.com/blog/launch-zjit/?utm_source=rss",
  "published": "Wed, 24 Dec 2025 00:00:00 +0000",
  "summary": "<p><em>Originally published on <a href=\"https://railsatscale.com/2025-12-24-launch-zjit/\">Rails At Scale</a>.</em></p>\n\n<p>ZJIT is a new just-in-time (JIT) Ruby compiler built into the reference Ruby\nimplementation, <a href=\"https://en.wikipedia.org/wiki/YARV\">YARV</a>, by the same compiler group that brought you YJIT.\nWe (Aaron Patterson, Aiden Fox Ivey, Alan Wu, Jacob Denbeaux, Kevin Menard, Max\nBernstein, Maxime Chevalier-Boisvert, Randy Stauner, Stan Lo, and Takashi\nKokubun) have been working on ZJIT since the beginning of this year.</p>\n\n<p>In case you missed the last post, we’re building a new compiler for Ruby\nbecause we want to both raise the performance ceiling (bigger compilation unit\nsize and SSA IR) and encourage more outside contribution (by becoming a more\ntraditional method compiler).</p>\n\n<p>It’s been a long time since we gave an official update on ZJIT. Things are\ngoing well. We’re excited to share our progress with you. We’ve done a lot\n<a href=\"/blog/merge-zjit/\">since May</a>.</p>\n\n<h2 id=\"in-brief\">In brief</h2>\n\n<p>ZJIT is compiled by default—but not enabled by default—in Ruby 4.0. Enable\nit by passing the <code class=\"language-plaintext highlighter-rouge\">--zjit</code> flag or the <code class=\"language-plaintext highlighter-rouge\">RUBY_ZJIT_ENABLE</code> environment variable\nor calling <code class=\"language-plaintext highlighter-rouge\">RubyVM::ZJIT.enable</code> after starting your application.</p>\n\n<p>It’s faster than the interpreter, but not yet as fast as YJIT. <strong>Yet.</strong> But we\nhave a plan, and we have some more specific numbers below. The TL;DR is we have\na great new foundation and now need to pull out all the Ruby-specific stops to\nmatch YJIT.</p>\n\n<p>We encourage you to experiment with ZJIT, but maybe hold off on deploying it in\nproduction for now. This is a very new compiler. You should expect crashes and\nwild performance degradations (or, perhaps, improvements). Please test locally,\ntry to run CI, etc, and let us know what you run into on <a href=\"https://bugs.ruby-lang.org/projects/ruby-master/issues?set_filter=1&amp;tracker_id=1\">the Ruby issue\ntracker</a> (or, if you don’t want to make a Ruby Bugs account, we would\nalso take reports <a href=\"https://github.com/Shopify/ruby/issues\">on GitHub</a>).</p>\n\n<h2 id=\"state-of-the-compiler\">State of the compiler</h2>\n\n<p>To underscore how much has happened since the <a href=\"/blog/merge-zjit/\">announcement of being merged\ninto CRuby</a>, we present to you a series of comparisons:</p>\n\n<h3 id=\"side-exits\">Side-exits</h3>\n\n<p>Back in May, we could not side-exit from JIT code into the interpreter. This\nmeant that the code we were running had to continue to have the same\npreconditions (expected types, no method redefinitions, etc) or the JIT would\nsafely abort. <strong>Now,</strong> we can side-exit and use this feature liberally.</p>\n\n<blockquote>\n  <p>For example, we gracefully handle the phase transition from integer to string;\na guard instruction fails and transfers control to the interpreter.</p>\n\n  <div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">add</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span>\n  <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span>\n<span class=\"k\">end</span>\n\n<span class=\"n\">add</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span>\n<span class=\"n\">add</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span>\n<span class=\"n\">add</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span>\n<span class=\"n\">add</span> <span class=\"s2\">\"three\"</span><span class=\"p\">,</span> <span class=\"s2\">\"four\"</span>\n</code></pre></div>  </div>\n</blockquote>\n\n<p>This enables running a lot more code!</p>\n\n<h3 id=\"more-code\">More code</h3>\n\n<p>Back in May, we could only run a handful of small benchmarks. <strong>Now,</strong> we can\nrun all sorts of code, including passing the full Ruby test suite, the test\nsuite and shadow traffic of a large application at Shopify, and the test suite\nof GitHub.com! Also a bank, apparently.</p>\n\n<p>Back in May, we did not optimize much; we only really optimized operations\non fixnums (small integers) and method sends to the <code class=\"language-plaintext highlighter-rouge\">main</code> object. <strong>Now,</strong>\nwe optimize a lot more: all sorts of method sends, instance variable reads\nand writes, attribute accessor/reader/writer use, struct reads and writes,\nobject allocations, certain string operations, optional parameters, and more.</p>\n\n<blockquote>\n  <p>For example, we can <a href=\"https://en.wikipedia.org/wiki/Constant_folding\">constant-fold</a> numeric operations. Because we also have a\n(small, limited) inliner borrowed from YJIT, we can constant-fold the entirety\nof <code class=\"language-plaintext highlighter-rouge\">add</code> down to <code class=\"language-plaintext highlighter-rouge\">3</code>—and still handle redefinitions of <code class=\"language-plaintext highlighter-rouge\">one</code>, <code class=\"language-plaintext highlighter-rouge\">two</code>,\n<code class=\"language-plaintext highlighter-rouge\">Integer#+</code>, …</p>\n\n  <div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">one</span>\n  <span class=\"mi\">1</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">two</span>\n  <span class=\"mi\">2</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">add</span>\n  <span class=\"n\">one</span> <span class=\"o\">+</span> <span class=\"n\">two</span>\n<span class=\"k\">end</span>\n</code></pre></div>  </div>\n</blockquote>\n\n<h3 id=\"register-spilling\">Register spilling</h3>\n\n<p>Back in May, we could not compile many large functions due to limitations of\nour backend that we borrowed from YJIT. <strong>Now,</strong> we can compile absolutely\nenormous functions just fine. And quickly, too. Though we have not been\nfocusing specifically on compiler performance, we compile even large methods in\nunder a millisecond.</p>\n\n<h3 id=\"c-methods\">C methods</h3>\n\n<p>Back in May, we could not even optimize calls to built-in C methods. <strong>Now,</strong>\nwe have a feature similar to JavaScriptCore’s DOMJIT, which allows us to emit\ninline HIR versions of certain well-known C methods. This allows the optimizer\nto reason about these methods and their effects (more on this in a future post)\nmuch more… er, effectively.</p>\n\n<blockquote>\n  <p>For example, <code class=\"language-plaintext highlighter-rouge\">Integer#succ</code>, which is defined as adding <code class=\"language-plaintext highlighter-rouge\">1</code> to an integer, is a\nC method. It’s used in <code class=\"language-plaintext highlighter-rouge\">Integer#times</code> to drive the <code class=\"language-plaintext highlighter-rouge\">while</code> loop. Instead of\nemitting a call to it, our C method “inliner” can emit our existing <code class=\"language-plaintext highlighter-rouge\">FixnumAdd</code>\ninstruction and take advantage of the rest of the type inference and\nconstant-folding.</p>\n\n  <div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">fn</span> <span class=\"nf\">inline_integer_succ</span><span class=\"p\">(</span><span class=\"n\">fun</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"k\">mut</span> <span class=\"nn\">hir</span><span class=\"p\">::</span><span class=\"n\">Function</span><span class=\"p\">,</span>\n                       <span class=\"n\">block</span><span class=\"p\">:</span> <span class=\"nn\">hir</span><span class=\"p\">::</span><span class=\"n\">BlockId</span><span class=\"p\">,</span>\n                       <span class=\"n\">recv</span><span class=\"p\">:</span> <span class=\"nn\">hir</span><span class=\"p\">::</span><span class=\"n\">InsnId</span><span class=\"p\">,</span>\n                       <span class=\"n\">args</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"nn\">hir</span><span class=\"p\">::</span><span class=\"n\">InsnId</span><span class=\"p\">],</span>\n                       <span class=\"n\">state</span><span class=\"p\">:</span> <span class=\"nn\">hir</span><span class=\"p\">::</span><span class=\"n\">InsnId</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"nn\">hir</span><span class=\"p\">::</span><span class=\"n\">InsnId</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">!</span><span class=\"n\">args</span><span class=\"nf\">.is_empty</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"nb\">None</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"n\">fun</span><span class=\"nf\">.likely_a</span><span class=\"p\">(</span><span class=\"n\">recv</span><span class=\"p\">,</span> <span class=\"nn\">types</span><span class=\"p\">::</span><span class=\"n\">Fixnum</span><span class=\"p\">,</span> <span class=\"n\">state</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">let</span> <span class=\"n\">left</span> <span class=\"o\">=</span> <span class=\"n\">fun</span><span class=\"nf\">.coerce_to</span><span class=\"p\">(</span><span class=\"n\">block</span><span class=\"p\">,</span> <span class=\"n\">recv</span><span class=\"p\">,</span> <span class=\"nn\">types</span><span class=\"p\">::</span><span class=\"n\">Fixnum</span><span class=\"p\">,</span> <span class=\"n\">state</span><span class=\"p\">);</span>\n        <span class=\"k\">let</span> <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"n\">fun</span><span class=\"nf\">.push_insn</span><span class=\"p\">(</span><span class=\"n\">block</span><span class=\"p\">,</span> <span class=\"nn\">hir</span><span class=\"p\">::</span><span class=\"nn\">Insn</span><span class=\"p\">::</span><span class=\"nb\">Const</span> <span class=\"p\">{</span> <span class=\"n\">val</span><span class=\"p\">:</span> <span class=\"nn\">hir</span><span class=\"p\">::</span><span class=\"nn\">Const</span><span class=\"p\">::</span><span class=\"nf\">Value</span><span class=\"p\">(</span><span class=\"nn\">VALUE</span><span class=\"p\">::</span><span class=\"nf\">fixnum_from_usize</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">))</span> <span class=\"p\">});</span>\n        <span class=\"k\">let</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">fun</span><span class=\"nf\">.push_insn</span><span class=\"p\">(</span><span class=\"n\">block</span><span class=\"p\">,</span> <span class=\"nn\">hir</span><span class=\"p\">::</span><span class=\"nn\">Insn</span><span class=\"p\">::</span><span class=\"n\">FixnumAdd</span> <span class=\"p\">{</span> <span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">right</span><span class=\"p\">,</span> <span class=\"n\">state</span> <span class=\"p\">});</span>\n        <span class=\"k\">return</span> <span class=\"nf\">Some</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"nb\">None</span>\n<span class=\"p\">}</span>\n</code></pre></div>  </div>\n</blockquote>\n\n<h3 id=\"fewer-c-calls\">Fewer C calls</h3>\n\n<p>Back in May, the machine code ZJIT generated called a lot of C functions from\nthe CRuby runtime to implement our HIR instructions in LIR. We have pared this\ndown significantly and now “open code” the implementations in LIR.</p>\n\n<blockquote>\n  <p>For example, <code class=\"language-plaintext highlighter-rouge\">GuardNotFrozen</code> used to call out to <code class=\"language-plaintext highlighter-rouge\">rb_obj_frozen_p</code>. Now, it\nrequires that its input is a heap-allocated object and can instead do a load, a\ntest, and a conditional jump.</p>\n\n  <div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">fn</span> <span class=\"nf\">gen_guard_not_frozen</span><span class=\"p\">(</span><span class=\"n\">jit</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"n\">JITState</span><span class=\"p\">,</span>\n                        <span class=\"n\">asm</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"k\">mut</span> <span class=\"n\">Assembler</span><span class=\"p\">,</span>\n                        <span class=\"n\">recv</span><span class=\"p\">:</span> <span class=\"n\">Opnd</span><span class=\"p\">,</span>\n                        <span class=\"n\">state</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"n\">FrameState</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"n\">Opnd</span> <span class=\"p\">{</span>\n    <span class=\"k\">let</span> <span class=\"n\">recv</span> <span class=\"o\">=</span> <span class=\"n\">asm</span><span class=\"nf\">.load</span><span class=\"p\">(</span><span class=\"n\">recv</span><span class=\"p\">);</span>\n    <span class=\"c1\">// It's a heap object, so check the frozen flag</span>\n    <span class=\"k\">let</span> <span class=\"n\">flags</span> <span class=\"o\">=</span> <span class=\"n\">asm</span><span class=\"nf\">.load</span><span class=\"p\">(</span><span class=\"nn\">Opnd</span><span class=\"p\">::</span><span class=\"nf\">mem</span><span class=\"p\">(</span><span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"n\">recv</span><span class=\"p\">,</span> <span class=\"n\">RUBY_OFFSET_RBASIC_FLAGS</span><span class=\"p\">));</span>\n    <span class=\"n\">asm</span><span class=\"nf\">.test</span><span class=\"p\">(</span><span class=\"n\">flags</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">RUBY_FL_FREEZE</span> <span class=\"k\">as</span> <span class=\"nb\">u64</span><span class=\"p\">)</span><span class=\"nf\">.into</span><span class=\"p\">());</span>\n    <span class=\"c1\">// Side-exit if frozen</span>\n    <span class=\"n\">asm</span><span class=\"nf\">.jnz</span><span class=\"p\">(</span><span class=\"nf\">side_exit</span><span class=\"p\">(</span><span class=\"n\">jit</span><span class=\"p\">,</span> <span class=\"n\">state</span><span class=\"p\">,</span> <span class=\"n\">GuardNotFrozen</span><span class=\"p\">));</span>\n    <span class=\"n\">recv</span>\n<span class=\"p\">}</span>\n</code></pre></div>  </div>\n</blockquote>\n\n<h3 id=\"more-teammates\">More teammates</h3>\n\n<p>Back in May, we had four people working full-time on the compiler. <strong>Now,</strong> we\nhave more internally at Shopify—and also more from the community! We have\nhad several interested people reach out, learn about ZJIT, and successfully\nland complex changes. For this reason, we have opened up <a href=\"https://zjit.zulipchat.com\">a chat\nroom</a> to discuss and improve ZJIT.</p>\n\n<h3 id=\"a-cool-graph-visualization-tool\">A cool graph visualization tool</h3>\n\n<p>You <em>have to</em> check out our intern Aiden’s <a href=\"https://railsatscale.com/2025-11-19-adding-iongraph-support/\">integration of Iongraph into\nZJIT</a>. Now we\nhave clickable, zoomable, scrollable graphs of all our functions and all our\noptimization passes. It’s great!</p>\n\n<p>Try zooming (Ctrl-scroll), clicking the different optimization passes on the\nleft, clicking the instruction IDs in each basic block (definitions and uses),\nand seeing how the IR for the below Ruby code changes over time.</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Point</span>\n  <span class=\"nb\">attr_accessor</span> <span class=\"ss\">:x</span><span class=\"p\">,</span> <span class=\"ss\">:y</span>\n  <span class=\"k\">def</span> <span class=\"nf\">initialize</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span>\n    <span class=\"vi\">@x</span> <span class=\"o\">=</span> <span class=\"n\">x</span>\n    <span class=\"vi\">@y</span> <span class=\"o\">=</span> <span class=\"n\">y</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n\n<span class=\"no\">P</span> <span class=\"o\">=</span> <span class=\"no\">Point</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">).</span><span class=\"nf\">freeze</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test</span> <span class=\"o\">=</span> <span class=\"no\">P</span><span class=\"p\">.</span><span class=\"nf\">x</span> <span class=\"o\">+</span> <span class=\"no\">P</span><span class=\"p\">.</span><span class=\"nf\">y</span>\n</code></pre></div></div>\n\n\n\n<h3 id=\"more\">More</h3>\n\n<p>…and so, so many garbage collection fixes.</p>\n\n<p>There’s still a lot to do, though.</p>\n\n<h2 id=\"to-do\">To do</h2>\n\n<p>We’re going to optimize <code class=\"language-plaintext highlighter-rouge\">invokeblock</code> (<code class=\"language-plaintext highlighter-rouge\">yield</code>) and <code class=\"language-plaintext highlighter-rouge\">invokesuper</code> (<code class=\"language-plaintext highlighter-rouge\">super</code>)\ninstructions, each of which behaves similarly, but not identically, to a\nnormal <code class=\"language-plaintext highlighter-rouge\">send</code> instruction. These are pretty common.</p>\n\n<p>We’re going to optimize <code class=\"language-plaintext highlighter-rouge\">setinstancevariable</code> in the case where we have to\ntransition the object’s shape. This will help normal <code class=\"language-plaintext highlighter-rouge\">@a = b</code> situations. It\nwill also help <code class=\"language-plaintext highlighter-rouge\">@a ||= b</code>, but I think we can even do better with the latter\nusing some kind of value numbering.</p>\n\n<p>We only optimize monomorphic calls right now—cases where a method send only\nsees one class of receiver while being profiled. We’re going to optimize\npolymorphic sends, too. Right now we’re laying the groundwork (a new register\nallocator; see below) to make this much easier. It’s not as much of an\nimmediate focus, though, because most (high 80s, low 90s percent) of sends are\nmonomorphic. <!-- TODO throwback to Smalltalk-80 --></p>\n\n<p>We’re in the middle of re-writing the register allocator after reading the\nentire history of linear scan papers and several implementations. That will\nunlock performance improvements and also allow us to make the IRs easier to\nuse.</p>\n\n<p>We don’t handle phase changes particularly well yet; if your method call\npatterns change significantly after your code has been compiled, we will\nfrequently side-exit into the interpreter. Instead, we would like to use these\nside-exits as additional profile information and re-compile the function.</p>\n\n<p>Right now we have a lot of traffic to the VM frame. JIT frame pushes are\nreasonably fast, but with every effectful operation, we have to flush our local\nvariable state and stack state to the VM frame. The instances in which code\nmight want to read this reified frame state are rare: frame unwinding due to\nexceptions, <code class=\"language-plaintext highlighter-rouge\">Binding#local_variable_get</code>, etc. In the future, we will instead\ndefer writing this state until it needs to be read.</p>\n\n<p>We only have a limited inliner that inlines constants, <code class=\"language-plaintext highlighter-rouge\">self</code>, and parameters.\nIn the fullness of time, we will add a general-purpose method inlining\nfacility. This will allow us to reduce the amount of polymorphic sends, do some\nbranch folding, and reduce the amount of method sends.</p>\n\n<p>We only support optimizing positional parameters, required keyword parameters,\nand optional parameters right now but we will work on optimizing optional\nkeyword arguments as well. Most of this work is in marshaling the complex\nRuby calling convention into one coherent form that the JIT can understand.</p>\n\n<h2 id=\"performance\">Performance</h2>\n\n<p>We have public performance numbers for a selection of macro- and\nmicro-benchmarks on <a href=\"https://rubybench.github.io/\">rubybench</a>. Here is a screenshot of what those\nper-benchmark graphs look like. The Y axis is speedup multiplier vs the\ninterpreter and the X axis is time. Higher is better:</p>\n\n<figure style=\"display: block; margin: 0 auto;\">\n  <img src=\"/assets/img/zjit-benchmark.png\" />\n  <figcaption>A line chart of ZJIT performance on railsbench&mdash;represented as a\n  speedup multiplier when compared to the interpreter&mdash;improving over\n  time, passing interpreter performance, catching up to YJIT.</figcaption>\n</figure>\n\n<p>You can see that we are improving performance on nearly all benchmarks over\ntime. Some of this comes from from optimizing in a similar way as YJIT does\ntoday (e.g. specializing ivar reads and writes), and some of it is optimizing\nin a way that takes advantage of ZJIT’s high-level IR (e.g. constant folding,\nbranch folding, more precise type inference).</p>\n\n<p>We are using both raw time numbers and also our internal performance counters\n(e.g. number of calls to C functions from generated code) to drive\noptimization.</p>\n\n<h2 id=\"try-it-out\">Try it out</h2>\n\n<p>While Ruby now ships with ZJIT compiled into the binary by default, it is not\n<em>enabled</em> by default at run-time. Due to performance and stability, YJIT is\nstill the default compiler choice in Ruby 4.0.</p>\n\n<p>If you want to run your test suite with ZJIT to see what happens, you\nabsolutely can. Enable it by passing the <code class=\"language-plaintext highlighter-rouge\">--zjit</code> flag or the\n<code class=\"language-plaintext highlighter-rouge\">RUBY_ZJIT_ENABLE</code> environment variable or calling <code class=\"language-plaintext highlighter-rouge\">RubyVM::ZJIT.enable</code> after\nstarting your application.</p>\n\n<h2 id=\"on-yjit\">On YJIT</h2>\n\n<p>We devoted a lot of our resources this year to developing ZJIT. While we did\nnot spend much time on YJIT (outside of a great <a href=\"https://railsatscale.com/2025-05-21-fast-allocations-in-ruby-3-5/\">allocation speed\nup</a>), YJIT isn’t going anywhere soon.</p>\n\n<h2 id=\"thank-you\">Thank you</h2>\n\n<p>This compiler was made possible by contributions to your <del>PBS station</del> open\nsource project from programmers like you. Thank you!</p>\n\n<ul>\n  <li>Aaron Patterson</li>\n  <li>Abrar Habib</li>\n  <li>Aiden Fox Ivey</li>\n  <li>Alan Wu</li>\n  <li>Alex Rocha</li>\n  <li>André Luiz Tiago Soares</li>\n  <li>Benoit Daloze</li>\n  <li>Charlotte Wen</li>\n  <li>Daniel Colson</li>\n  <li>Donghee Na</li>\n  <li>Eileen Uchitelle</li>\n  <li>Étienne Barrié</li>\n  <li>Godfrey Chan</li>\n  <li>Goshanraj Govindaraj</li>\n  <li>Hiroshi SHIBATA</li>\n  <li>Hoa Nguyen</li>\n  <li>Jacob Denbeaux</li>\n  <li>Jean Boussier</li>\n  <li>Jeremy Evans</li>\n  <li>John Hawthorn</li>\n  <li>Ken Jin</li>\n  <li>Kevin Menard</li>\n  <li>Max Bernstein</li>\n  <li>Max Leopold</li>\n  <li>Maxime Chevalier-Boisvert</li>\n  <li>Nobuyoshi Nakada</li>\n  <li>Peter Zhu</li>\n  <li>Randy Stauner</li>\n  <li>Satoshi Tagomori</li>\n  <li>Shannon Skipper</li>\n  <li>Stan Lo</li>\n  <li>Takashi Kokubun</li>\n  <li>Tavian Barnes</li>\n  <li>Tobias Lütke</li>\n</ul>\n\n<p>(via a lightly touched up <code class=\"language-plaintext highlighter-rouge\">git log --pretty=\"%an\" zjit | sort -u</code>)</p>",
  "id": "https://bernsteinbear.com/blog/launch-zjit/"
}