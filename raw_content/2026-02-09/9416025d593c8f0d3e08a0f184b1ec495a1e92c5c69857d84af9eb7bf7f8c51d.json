{
  "title": "Linear scan with lifetime holes",
  "link": "https://bernsteinbear.com/blog/linear-scan-lifetime-holes/?utm_source=rss",
  "published": "Sun, 24 Aug 2025 00:00:00 +0000",
  "summary": "<p>In my <a href=\"/blog/linear-scan/\">last post</a>, I explained a bit about how to retrofit\nSSA onto the original linear scan algorithm. I went over all of the details for\nhow to go from low-level IR to register assignments—liveness analysis,\nscheduling, building intervals, and the actual linear scan algorithm.</p>\n\n<p>Basically, we made it to 1997 linear scan, with small adaptations for\nallocating directly on SSA.</p>\n\n<p>This time, we’re going to retrofit <em>lifetime holes</em>.</p>\n\n<h2 id=\"lifetime-holes\">Lifetime holes</h2>\n\n<p>Lifetime holes come into play because a linearized sequence of instructions is\nnot a great proxy for storing or using metadata about a program originally\nstored as a graph.</p>\n\n<p>According to <a href=\"/assets/img/wimmer-linear-scan-ssa.pdf\">Linear Scan Register Allocation on SSA Form</a> (PDF,\n2010):</p>\n\n<blockquote>\n  <p>The lifetime interval of a virtual register must cover all parts where this\nregister is needed, with lifetime holes in between. Lifetime holes occur\nbecause the control flow graph is reduced to a list of blocks before register\nallocation. If a register flows into an <code class=\"language-plaintext highlighter-rouge\">else</code>-block, but not into the\ncorresponding <code class=\"language-plaintext highlighter-rouge\">if</code>-block, the lifetime interval has a hole for the <code class=\"language-plaintext highlighter-rouge\">if</code>-block.</p>\n</blockquote>\n\n<p>Lifetime holes come from <a href=\"/assets/img/quality-speed-linear-scan-ra-clean.pdf\">Quality and Speed in Linear-scan Register\nAllocation</a> (PDF, 1998) by Traub, Holloway, and Smith. Figure 1,\nthough not in SSA form, is a nice diagram for understanding how lifetime holes\nmay occur. Unfortunately, the paper contains a rather sparse plaintext\ndescription of their algorithm that I did not understand how to apply to my\nconcrete allocator.</p>\n\n<p>Thankfully, other papers continued this line of research in (at least) 2002,\n2005, and 2010. We will piece snippets from those papers together to understand\nwhat’s going on.</p>\n\n<p>Let’s take a look at the sample IR snippet from Wimmer2010 to illustrate how\nlifetime holes form:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>16: label B1(R10, R11):\n18: jmp B2($1, R11)\n     # vvvvvvvvvv #\n20: label B2(R12, R13)\n22: cmp R13, $1\n24: branch lessThan B4() else B3()\n\n26: label B3()\n28: mul R12, R13 -&gt; R14\n30: sub R13, $1 -&gt; R15\n32: jump B2(R14, R15)\n\n34: label B4()\n     # ^^^^^^^^^^ #\n36: add R10, R12 -&gt; R16\n38: ret R16\n</code></pre></div></div>\n\n<p>Virtual register R12 is not used between position 28 and 34. For this reason,\nWimmer’s interval building algorithm assigns it the interval <code class=\"language-plaintext highlighter-rouge\">[[20, 28), [34,\n...)]</code>. Note how the interval has two disjoint ranges with space in the middle.</p>\n\n<p>Our simplified interval building algorithm from last time gave us—in the same\nnotation—the interval <code class=\"language-plaintext highlighter-rouge\">[[20, ...)]</code> (well, <code class=\"language-plaintext highlighter-rouge\">[[20, 36)]</code> in our modified\nsnippet). This simplified interval only supports one range with no lifetime\nholes.</p>\n\n<p>Ideally we would be able to use the physical register assigned to R12 for\nanother virtual register in this empty slot! For example, maybe R14 or R15,\nwhich have short lifetimes that completely fit into the hole.</p>\n\n<p>Another example is a control-flow diamond. In this example, B1 jumps to either\nB3 or B2, which then merge at B4. Virtual register R0 is defined in B1 and only\nused in one of the branches, B3. It’s also not used in B4—if it were used in\nB4, it would be live in both B2 and B3!</p>\n\n<!--\n# dot IN.dot -Tsvg -Nfontname=Monospace -Efontname=Monospace > OUT.svg\n\ndigraph G {\nnode [shape=plaintext]\nB1 [label=<<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\">\n<TR><TD PORT=\"params\" BGCOLOR=\"lightgray\">B1()&nbsp;</TD></TR>\n<TR><TD ALIGN=\"left\" PORT=\"0\">R0 = loadi $123&nbsp;</TD></TR>\n<TR><TD ALIGN=\"left\" PORT=\"1\">blt →B3, →B2&nbsp;</TD></TR>\n</TABLE>>];\nB1:s -> B3:params:n;\nB1:s -> B2:params:n;\nB2 [label=<<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\">\n<TR><TD PORT=\"params\" BGCOLOR=\"lightgray\">B2()&nbsp;</TD></TR>\n<TR><TD ALIGN=\"left\" PORT=\"0\">R1 = loadi $456&nbsp;</TD></TR>\n<TR><TD ALIGN=\"left\" PORT=\"1\">R2 = add R1, $1&nbsp;</TD></TR>\n<TR><TD ALIGN=\"left\" PORT=\"2\">jump →B4&nbsp;</TD></TR>\n</TABLE>>];\nB2:s -> B4:params:n;\nB3 [label=<<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\">\n<TR><TD PORT=\"params\" BGCOLOR=\"lightgray\">B3()&nbsp;</TD></TR>\n<TR><TD ALIGN=\"left\" PORT=\"0\">R3 = mul R0, $2&nbsp;</TD></TR>\n<TR><TD ALIGN=\"left\" PORT=\"1\">jump →B4&nbsp;</TD></TR>\n</TABLE>>];\nB3:s -> B4:params:n;\nB4 [label=<<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\">\n<TR><TD PORT=\"params\" BGCOLOR=\"lightgray\">B4()&nbsp;</TD></TR>\n<TR><TD ALIGN=\"left\" PORT=\"0\">ret $5&nbsp;</TD></TR>\n</TABLE>>];\n}\n-->\n<figure>\n\n</figure>\n\n<p>Once we schedule it, the need for lifetime holes becomes more apparent:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>0: label B1:\n2: R0 = loadi $123\n4: blt iftrue: →B3, iffalse: →B2\n\n6: label B2:\n8: R1 = loadi $456\n10: R2 = add R1, $1\n12: jump →B4\n\n14: label B3:\n16: R3 = mul R0, $2\n18: jump →B4\n\n20: label B4:\n22: ret $5\n</code></pre></div></div>\n\n<p>Since B2 gets scheduled (in this case, arbitrarily) before B3, there’s a gap\nwhere R0—which is completely unused in B2—would otherwise take up space in\nour simplified interval form. Let’s fix that by adding some lifetime holes.</p>\n\n<p><strong>Even though</strong> we are adding some gaps between ranges, each interval still\ngets assigned <em>one location for its entire life</em>. It’s just that in the gaps,\nwe get to put other smaller intervals, like lichen growing between bricks.</p>\n\n<p>To get lifetime holes, we have to modify our interval data structure a bit.</p>\n\n<h2 id=\"finding-lifetime-holes\">Finding lifetime holes</h2>\n\n<p>Our interval currently only supports a single range:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Interval</span>\n  <span class=\"nb\">attr_reader</span> <span class=\"ss\">:range</span>\n  <span class=\"k\">def</span> <span class=\"nf\">initialize</span> <span class=\"o\">=</span> <span class=\"k\">raise</span>\n  <span class=\"k\">def</span> <span class=\"nf\">add_range</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">,</span> <span class=\"n\">to</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"k\">raise</span>\n  <span class=\"k\">def</span> <span class=\"nf\">set_from</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"k\">raise</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>We can change this to support multiple ranges by changing <em>just one character</em>!!!</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Interval</span>\n  <span class=\"nb\">attr_reader</span> <span class=\"ss\">:ranges</span>\n  <span class=\"k\">def</span> <span class=\"nf\">initialize</span> <span class=\"o\">=</span> <span class=\"k\">raise</span>\n  <span class=\"k\">def</span> <span class=\"nf\">add_range</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">,</span> <span class=\"n\">to</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"k\">raise</span>\n  <span class=\"k\">def</span> <span class=\"nf\">set_from</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"k\">raise</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>Har har. Okay, so we now have an array of <code class=\"language-plaintext highlighter-rouge\">Range</code> instead of just a single\n<code class=\"language-plaintext highlighter-rouge\">Range</code>. But now we have to implement the methods differently.</p>\n\n<p>We’ll start with <code class=\"language-plaintext highlighter-rouge\">initialize</code>. The start state of an interval is an empty array\nof ranges:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Interval</span>\n  <span class=\"k\">def</span> <span class=\"nf\">initialize</span>\n    <span class=\"vi\">@ranges</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>Because we’re iterating backwards through the blocks and backwards through\ninstructions in each block, we’ll be starting with instruction 38 and working\nour way linearly backwards until 16.</p>\n\n<p>This means that we’ll see later uses before earlier uses, and uses before defs.\nIn order to keep the <code class=\"language-plaintext highlighter-rouge\">@ranges</code> array in sorted order, we need to add each new\nrange to the front. This is O(n) in an array, so use a deque or linked list.\n(Alternatively, push to the end and then reverse them afterwards.)</p>\n\n<!-- TODO why keep them disjoint? -->\n\n<p>We keep the ranges in sorted order because it makes keeping them disjoint\neasier, as we’ll see in <code class=\"language-plaintext highlighter-rouge\">add_range</code> and <code class=\"language-plaintext highlighter-rouge\">set_from</code>. Let’s start with <code class=\"language-plaintext highlighter-rouge\">set_from</code>\nsince it’s very similar to the previous version:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Interval</span>\n  <span class=\"k\">def</span> <span class=\"nf\">set_from</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"vi\">@ranges</span><span class=\"p\">.</span><span class=\"nf\">empty?</span>\n      <span class=\"c1\"># @ranges is empty when we don't have a use of the vreg</span>\n      <span class=\"vi\">@ranges</span> <span class=\"o\">&lt;&lt;</span> <span class=\"no\">Range</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">,</span> <span class=\"n\">from</span><span class=\"p\">)</span>\n    <span class=\"k\">else</span>\n      <span class=\"vi\">@ranges</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"no\">Range</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">,</span> <span class=\"vi\">@ranges</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"nf\">end</span><span class=\"p\">)</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">assert_sorted_and_disjoint</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p><code class=\"language-plaintext highlighter-rouge\">add_range</code> has a couple more cases, but we’ll go through them step by step.\nFirst, a quick check that the range is the right way ‘round:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Interval</span>\n  <span class=\"k\">def</span> <span class=\"nf\">add_range</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">,</span> <span class=\"n\">to</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">to</span> <span class=\"o\">&lt;=</span> <span class=\"n\">from</span>\n      <span class=\"k\">raise</span> <span class=\"no\">ArgumentError</span><span class=\"p\">,</span> <span class=\"s2\">\"Invalid range: </span><span class=\"si\">#{</span><span class=\"n\">from</span><span class=\"si\">}</span><span class=\"s2\"> to </span><span class=\"si\">#{</span><span class=\"n\">to</span><span class=\"si\">}</span><span class=\"s2\">\"</span>\n    <span class=\"k\">end</span>\n    <span class=\"c1\"># ...</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>Then we have a straightforward case: if we don’t have any ranges yet, add a\nbrand new one:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Interval</span>\n  <span class=\"k\">def</span> <span class=\"nf\">add_range</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">,</span> <span class=\"n\">to</span><span class=\"p\">)</span>\n    <span class=\"c1\"># ...</span>\n    <span class=\"k\">if</span> <span class=\"vi\">@ranges</span><span class=\"p\">.</span><span class=\"nf\">empty?</span>\n      <span class=\"vi\">@ranges</span> <span class=\"o\">&lt;&lt;</span> <span class=\"no\">Range</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">,</span> <span class=\"n\">to</span><span class=\"p\">)</span>\n      <span class=\"k\">return</span>\n    <span class=\"k\">end</span>\n    <span class=\"c1\"># ...</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>But if we do have ranges, this new range might be totally subsumed by the\nexisting first range. This happens if a virtual register is live for the\nentirety of a block and also used inside that block. The uses that cause an\n<code class=\"language-plaintext highlighter-rouge\">add_range</code> don’t add any new information:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Interval</span>\n  <span class=\"k\">def</span> <span class=\"nf\">add_range</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">,</span> <span class=\"n\">to</span><span class=\"p\">)</span>\n    <span class=\"c1\"># ...</span>\n    <span class=\"k\">if</span> <span class=\"vi\">@ranges</span><span class=\"p\">.</span><span class=\"nf\">first</span><span class=\"p\">.</span><span class=\"nf\">cover?</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"o\">..</span><span class=\"n\">to</span><span class=\"p\">)</span>\n      <span class=\"n\">assert_sorted_and_disjoint</span>\n      <span class=\"k\">return</span>\n    <span class=\"k\">end</span>\n    <span class=\"c1\"># ...</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>Another case is that the new range has a partial overlap with the existing\nfirst range. This happens when we’re adding ranges for all of the live-out\nvirtual registers; the range for the predecessor block (say <code class=\"language-plaintext highlighter-rouge\">[4, 8]</code>) will abut\nthe range for the successor block (say <code class=\"language-plaintext highlighter-rouge\">[8, 12]</code>). We merge these ranges into\none big range (say, <code class=\"language-plaintext highlighter-rouge\">[4, 12]</code>):</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Interval</span>\n  <span class=\"k\">def</span> <span class=\"nf\">add_range</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">,</span> <span class=\"n\">to</span><span class=\"p\">)</span>\n    <span class=\"c1\"># ...</span>\n    <span class=\"k\">if</span> <span class=\"vi\">@ranges</span><span class=\"p\">.</span><span class=\"nf\">first</span><span class=\"p\">.</span><span class=\"nf\">cover?</span><span class=\"p\">(</span><span class=\"n\">to</span><span class=\"p\">)</span>\n      <span class=\"vi\">@ranges</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"no\">Range</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">,</span> <span class=\"vi\">@ranges</span><span class=\"p\">.</span><span class=\"nf\">first</span><span class=\"p\">.</span><span class=\"nf\">end</span><span class=\"p\">)</span>\n      <span class=\"n\">assert_sorted_and_disjoint</span>\n      <span class=\"k\">return</span>\n    <span class=\"k\">end</span>\n    <span class=\"c1\"># ...</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>The last case is the case that gives us lifetime holes and happens when the new\nrange is already completely disjoint from the existing first range. That is\nalso a straightforward case: put the new range in at the start of the list.</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Interval</span>\n  <span class=\"k\">def</span> <span class=\"nf\">add_range</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">,</span> <span class=\"n\">to</span><span class=\"p\">)</span>\n    <span class=\"c1\"># ...</span>\n    <span class=\"c1\"># TODO(max): Use a linked list or deque or something to avoid O(n) insertions</span>\n    <span class=\"vi\">@ranges</span><span class=\"p\">.</span><span class=\"nf\">insert</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"no\">Range</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">,</span> <span class=\"n\">to</span><span class=\"p\">))</span>\n    <span class=\"n\">assert_sorted_and_disjoint</span>\n    <span class=\"c1\"># ...</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>This is all fine and good. I added this to the register allocator to test out\nthe lifetime hole finding but kept the rest of the same (changed the APIs\nslightly so the interval could pretend it was still one big range). The tests\npassed. Neat!</p>\n\n<p>I also verified that the lifetime holes were what we expected. This means our\n<code class=\"language-plaintext highlighter-rouge\">build_intervals</code> function works unmodified with the new <code class=\"language-plaintext highlighter-rouge\">Interval</code>\nimplementation. That makes sense, given that we copied the implementation off\nof Wimmer2010, which can deal with lifetime holes.</p>\n\n<p>Now we would like to use this new information in the register allocator.</p>\n\n<h2 id=\"modified-linear-scan\">Modified linear scan</h2>\n\n<p>It took a little bit of untangling, but the required modifications to support\nlifetime holes in the register assignment phase are not too invasive. To get an\nidea of the difference, I took the original <a href=\"/assets/img/linearscan-ra.pdf\">Poletto1999</a> (PDF) algorithm\nand rewrote it in the style of the <a href=\"/assets/img/linear-scan-ra-context-ssa.pdf\">Mössenböck2002</a> (PDF)\nalgorithm.</p>\n\n<p>For example, here is Poletto1999:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>LinearScanRegisterAllocation\nactive ← {}\nforeach live interval i, in order of increasing start point\n  ExpireOldIntervals(i)\n  if length(active) = R then\n    SpillAtInterval(i)\n  else\n    register[i] ← a register removed from pool of free registers\n    add i to active, sorted by increasing end point\n\nExpireOldIntervals(i)\nforeach interval j in active, in order of increasing end point\n  if endpoint[j] ≥ startpoint[i] then\n    return\n  remove j from active\n  add register[j] to pool of free registers\n\nSpillAtInterval(i)\nspill ← last interval in active\nif endpoint[spill] &gt; endpoint[i] then\n  register[i] ← register[spill]\n  location[spill] ← new stack location\n  remove spill from active\n  add i to active, sorted by increasing end point\nelse\n  location[i] ← new stack location\n</code></pre></div></div>\n\n<p>And here it is again, reformatted a bit. The implicit <code class=\"language-plaintext highlighter-rouge\">unhandled</code> and <code class=\"language-plaintext highlighter-rouge\">handled</code>\nsets that don’t get names in Poletto1999 now get names. <code class=\"language-plaintext highlighter-rouge\">ExpireOldIntervals</code> is\ninlined and <code class=\"language-plaintext highlighter-rouge\">SpillAtInterval</code> gets a new name:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>LINEARSCAN()\nunhandled ← all intervals in increasing order of their start points\nactive ← {}; handled ← {}\nfree ← set of available registers\nwhile unhandled ≠ {} do\n  cur ← pick and remove the first interval from unhandled\n  //----- check for active intervals that expired\n  for each interval i in active do\n    if i ends before cur.beg then\n      move i to handled and add i.reg to free\n\n  //----- collect available registers in f\n  f ← free\n\n  //----- select a register from f\n  if f = {} then\n    ASSIGNMEMLOC(cur) // see below\n  else\n    cur.reg ← any register in f\n    free ← free – {cur.reg}\n    move cur to active\n\nASSIGNMEMLOC(cur: Interval)\nspill ← last interval in active\nif spill.end &gt; cur.end then\n  cur.reg ← spill.reg\n  spill.location ← new stack location\n  move spill from active to handled\n  move cur to active\nelse\n  cur.location ← new stack location\n</code></pre></div></div>\n\n<p>Now we can pick out all of the bits of Mössenböck2002 that look like they are\nresponsible for dealing with lifetime holes.</p>\n\n<p>For example, the algorithm now has a fourth set, <code class=\"language-plaintext highlighter-rouge\">inactive</code>. This set holds\nintervals that have holes that contain the current interval’s start position.\nThese intervals are assigned registers that are potential candidates for the\ncurrent interval to live (more on this in a sec).</p>\n\n<p>I say potential candidates because in order for them to be a home for the\ncurrent interval, an inactive interval has to be completely disjoint from the\ncurrent interval. If they overlap at all—in any of their ranges—then we\nwould be trying to put two virtual registers into one physical register at the\nsame program point. That’s a bad compile.</p>\n\n<p>We have to do a little extra bookkeeping in <code class=\"language-plaintext highlighter-rouge\">ASSIGNMEMLOC</code> because now one\nphysical register can be assigned to more than one interval that is still in\nthe middle of being processed (active and inactive sets). If we choose to\nspill, we have to make sure that all conflicting uses of the register\n(intervals that overlap with the current interval) get reassigned locations.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>LINEARSCAN()\nunhandled ← all intervals in increasing order of their start points\nactive ← {}; handled ← {}\ninactive ← {}\nfree ← set of available registers\nwhile unhandled ≠ {} do\n  cur ← pick and remove the first interval from unhandled\n  //----- check for active intervals that expired\n  for each interval i in active do\n    if i ends before cur.beg then\n      move i to handled and add i.reg to free\n    else if i does not overlap cur.beg then\n      move i to inactive and add i.reg to free\n  //----- check for inactive intervals that expired or become reactivated\n  for each interval i in inactive do\n    if i ends before cur.beg then\n      move i to handled\n    else if i overlaps cur.beg then\n      move i to active and remove i.reg from free\n\n  //----- collect available registers in f\n  f ← free\n  for each interval i in inactive that overlaps cur do f ← f – {i.reg}\n\n  //----- select a register from f\n  if f = {} then\n    ASSIGNMEMLOC(cur) // see below\n  else\n    cur.reg ← any register in f\n    free ← free – {cur.reg}\n    move cur to active\n\nASSIGNMEMLOC(cur: Interval)\nspill ← heuristic: pick some interval from active or inactive\nif spill.end &gt; cur.end then\n  r = spill.reg\n  conflicting = set of active or inactive intervals with register r that\n    overlap with cur\n  move all intervals in conflicting to handled\n  assign memory locations to them\n  cur.reg ← r\n  move cur to active\nelse\n  cur.location ← new stack location\n</code></pre></div></div>\n\n<p>Note that this begins to depart from strictly linear (time) linear scan: the\n<code class=\"language-plaintext highlighter-rouge\">inactive</code> set is bounded not by the number of physical registers but instead\nby the number of virtual registers. Mössenböck2002 notes that the size of the\n<code class=\"language-plaintext highlighter-rouge\">inactive</code> set is generally very small, though, so “linear in practice”.</p>\n\n<blockquote>\n  <p>EDIT: After re-reading Wimmer2010, I noticed that they say:</p>\n\n  <blockquote>\n    <p>[…] introduced non-linear parts. Two of them are highlighted in Figure 6\nwhere the set of inactive intervals is iterated. The set can contain an\narbitrary number of intervals since it is not bound by the number of\nphysical registers. Testing the current interval for intersection with all\nof them can therefore be expensive.</p>\n\n    <p>When the lifetime intervals are created from code in SSA form, this test is\nnot necessary anymore: All intervals in inactive start before the current\ninterval, so they do not intersect with the current interval at their\ndefinition. They are inactive and thus have a lifetime hole at the current\nposition, so they do not intersect with the current interval at its\ndefinition. SSA form therefore guarantees that they never intersect [7],\nmaking the entire loop that tests for intersection unnecessary.</p>\n\n    <p>Unfortunately, splitting of intervals leads to intervals that no longer\nadhere to the SSA form properties because it destroys SSA form. Therefore,\nthe intersection test cannot be omitted completely; it must be performed if\nthe current interval has been split off from another interval.</p>\n  </blockquote>\n\n  <p>Which indicates to me that we may actually be able to leave off that loop\nover the inactive intervals after all? Unclear. I’ll have to come back and\nmess with this later.</p>\n</blockquote>\n\n<p>I left out the parts about register weights that are heuristics to improve\nregister allocation. They are not core to supporting lifetime holes. You can\nadd them back in if you like.</p>\n\n<p>Here is a text diff to make it clear what changed:</p>\n\n<div class=\"language-diff highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"gh\">diff --git a/tmp/lsra b/tmp/lsra-holes\nindex e9de35b..de79a63 100644\n</span><span class=\"gd\">--- a/tmp/lsra\n</span><span class=\"gi\">+++ b/tmp/lsra-holes\n</span><span class=\"p\">@@ -1,6 +1,7 @@</span>\n LINEARSCAN()\n unhandled ← all intervals in increasing order of their start points\n active ← {}; handled ← {}\n<span class=\"gi\">+inactive ← {}\n</span> free ← set of available registers\n while unhandled ≠ {} do\n   cur ← pick and remove the first interval from unhandled\n<span class=\"p\">@@ -8,9 +9,18 @@</span> while unhandled ≠ {} do\n   for each interval i in active do\n     if i ends before cur.beg then\n       move i to handled and add i.reg to free\n<span class=\"gi\">+    else if i does not overlap cur.beg then\n+      move i to inactive and add i.reg to free\n+  //----- check for inactive intervals that expired or become reactivated\n+  for each interval i in inactive do\n+    if i ends before cur.beg then\n+      move i to handled\n+    else if i overlaps cur.beg then\n+      move i to active and remove i.reg from free\n</span>\n   //----- collect available registers in f\n   f ← free\n<span class=\"gi\">+  for each interval i in inactive that overlaps cur do f ← f – {i.reg}\n</span>\n   //----- select a register from f\n   if f = {} then\n<span class=\"p\">@@ -23,10 +33,10 @@</span> while unhandled ≠ {} do\n ASSIGNMEMLOC(cur: Interval)\n<span class=\"gd\">-spill ← last interval in active\n</span><span class=\"gi\">+spill ← heuristic: pick some interval from active or inactive\n</span> if spill.end &gt; cur.end then\n<span class=\"gd\">-  cur.reg ← spill.reg\n-  spill.location ← new stack location\n-  move spill from active to handled\n</span><span class=\"gi\">+  r = spill.reg\n+  conflicting = set of active or inactive intervals with register r that\n+    overlap with cur\n+  move all intervals in conflicting to handled\n+  assign memory locations to them\n+  cur.reg ← r\n</span>   move cur to active\n else\n   cur.location ← new stack location\n</code></pre></div></div>\n\n<p>This reformatting and diffing made it much easier for me to reason about what\nspecifically had to be changed.</p>\n\n<p>There’s just one thing left after register assignment: resolution and SSA\ndeconstruction.</p>\n\n<h2 id=\"resolution-and-ssa-destruction\">Resolution and SSA destruction</h2>\n\n<p>I’m pretty sure we can actually just keep the resolution the same. In our\n<code class=\"language-plaintext highlighter-rouge\">resolve</code> function, we are only making sure that the block arguments get\nparallel-moved into the block parameters. That hasn’t changed.</p>\n\n<p>Wimmer2010 says:</p>\n\n<blockquote>\n  <p>Linear scan register allocation with splitting of lifetime intervals requires\na resolution phase after the actual allocation. Because the control flow\ngraph is reduced to a list of blocks, control flow is possible between blocks\nthat are not adjacent in the list. When the location of an interval is\ndifferent at the end of the predecessor and at the start of the successor, a\nmove instruction must be inserted to resolve the conflict.</p>\n</blockquote>\n\n<p>That’s great news for us: we don’t do splitting. An interval, though it has\nlifetime holes, still only ever has one location for its entire life. So once\nan interval begins, we don’t need to think about moving its contents.</p>\n\n<p>So I was actually overly conservative in the previous post, which I have\namended!</p>\n\n<h2 id=\"fixed-intervals-and-register-constraints\">Fixed intervals and register constraints?</h2>\n\n<p>Mössenböck2002 also tackles register constraints with this notion of “fixed\nintervals”—intervals that have been pre-allocated physical registers.</p>\n\n<p>Since I eventually want to use “register hinting” from Wimmer2005 and\nWimmer2010, I’m going to ignore the fixed interval part of Mössenböck2002 for\nnow. It seems like they work nicely together.</p>\n\n<h2 id=\"wrapping-up\">Wrapping up</h2>\n\n<p>We added lifetime holes to our register allocator without too much effort. This\nbetter maps the graph-like nature of the IR onto the linear sequence of\ninstructions and should get us some better allocation for short-lived virtual\nregisters.</p>\n\n<p>Maybe next time we will add <em>interval splitting</em>, which will help us a) address\nABI constraints more cleanly in function calls and b) remove the dependence on\nreserving a scratch register.</p>",
  "id": "https://bernsteinbear.com/blog/linear-scan-lifetime-holes/"
}