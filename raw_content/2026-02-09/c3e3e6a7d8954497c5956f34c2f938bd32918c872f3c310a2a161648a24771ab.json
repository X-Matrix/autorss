{
  "title": "Recent improvements to Redis Lua scripting",
  "link": "http://antirez.com/news/97",
  "published": "Thu, 19 Nov 2015 12:23:27 +0100",
  "summary": "Lua scripting is probably the most successful Redis feature, among the ones introduced when Redis was already pretty popular: no surprise that a few of the things users really want are about scripting. The following two features were suggested multiple times over the last two years, and many people tried to focus my attention into one or the other during the Redis developers meeting, a few weeks ago.\n<br />\n<br />1. A proper debugger for Redis Lua scripts.\n<br />2. Replication, and storage on the AOF, of Lua scripts as a set of write commands materializing the *effects* of the script, instead of replicating the script itself as we normally do.\n<br />\n<br />The second feature is not just a matter of how scripts are replicated, but also touches what you can do with Lua scripting as we will see later.\n<br />\n<br />Back from London, I implemented both the features. This blog post describes both, giving a few hints about the design and implementation aspects that may be interesting for the readers.\n<br />\n<br />A proper Lua debugger\n<br />---\n<br />\n<br />Lua scripting was initially conceived in order to write really trivial scripts. Things like: if the key exists do this. A couple of lines in order to avoid bloating Redis with all the possible variations of commands. Of course users did a lot more with it, and started to write complex scripts: from quad-tree implementations to full featured messaging systems with non trivial semantics. Lua scripting makes Redis programmable, and usually programmers can’t resist to programmable things. It helps that all the Lua scripts run using the same interpreter and are cached, so they are very fast. It is most of the time possible to do a lot more with a Redis instance by using Lua scripting, both functionally and in terms of operations per second. So complex scripts totally have their place today. We went from a very cold reception of the scripting feature (something as dynamic as a script sent to a database!), to mass usage, to writing complex scripts in a matter of a few years.\n<br />\n<br />However writing simple scripts and writing complex scripts is a completely different matter. Bigger programs become exponentially more complex, and you can feel this even when going from 10 to 200 lines of code. While you can debug by brute force any simple script, just trying a few variants and observing the effects on the data set, or putting a few logging instructions in the middle, with complex scripts you have a bad time without a debugger.\n<br />\n<br />My colleague Itamar Haber used a lot of his time to write complex scripts recently. At some point he also wrote some kind of debugger for Redis Lua scripting using the Lua debug library. This debugger no longer works since the debug library is now no longer exposed to scripts, for sandboxing concerns, and in general, what you want in a Redis debugger is an interactive and remote debugger, with a proper client able to work alongside with the server, to provide a good debugging experience. Debugging is already a lot of hard work, to have solid tools is really a must. The only way to accomplish this result, was to add proper debugging support inside Redis itself.\n<br />\n<br />So back from London Itamar and I started to talk about what a debugger should export to the user in order to be kinda of useful, and a real upgrade compared to the past. It was also discussed to just add support for the Lua debuggers that already exist outside the Redis ecosystem. However I strongly believe the user experience is enhanced when everything is designed specifically to work well with Redis, so in the end I decided to wrote the debugger from scratch. A few things were sure: we needed a remote debugger where you could attach to Redis, start a debugging session, have good observability of what the script was doing with the Redis dataset. A special concern of mine was to have colorized output, of course ;-) I wanted to make debugging a fun experience, and to have a very fast learning curve, which are related.\n<br />\n<br />Now to show how a debugger work, by writing a blog post about it, is surely possible but, even a purist like me writing articles in courier, will resort to a video from time to time. So here is longish video showing the main features of the Redis debugger. I start talking like a bit depressed since this was early in the morning, but after a few minutes coffee fires in and you’ll se me more happy.\n<br />\n<br />(Hint: watch the video in full screen to have acceptable font size for the interactive session. Video is high quality enough to make them readable)\n<br />\n<br />!~!\n<br />\n<br />If you are not into playing videos, a short recap of what you can do with the Lua debugger is provided by the debugger help screen itself:\n<br />\n<br />$ ./redis-cli --ldb --eval /tmp/script.lua\n<br />Lua debugging session started, please use:\n<br />quit    -- End the session.\n<br />restart -- Restart the script in debug mode again.\n<br />help    -- Show Lua script debugging commands.\n<br />\n<br />* Stopped at 1, stop reason = step over\n<br />-> 1   local src = KEYS[1]\n<br />lua debugger> help\n<br />Redis Lua debugger help:\n<br />[h]elp               Show this help.\n<br />[s]tep               Run current line and stop again.\n<br />[n]ext               Alias for step.\n<br />[c]continue          Run till next breakpoint.\n<br />[l]list              List source code around current line.\n<br />[l]list [line]       List source code around [line].\n<br />                     line = 0 means: current position.\n<br />[l]list [line] [ctx] In this form [ctx] specifies how many lines\n<br />                     to show before/after [line].\n<br />[w]hole              List all source code. Alias for 'list 1 1000000'.\n<br />[p]rint              Show all the local variables.\n<br />[p]rint <var>        Show the value of the specified variable.\n<br />                     Can also show global vars KEYS and ARGV.\n<br />[b]reak              Show all breakpoints.\n<br />[b]reak        Add a breakpoint to the specified line.\n<br />[b]reak -      Remove breakpoint from the specified line.\n<br />[b]reak 0            Remove all breakpoints.\n<br />[t]race              Show a backtrace.\n<br />[e]eval <code>       Execute some Lua code (in a different callframe).\n<br />[r]edis         Execute a Redis command.\n<br />[m]axlen [len]       Trim logged Redis replies and Lua var dumps to len.\n<br />                     Specifying zero as  means unlimited.\n<br />[a]abort             Stop the execution of the script. In sync\n<br />                     mode dataset changes will be retained.\n<br />\n<br />Debugger functions you can call from Lua scripts:\n<br />redis.debug()        Produce logs in the debugger console.\n<br />redis.breakpoint()   Stop execution like if there was a breakpoing.\n<br />                     in the next line of code.\n<br />lua debugger>\n<br />\n<br />How it works?\n<br />---\n<br />\n<br />The whole debugger is pretty much a self contained block of code, and consists of 1300 lines of code, mostly inside scripting.c, but a few inside redis-cli.c, in order to implement the CLI special mode acting as a client for the debugger. As already said this is a server-client remote debugger.\n<br />\n<br />The Lua C API has a debugging interface that’s pretty useful. Is not a debugger per-se, but offers the primitives you need in order to write a debugger. However writing a debugger in the context of Redis was a bit less trivial that writing a Lua stand-alone debugger. In order to debug the script you have callbacks executed while the script is running. But when Redis is running a script, we are in the context of EVAL, executing a client command. How to do I/O there if we are blocked? Also what happens to the Redis server? Even if debugging must be performed in a development server and not into a production server, to completely hang the instance may not be a good idea. Maybe other developers want to use the instance, or the single developer that is debugging the script wants to create a new parallel debugging session. And finally, what about rolling back the changes so that the same script can be tested again and again with the same Redis data set, regardless of the changes it does while we are debugging? Determinism is gold in the context of debugging.\n<br />\n<br />So I needed a complex implementation, apparently. Or I needed to cheat big time, and find a strange solution to the problem involving a lot less code and complexity, but giving 90% of the benefits I was looking for. This odd solution turned out to be the following:\n<br />\n<br />* When a debugging session starts, fork() Redis.\n<br />* Capture the client file descriptor, and do direct, blocking I/O while the debugging session is active.\n<br />* Use the Redis protocol, but a trivial subset that can be implemented in a couple of lines of code, so that we don’t re-enter the Redis event loop at all. The I/O is part of the debugger.\n<br />\n<br />After 400 lines of code I had all the basic working, so the rest was just a matter of adding features and fixing bugs and corner cases.\n<br />\n<br />This gives us everything we needed: the server is not blocked since each debugging session is a separated process. We don’t need to re-enter the event loop from within the middle of an EVAL call, and we have rollback for free.\n<br />\n<br />However, there is also a synchronous mode available, that blocks the server, in the case you really need to debug something while preserving the changes to the dataset. I’ve the feeling this will not be used much at all but to add this mode was a matter of not forking and handling the cleanup of the client at the end, so I added this mode as well.\n<br />\n<br />On top of that it was possible to add everything else using a Lua “line” hook in order to implement stepping and breakpoints. Since the debugger is integrated inside Redis itself, it was trivial to capture all the Redis calls to show the user what was happening. The I/O model is also trivial, we just read input from the user and output appending to a buffer. Every time the debugger stops at some point, the output is flushed to the client as an array of “status replies”. The prefix of each line hints redis-cli about the colorization to provide.\n<br />\n<br />Because of this design, the debugger was working after 2 days and was complete after 4 days of work. Moreover this design allowed me to write completely self contained code, so the debugger interacts almost zero with the rest of Redis. This will make possible to release it with Redis 3.2 in December.\n<br />\n<br />A simple way to make the debugger much more powerful almost for free was to\n<br />add two new Redis Lua calls: redis.breakpoint() and redis.debug(), that\n<br />respectively can simulate a breakpoint inside the debugger (to the next line\n<br />to be executed), or log Lua objects in the debugger console. This way you can\n<br />add breakpoints that only fire when something interesting happens:\n<br />\n<br />    if some_odd_condition then redis.breakpoint() end\n<br />\n<br />This effectively replaces a lot of complex features you may add into a debugger.\n<br />However we also have all the normal features directly inside the debugger,\n<br />like static breakpoints, the ability to observe the state, and so forth.\n<br />\n<br />I’m very interested in what users writing complex scripts will think about it!\n<br />We’ll see.\n<br />\n<br />Script effects replication\n<br />---\n<br />\n<br />Before understanding why replicating just the *effects* of a script is interesting, it’s better to understand why instead by default replicating the script itself, to be re-executed by slaves, was considered the best option and is anyway the default. The central matter is: bandwidth between the master and the salve, and in general the ability of the slave to “follow” the master (keep in sync without too much delay) and don’t lag behind.\n<br />\n<br />Think at this small Redis Lua script:\n<br />\n<br />    local i;\n<br />    for i=0,1000000 do\n<br />        redis.call(“lpush”,KEYS[1],ARGV[1])\n<br />    end\n<br />\n<br />It appends 1 million elements to the specified list and runs in 0.75 seconds in my testing environment. It’s just a few bytes, and runs inside the server, so replicating this script as script, and not as the 1 million commands resulting from the script execution, makes a lot of sense.\n<br />\n<br />There are scripts which are exactly the opposite. At the other side of the spectrum there is a script that calculates the average of 1 million integer elements stored into a list, and stores the result setting some key with SET.\n<br />\n<br />The effect of the script could be just: SET somekey 94.29\n<br />\n<br />But the actual execution is maybe 2 seconds of computation. Replicating this script as the resulting command is much better. However there is a difference between replicating scripts and replicating effects: both are optimal or suboptimal depending on the use case, but replicating scripts always work, even when it’s inefficient. It never creates a situation where the replication link has to transfer huge amount of data, nor it creates a situation where the slave has to do a lot more work than the master. This is why so far Redis always used to replicate scripts verbatim.\n<br />\n<br />However the most interesting part perhaps is that’s not just a matter of efficiency. When replicating scripts we need that each script is a *pure function*. Scripts executed with the same initial dataset, must produce always the same result. This requirement, prevents users from writing scripts using, for example, the TIME command, or SRANDMEMBER. Redis detects this dangerous condition and stops the script as soon as the first write command is going to be called.\n<br />\n<br />Yet there are many use cases for scripts using the current time, random numbers or random elements. Replicating the effects of the script also overcomes this limitation.\n<br />\n<br />So finally, and thanks to refactoring performed inside Redis in the previous months, it was possible to implement opt-in support for scripts effects replication. It is as trivial as calling, at the start of the script, the following command:\n<br />\n<br />    redis.replicate_commands()\n<br />    … do something with the script …\n<br />\n<br />The script will be replicated only as a set of write commands.\n<br />Actually there is no need to call replicate_commands() as the first command. It is enough to call it before any write, so the Lua script may even check the work to do and select the right replication model. If writes were already performed when replicate_commands() is called, it just returns false, and the normal whole script replication will be used, so the command will never prevent the script from running, even when misused.\n<br />\n<br />However we did not resisted to the temptation of doing more advanced and possibly dangerous things. I designed this feature with my colleague Yossi Gottleib from Redis Labs, and he had a very compelling use case for a dangerous feature allowing the exclusion of selected commands from the replication stream.\n<br />\n<br />The idea is that your script may do something like that:\n<br />\n<br />1) Call certain commands that write temporary values. Think at intersections between sets just to have a mental model.\n<br />2) Perform some aggregation.\n<br />3) Store a small result as the effect of the script.\n<br />4) Discard the temporary values.\n<br />\n<br />There are a few legitimate use cases for the above pattern, and guess what, you don’t want to replicate the temporary writes to your AOF and slaves. You want replicate just step “3”. So in the end we decided that, when script effects replication is enabled, it is possible for the brave user, to select what replicate and what not, by using the following API:\n<br />\n<br />    redis.set_repl(redis.REPL_ALL); -- The default\n<br />    redis.set_repl(redis.REPL_NONE); -- No replication at all\n<br />    redis.set_repl(redis.REPL_AOF); -- Just AOF replication\n<br />    redis.set_repl(redis.REPL_SLAVE); -- Just slaves replication\n<br />\n<br />There is a lot of room for misuse, but non expert users are very unlikely to touch this feature at all, and it can benefit who knows what to do with powerful tools.\n<br />\n<br />ETA\n<br />---\n<br />\n<br />Both features will be available into Redis 3.2, that will be out as an RC in mid December 2015.\n<br />Redis 3.2 is going to have many interesting new features at API level, exposed to users. A big part of the user base asked for this, after a period where we focused more into operations and internals maturity.\n<br />\n<br />Feel free to ask questions in the comments if you want to know more or have any doubt.\n<br />\n<br />Hacker News thread is here: https://news.ycombinator.com/item?id=10594236\n<a href=\"http://antirez.com/news/97\">Comments</a>",
  "id": "http://antirez.com/news/97"
}