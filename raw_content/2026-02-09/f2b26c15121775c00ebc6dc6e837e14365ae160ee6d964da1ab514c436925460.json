{
  "title": "Liveness analysis with Datalog",
  "link": "https://bernsteinbear.com/blog/liveness-datalog/?utm_source=rss",
  "published": "Wed, 13 Aug 2025 00:00:00 +0000",
  "summary": "<p>After publishing <a href=\"/blog/linear-scan\">Linear scan register allocation on SSA</a>, I\nhad a nice call with <a href=\"https://waleedkhan.name\">Waleed Khan</a> where he showed me\nhow to Datalog. He thought it might be useful to try implementing liveness\nanalysis as a Datalog problem.</p>\n\n<p>We started off with the Wimmer2010 CFG example from that post, sketching out\nmanually which variables were live out of each block: R10 out of B1, R12 out of\nB2, etc.</p>\n\n<figure>\n\n<figcaption>\n    <p>The graph from Wimmer2010 has come back! Remember, we’re using block arguments\ninstead of phis, so <code class=\"language-plaintext highlighter-rouge\">B1(R10, R11)</code> defines R10 and R11 before the first\ninstruction in B1.</p>\n  </figcaption>\n</figure>\n\n<p>Then we tried to formulate liveness as a Datalog relation.</p>\n\n<p>Liveness is normally (at least for me) defined in terms of two relations:\nlive-in and live-out. Live-out is “what is needed” from all of the successors\nof a block and live-in is the “what is needed” summary for a block. So, in\nfake math notation:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>live-out(b) = union(live-in(s) for each successor s of b)\nlive-in(b) = (live-out(b) + used(b)) - defined(b)\n</code></pre></div></div>\n\n<p>where each of the component parts of that expression represent sets of\nvariables:</p>\n\n<ul>\n  <li><em>used(b)</em> is the set of variables referenced as in-operands to instructions in\na block</li>\n  <li><em>defined(b)</em> is the set of variables defined by instructions in a block</li>\n</ul>\n\n<p>We ended up computing the live-in sets for blocks in the register allocator\npost but then using the live-out sets instead. So today let’s compute both\nlive-in and live-out sets with Datalog!</p>\n\n<h2 id=\"datalog\">Datalog</h2>\n\n<p>Datalog is a logic programming language. It probably looks and feels different\nfrom every other programming language you have used… except for maybe SQL. It\nmight feel similar to SQL, except SQL has a certain order to it that Datalog\ndoes not.</p>\n\n<p>We’ll be using Souffle here because Waleed mentioned it and also I learned a\nbit about it in my databases class.</p>\n\n<p>The thing you do first is define your relations, which is what Datalog calls a\ntable.</p>\n\n<p>In this case, if we want to compute liveness information, we have to know\ninformation about what a block uses, defines, and what successors it has.</p>\n\n<p>First, the thing you have to know about Datalog, is that it’s kind of like\nthe opposite of array programming. We’re going to express things about sets by\nexpressing facts about individual items in a set.</p>\n\n<p>For example, we’re not going to say “this block B4 uses [R10, R12, R16]”. We’re\ngoing to say three separate facts: “B4 uses R10”, “B4 uses R12”, “B4 uses R16”.\nYou can think about it like each relation being a database table where each\nparameter is a column name.</p>\n\n<p>Here are the relations for block uses, block defs, and which blocks follow\nother blocks:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// liveness.dl\n.decl block_use(block:symbol, var:symbol)\n.decl block_def(block:symbol, var:symbol)\n.decl block_succ(succ:symbol, pred:symbol)\n</code></pre></div></div>\n\n<p>Where <code class=\"language-plaintext highlighter-rouge\">symbol</code> here means string.</p>\n\n<p>We can then embed some facts inline. For example, this says “A defines R0 and\nR1 and uses R0”:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>block_def(\"A\", \"R0\").\nblock_def(\"A\", \"R1\").\nblock_use(\"A\", \"R0\").\n</code></pre></div></div>\n\n<p>You can also provide facts as a TSV but this file format is so irritating to\nconstruct manually and has given me silently wrong answers in Souffle before so\nI am not doing that for this example.</p>\n\n<p>You can, for your edification, manually encode all the use/def/successor facts\nfrom the previous post into Souffle—or you can copy this chunk into your file:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// liveness.dl\n// ...\nblock_def(\"B1\", \"R10\").\nblock_def(\"B1\", \"R11\").\nblock_use(\"B1\", \"R11\").\n\nblock_def(\"B2\", \"R12\").\nblock_def(\"B2\", \"R13\").\nblock_use(\"B2\", \"R13\").\n\nblock_def(\"B3\", \"R14\").\nblock_def(\"B3\", \"R15\").\nblock_use(\"B3\", \"R12\").\nblock_use(\"B3\", \"R13\").\nblock_use(\"B3\", \"R14\").\nblock_use(\"B3\", \"R15\").\n\nblock_def(\"B4\", \"R16\").\nblock_use(\"B4\", \"R16\").\nblock_use(\"B4\", \"R10\").\nblock_use(\"B4\", \"R12\").\n\nblock_succ(\"B2\", \"B1\").\nblock_succ(\"B3\", \"B2\").\nblock_succ(\"B2\", \"B3\").\nblock_succ(\"B4\", \"B2\").\n</code></pre></div></div>\n\n<p>We can declare our live-in and live-out relations similarly to our use/def/succ\nrelations. We mark them as being <code class=\"language-plaintext highlighter-rouge\">.output</code> so that Souffle presents us with the\nresults.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// liveness.dl\n// ...\n.decl live_out(block:symbol, var:symbol)\n.output live_out\n.decl live_in(block:symbol, var:symbol)\n.output live_in\n</code></pre></div></div>\n\n<p>Now it’s time to define our relations. You may notice that the Souffle\ndefinitions look very similar to our earlier definitions. This is no mistake;\nDatalog was created for dataflow and graph problems.</p>\n\n<p>We’ll start with live-out:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// liveness.dl\n// ...\nlive_out(b, v) :- block_succ(s, b), live_in(s, v).\n</code></pre></div></div>\n\n<p>We read this left to right as “a variable <code class=\"language-plaintext highlighter-rouge\">v</code> is live-out of block <code class=\"language-plaintext highlighter-rouge\">b</code> if block\n<code class=\"language-plaintext highlighter-rouge\">s</code> is a successor of <code class=\"language-plaintext highlighter-rouge\">b</code> and <code class=\"language-plaintext highlighter-rouge\">v</code> is live-in to <code class=\"language-plaintext highlighter-rouge\">s</code>”. The <code class=\"language-plaintext highlighter-rouge\">:-</code> defines the left\nside in terms of the right side. The comma between <code class=\"language-plaintext highlighter-rouge\">block_succ</code> and <code class=\"language-plaintext highlighter-rouge\">live_in</code>\nmeans it’s a conjunction—<em>and</em>.</p>\n\n<p>Where’s the union? Well, remember what I said about array programming? We’re\nnot thinking in terms of sets. We’re thinking one program variable at a time.\nAs Souffle executes our relations, <code class=\"language-plaintext highlighter-rouge\">live_out</code> will incrementally build up a\ntable.</p>\n\n<p>It’s also a little weird to program in this style because <code class=\"language-plaintext highlighter-rouge\">s</code> wasn’t textually\ndefined anywhere like a parameter or a variable. You kind of have to think of\n<code class=\"language-plaintext highlighter-rouge\">s</code> as connector, a binder, a foreign key—what have you. It’s a placeholder.\n(I don’t know how to explain this well. Sorry.)</p>\n\n<p>Then we can define live-in. This on the surface looks more complicated but I\nthink that is only because of Souffle’s choice of syntax.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// liveness.dl\n// ...\nlive_in(b, v) :- (live_out(b, v) ; block_use(b, v)), !block_def(b, v).\n</code></pre></div></div>\n\n<p>It reads as “a variable <code class=\"language-plaintext highlighter-rouge\">v</code> is live-in to <code class=\"language-plaintext highlighter-rouge\">b</code> if it is either live-out of <code class=\"language-plaintext highlighter-rouge\">b</code>\nor used in <code class=\"language-plaintext highlighter-rouge\">b</code>, and <em>not</em> defined in <code class=\"language-plaintext highlighter-rouge\">b</code>. The semicolons are\ndisjunctions—<em>or</em>—and the exclamation points negations—<em>not</em>.</p>\n\n<p>These relations look endlessly mutually recursive but you have to keep in mind\nthat we’re not running functions on data, exactly. We’re declaratively\nexpressing definitions of rules—relations. <code class=\"language-plaintext highlighter-rouge\">block_use(b, v)</code> in the body of\n<code class=\"language-plaintext highlighter-rouge\">live_in</code> is not calling a function but instead making a query—is the row\n<code class=\"language-plaintext highlighter-rouge\">(b, v)</code> in the table <code class=\"language-plaintext highlighter-rouge\">block_use</code>? Datalog builds the tables until saturation.</p>\n\n<p>Now we can run Souffle! We tell it to dump to standard output with <code class=\"language-plaintext highlighter-rouge\">-D-</code> but\nyou could just as easily have it dump each output relation in its own separate\nfile in the current directory by specifying <code class=\"language-plaintext highlighter-rouge\">-D.</code>.</p>\n\n<div class=\"language-console highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"gp\">$</span><span class=\"w\"> </span>souffle <span class=\"nt\">-D-</span> liveness.dl\n<span class=\"go\">---------------\nlive_in\nblock   var\n===============\nB2      R10\nB3      R10\nB3      R12\nB3      R13\nB4      R10\nB4      R12\n===============\n---------------\nlive_out\nblock   var\n===============\nB1      R10\nB2      R10\nB2      R12\nB2      R13\nB3      R10\n===============\n</span><span class=\"gp\">$</span><span class=\"w\">\n</span></code></pre></div></div>\n\n<p>That’s neat. We got nicely formatted tables and it only took us two lines of\ncode! Let’s compare to our Ruby code from the previous post to underscore the\npoint:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">analyze_liveness</span>\n  <span class=\"n\">order</span> <span class=\"o\">=</span> <span class=\"n\">post_order</span>\n  <span class=\"n\">gen</span><span class=\"p\">,</span> <span class=\"n\">kill</span> <span class=\"o\">=</span> <span class=\"n\">compute_initial_liveness_sets</span><span class=\"p\">(</span><span class=\"n\">order</span><span class=\"p\">)</span>\n  <span class=\"n\">live_in</span> <span class=\"o\">=</span> <span class=\"no\">Hash</span><span class=\"p\">.</span><span class=\"nf\">new</span> <span class=\"mi\">0</span>\n  <span class=\"n\">changed</span> <span class=\"o\">=</span> <span class=\"kp\">true</span>\n  <span class=\"k\">while</span> <span class=\"n\">changed</span>\n    <span class=\"n\">changed</span> <span class=\"o\">=</span> <span class=\"kp\">false</span>\n    <span class=\"k\">for</span> <span class=\"n\">block</span> <span class=\"k\">in</span> <span class=\"n\">order</span>\n      <span class=\"n\">block_live</span> <span class=\"o\">=</span> <span class=\"n\">block</span><span class=\"p\">.</span><span class=\"nf\">successors</span><span class=\"p\">.</span><span class=\"nf\">map</span> <span class=\"p\">{</span> <span class=\"o\">|</span><span class=\"n\">succ</span><span class=\"o\">|</span> <span class=\"n\">live_in</span><span class=\"p\">[</span><span class=\"n\">succ</span><span class=\"p\">]</span> <span class=\"p\">}.</span><span class=\"nf\">reduce</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"ss\">:|</span><span class=\"p\">)</span>\n      <span class=\"n\">block_live</span> <span class=\"o\">|=</span> <span class=\"n\">gen</span><span class=\"p\">[</span><span class=\"n\">block</span><span class=\"p\">]</span>\n      <span class=\"n\">block_live</span> <span class=\"o\">&amp;=</span> <span class=\"o\">~</span><span class=\"n\">kill</span><span class=\"p\">[</span><span class=\"n\">block</span><span class=\"p\">]</span>\n      <span class=\"k\">if</span> <span class=\"n\">live_in</span><span class=\"p\">[</span><span class=\"n\">block</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"n\">block_live</span>\n        <span class=\"n\">changed</span> <span class=\"o\">=</span> <span class=\"kp\">true</span>\n        <span class=\"n\">live_in</span><span class=\"p\">[</span><span class=\"n\">block</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">block_live</span>\n      <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n  <span class=\"n\">live_in</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>This is because we have separated the iteration-to-fixpoint bit from the main\nbit of the dataflow analysis: the equation. If we let Datalog do the data\nmovement for us, we can work on defining the rules—and only the rules.</p>\n\n<blockquote>\n  <p>This is probably why, in the fullness of time, many static analysis and\ncompiler tools end up growing some kind of embedded (partial) Datalog engine.\nCall it Scholz’s tenth rule.</p>\n</blockquote>\n\n<p>Souffle also has the ability to compile to C++, which gives you two nice\nthings:</p>\n\n<ol>\n  <li>you can probably get faster execution</li>\n  <li>you can use it from an existing C++ program</li>\n</ol>\n\n<p>I don’t have any experience with this API.</p>\n\n<p>This is when Waleed mentioned offhandedly that he had heard about some embedded\nRust datalog called <a href=\"https://s-arash.github.io/ascent/\">Ascent</a>.</p>\n\n<h2 id=\"rust\">Rust</h2>\n\n<p>The front page of the Ascent website is a really great sell if you show up\nthinking “gee, I wish I had Datalog to use in my Rust program”. Right out the\ngate, you get reasonable-enough Datalog syntax via a proc macro.</p>\n\n<p>For example, here is the canonical path example for Souffle:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>.decl edge(x:number, y:number)\n.decl path(x:number, y:number)\n\npath(x, y) :- edge(x, y).\npath(x, y) :- path(x, z), edge(z, y).\n</code></pre></div></div>\n\n<p>and in Ascent:</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">ascent!</span> <span class=\"p\">{</span>\n   <span class=\"n\">relation</span> <span class=\"nf\">edge</span><span class=\"p\">(</span><span class=\"nb\">i32</span><span class=\"p\">,</span> <span class=\"nb\">i32</span><span class=\"p\">);</span>\n   <span class=\"n\">relation</span> <span class=\"nf\">path</span><span class=\"p\">(</span><span class=\"nb\">i32</span><span class=\"p\">,</span> <span class=\"nb\">i32</span><span class=\"p\">);</span>\n\n   <span class=\"nf\">path</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"o\">&lt;--</span> <span class=\"nf\">edge</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">);</span>\n   <span class=\"nf\">path</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">z</span><span class=\"p\">)</span> <span class=\"o\">&lt;--</span> <span class=\"nf\">edge</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">),</span> <span class=\"nf\">path</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">z</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>Super.</p>\n\n<p>We weren’t sure if the Souffle liveness would port cleanly to Rust, but it sure\ndid! It even lets you use your own datatypes instead of just <code class=\"language-plaintext highlighter-rouge\">i32</code> (which the\nfront-page example uses).</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">use</span> <span class=\"nn\">ascent</span><span class=\"p\">::</span><span class=\"n\">ascent</span><span class=\"p\">;</span>\n\n<span class=\"nd\">#[derive(Clone,</span> <span class=\"nd\">PartialEq,</span> <span class=\"nd\">Eq,</span> <span class=\"nd\">Hash,</span> <span class=\"nd\">Copy)]</span>\n<span class=\"k\">struct</span> <span class=\"nf\">BlockId</span><span class=\"p\">(</span><span class=\"nb\">i32</span><span class=\"p\">);</span>\n\n<span class=\"k\">impl</span> <span class=\"nn\">std</span><span class=\"p\">::</span><span class=\"nn\">fmt</span><span class=\"p\">::</span><span class=\"n\">Debug</span> <span class=\"k\">for</span> <span class=\"n\">BlockId</span> <span class=\"p\">{</span>\n    <span class=\"k\">fn</span> <span class=\"nf\">fmt</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">self</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"k\">mut</span> <span class=\"nn\">std</span><span class=\"p\">::</span><span class=\"nn\">fmt</span><span class=\"p\">::</span><span class=\"n\">Formatter</span><span class=\"o\">&lt;</span><span class=\"nv\">'_</span><span class=\"o\">&gt;</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"nn\">std</span><span class=\"p\">::</span><span class=\"nn\">fmt</span><span class=\"p\">::</span><span class=\"nb\">Result</span> <span class=\"p\">{</span>\n        <span class=\"nd\">write!</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"s\">\"B{}\"</span><span class=\"p\">,</span> <span class=\"k\">self</span><span class=\"na\">.0</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"nd\">#[derive(Clone,</span> <span class=\"nd\">PartialEq,</span> <span class=\"nd\">Eq,</span> <span class=\"nd\">Hash,</span> <span class=\"nd\">Copy)]</span>\n<span class=\"k\">struct</span> <span class=\"nf\">VarId</span><span class=\"p\">(</span><span class=\"nb\">i32</span><span class=\"p\">);</span>\n\n<span class=\"k\">impl</span> <span class=\"nn\">std</span><span class=\"p\">::</span><span class=\"nn\">fmt</span><span class=\"p\">::</span><span class=\"n\">Debug</span> <span class=\"k\">for</span> <span class=\"n\">VarId</span> <span class=\"p\">{</span>\n    <span class=\"k\">fn</span> <span class=\"nf\">fmt</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">self</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">:</span> <span class=\"o\">&amp;</span><span class=\"k\">mut</span> <span class=\"nn\">std</span><span class=\"p\">::</span><span class=\"nn\">fmt</span><span class=\"p\">::</span><span class=\"n\">Formatter</span><span class=\"o\">&lt;</span><span class=\"nv\">'_</span><span class=\"o\">&gt;</span><span class=\"p\">)</span> <span class=\"k\">-&gt;</span> <span class=\"nn\">std</span><span class=\"p\">::</span><span class=\"nn\">fmt</span><span class=\"p\">::</span><span class=\"nb\">Result</span> <span class=\"p\">{</span>\n        <span class=\"nd\">write!</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"s\">\"R{}\"</span><span class=\"p\">,</span> <span class=\"k\">self</span><span class=\"na\">.0</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"nd\">ascent!</span> <span class=\"p\">{</span>\n    <span class=\"n\">relation</span> <span class=\"nf\">block_use</span><span class=\"p\">(</span><span class=\"n\">BlockId</span><span class=\"p\">,</span> <span class=\"n\">VarId</span><span class=\"p\">);</span>\n    <span class=\"n\">relation</span> <span class=\"nf\">block_def</span><span class=\"p\">(</span><span class=\"n\">BlockId</span><span class=\"p\">,</span> <span class=\"n\">VarId</span><span class=\"p\">);</span>\n    <span class=\"n\">relation</span> <span class=\"nf\">block_succ</span><span class=\"p\">(</span><span class=\"n\">BlockId</span><span class=\"p\">,</span> <span class=\"n\">BlockId</span><span class=\"p\">);</span>  <span class=\"c1\">// (succ, pred)</span>\n    <span class=\"n\">relation</span> <span class=\"nf\">live_out</span><span class=\"p\">(</span><span class=\"n\">BlockId</span><span class=\"p\">,</span> <span class=\"n\">VarId</span><span class=\"p\">);</span>\n    <span class=\"n\">relation</span> <span class=\"nf\">live_in</span><span class=\"p\">(</span><span class=\"n\">BlockId</span><span class=\"p\">,</span> <span class=\"n\">VarId</span><span class=\"p\">);</span>\n    <span class=\"nf\">live_out</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"o\">&lt;--</span> <span class=\"nf\">block_succ</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">),</span> <span class=\"nf\">live_in</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">);</span>\n    <span class=\"nf\">live_in</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"o\">&lt;--</span> <span class=\"p\">(</span><span class=\"nf\">live_out</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"p\">|</span> <span class=\"nf\">block_use</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">)),</span> <span class=\"o\">!</span><span class=\"nf\">block_def</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// ...</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>Notice how we don’t have an <code class=\"language-plaintext highlighter-rouge\">input</code> or <code class=\"language-plaintext highlighter-rouge\">output</code> annotation like we did in\nDatalog. That’s because this is designed to be embedded in an existing program,\nwhich probably doesn’t to deal with the disk (or at least wants to read/write\nin its own format).</p>\n\n<p>Ascent lets us give it some vectors of data and then at the end lets us read\nsome vectors of data too.</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// ...</span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">let</span> <span class=\"k\">mut</span> <span class=\"n\">prog</span> <span class=\"o\">=</span> <span class=\"nn\">AscentProgram</span><span class=\"p\">::</span><span class=\"nf\">default</span><span class=\"p\">();</span>\n    <span class=\"k\">let</span> <span class=\"n\">b1</span> <span class=\"o\">=</span> <span class=\"nf\">BlockId</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"k\">let</span> <span class=\"n\">b2</span> <span class=\"o\">=</span> <span class=\"nf\">BlockId</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n    <span class=\"k\">let</span> <span class=\"n\">b3</span> <span class=\"o\">=</span> <span class=\"nf\">BlockId</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">);</span>\n    <span class=\"k\">let</span> <span class=\"n\">b4</span> <span class=\"o\">=</span> <span class=\"nf\">BlockId</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">);</span>\n    <span class=\"k\">let</span> <span class=\"n\">r10</span> <span class=\"o\">=</span> <span class=\"nf\">VarId</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">);</span>\n    <span class=\"k\">let</span> <span class=\"n\">r11</span> <span class=\"o\">=</span> <span class=\"nf\">VarId</span><span class=\"p\">(</span><span class=\"mi\">11</span><span class=\"p\">);</span>\n    <span class=\"k\">let</span> <span class=\"n\">r12</span> <span class=\"o\">=</span> <span class=\"nf\">VarId</span><span class=\"p\">(</span><span class=\"mi\">12</span><span class=\"p\">);</span>\n    <span class=\"k\">let</span> <span class=\"n\">r13</span> <span class=\"o\">=</span> <span class=\"nf\">VarId</span><span class=\"p\">(</span><span class=\"mi\">13</span><span class=\"p\">);</span>\n    <span class=\"k\">let</span> <span class=\"n\">r14</span> <span class=\"o\">=</span> <span class=\"nf\">VarId</span><span class=\"p\">(</span><span class=\"mi\">14</span><span class=\"p\">);</span>\n    <span class=\"k\">let</span> <span class=\"n\">r15</span> <span class=\"o\">=</span> <span class=\"nf\">VarId</span><span class=\"p\">(</span><span class=\"mi\">15</span><span class=\"p\">);</span>\n    <span class=\"k\">let</span> <span class=\"n\">r16</span> <span class=\"o\">=</span> <span class=\"nf\">VarId</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">);</span>\n    <span class=\"n\">prog</span><span class=\"py\">.block_def</span> <span class=\"o\">=</span> <span class=\"nd\">vec!</span><span class=\"p\">[</span>\n        <span class=\"p\">(</span><span class=\"n\">b1</span><span class=\"p\">,</span> <span class=\"n\">r10</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"n\">b1</span><span class=\"p\">,</span> <span class=\"n\">r11</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"n\">b2</span><span class=\"p\">,</span> <span class=\"n\">r12</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"n\">b2</span><span class=\"p\">,</span> <span class=\"n\">r13</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"n\">b3</span><span class=\"p\">,</span> <span class=\"n\">r14</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"n\">b3</span><span class=\"p\">,</span> <span class=\"n\">r15</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"n\">b4</span><span class=\"p\">,</span> <span class=\"n\">r16</span><span class=\"p\">),</span>\n    <span class=\"p\">];</span>\n    <span class=\"n\">prog</span><span class=\"py\">.block_succ</span> <span class=\"o\">=</span> <span class=\"nd\">vec!</span><span class=\"p\">[</span>\n        <span class=\"p\">(</span><span class=\"n\">b2</span><span class=\"p\">,</span> <span class=\"n\">b1</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"n\">b3</span><span class=\"p\">,</span> <span class=\"n\">b2</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"n\">b2</span><span class=\"p\">,</span> <span class=\"n\">b3</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"n\">b4</span><span class=\"p\">,</span> <span class=\"n\">b2</span><span class=\"p\">),</span>\n    <span class=\"p\">];</span>\n    <span class=\"n\">prog</span><span class=\"py\">.block_use</span> <span class=\"o\">=</span> <span class=\"nd\">vec!</span><span class=\"p\">[</span>\n        <span class=\"p\">(</span><span class=\"n\">b1</span><span class=\"p\">,</span> <span class=\"n\">r11</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"n\">b2</span><span class=\"p\">,</span> <span class=\"n\">r13</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"n\">b3</span><span class=\"p\">,</span> <span class=\"n\">r12</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"n\">b3</span><span class=\"p\">,</span> <span class=\"n\">r13</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"n\">b3</span><span class=\"p\">,</span> <span class=\"n\">r14</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"n\">b3</span><span class=\"p\">,</span> <span class=\"n\">r15</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"n\">b4</span><span class=\"p\">,</span> <span class=\"n\">r10</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"n\">b4</span><span class=\"p\">,</span> <span class=\"n\">r12</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"n\">b4</span><span class=\"p\">,</span> <span class=\"n\">r16</span><span class=\"p\">),</span>\n    <span class=\"p\">];</span>\n    <span class=\"n\">prog</span><span class=\"nf\">.run</span><span class=\"p\">();</span>\n    <span class=\"nd\">println!</span><span class=\"p\">(</span><span class=\"s\">\"live out: {:?}\"</span><span class=\"p\">,</span> <span class=\"n\">prog</span><span class=\"py\">.live_out</span><span class=\"p\">);</span>\n    <span class=\"nd\">println!</span><span class=\"p\">(</span><span class=\"s\">\"live in: {:?}\"</span><span class=\"p\">,</span> <span class=\"n\">prog</span><span class=\"py\">.live_in</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>Then we need only run <code class=\"language-plaintext highlighter-rouge\">cargo add ascent</code> and <code class=\"language-plaintext highlighter-rouge\">cargo run</code>—both of which worked\nwith zero issues—and see the results.</p>\n\n<div class=\"language-console highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"gp\">$</span><span class=\"w\"> </span>cargo run\n<span class=\"go\">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s\n     Running `target/debug/liveness`\nlive out: [(B2, R12), (B2, R13), (B2, R10), (B1, R10), (B3, R10)]\nlive in: [(B3, R12), (B3, R13), (B4, R10), (B4, R12), (B2, R10), (B3, R10)]\n</span><span class=\"gp\">$</span><span class=\"w\">\n</span></code></pre></div></div>\n\n<p>It’s not a fancy looking table, but it’s very close to my program, which is\nneat.</p>\n\n<p>This is similar to embedding Souffle in C++ and then calling the C++. One\ndifference, though, is the Souffle process has two steps. It’s a slight build\nsystem complication. But this isn’t meant to be a Datalog comparison post!</p>\n\n<h2 id=\"more\">More?</h2>\n\n<p>Can we model all of linear scan this way? Maybe. I’m new to all this stuff.</p>\n\n<p>Ascent also seems to support lattices, which means we can use it to do abstract\ninterpretation on some cool domains.</p>\n\n<p><a href=\"https://pointersgonewild.com/\">Maxime Chevalier-Boisvert</a> and I prototyped\n<a href=\"https://github.com/shopify/loupe\">loupe</a>, an interprocedural type analysis in\nRust. We had to build our own iterate-to-fixpoint engine, which was\nnon-trivial. I wonder how it would look to build something similar on top of\nAscent.</p>\n\n<p>I kind of want to check out <a href=\"https://github.com/frankmcsherry/\">Frank\nMcSherry</a>’s\n<a href=\"https://github.com/frankmcsherry/blog/blob/master/posts/2025-06-03.md\">datatoad</a>.</p>\n\n<h2 id=\"wrapping-up\">Wrapping up</h2>\n\n<p>That’s all for now, folks. Just a couple Datalog snippets. Happy hacking.</p>",
  "id": "https://bernsteinbear.com/blog/liveness-datalog/"
}