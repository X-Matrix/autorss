{
  "title": "Playing audio files in a Pi Pico without a DAC",
  "link": "http://antirez.com/news/143",
  "published": "Wed, 06 Mar 2024 11:52:34 +0100",
  "summary": "The Raspberry Pico is suddenly becoming my preferred chip for embedded development. It is well made, durable hardware, with a ton of features that appear designed with smartness and passion (the state machines driving the GPIOs are a killer feature!). Its main weakness, the lack of connectivity, is now resolved by the W variant. The data sheet is excellent and documents every aspect of the chip. Moreover, it is well supported by MicroPython (which I’m using a lot), and the C SDK environment is decent, even if full of useless complexities like today fashion demands: a cmake build system that in turn generates a Makefile, files to define this and that (used libraries, debug outputs, …), and in general a huge overkill for the goal of compiling tiny programs for tiny devices. No, it’s worse than that: all this complexity to generate programs for a FIXED hardware with a fixed set of features (if not for the W / non-W variant). Enough with the rant about how much today software sucks, but it must be remembered.\n<br />\n<br />One of the cool things one wants to do with an MCU like that, is generating some sound. The most obvious way to do this is using the built-in PWM feature of the chip. The GPIOs can be configured to just alterante between zero and one at the desired frequency, like that:\n<br />\n<br />from machine import Pin, PWM\n<br />pwm = PWM(Pin(1))\n<br />pwm.freq(400)\n<br />pwm.duty_u16(1000)\n<br />\n<br />Assuming you connected a piezo to GND and pin 1 of your Pico, you will hear a square wave sound at 400hz of frequency. Now, there are little sounds as terrible to hear as square waves. Maybe we can do better. I’ll skip all the intermediate steps here, like producing a sin wave, and directly jump to playing a wav file. Once you see how to do that, you can easily generate your own other waves (sin, noise, envelops for such waveforms and so forth).\n<br />\n<br />Now you are likely asking yourself: how can I generate the complex wave forms to play a wav file, if the Pico can only switch the pin high or low? A proper non square waveform is composed of different levels, so I would need a DAC! Fortunately we can do all this without a DAC at all, just a single pin of our Pico.\n<br />\n<br />### How complex sound generation works\n<br />\n<br />I don’t want to cover too much background here. But all you need to know is that, if you don’t want to generate a trivial square wave, that just alternates between a minimum and maximum level of output, you will need to have intermediate steps, like that:\n<br />\n<br />S0: #\n<br />S1: ####\n<br />S2: ######\n<br />S3: #######\n<br />S4: ########\n<br />\n<br />And so forth, where S0 is the first sample, S1, the second sample, …\n<br />\n<br />Each sample duration depends on the sampling frequency, that is how many times every second we change (when playing) or sample (when recording) the audio wave. This means that to play a complex sound, we need the ability of our Pico pin to output different voltages.\n<br />\n<br />There is a trick to do this with the Pico just using PWM, that is to use a square wave with a very high frequency, but with a different duty cycle for the different voltages we want to generate. So we set a very very high frequency output:\n<br />\n<br />pwm.freq(100000)\n<br />\n<br />Then, if we want to produce the S0 sample, we set the duty cycle (whose value is between 0 and 65535) to a small value. If we want to produce the S1 sample, we use a higher value, and so forth. In sequence we may want to do something like that:\n<br />\n<br />pwm.duty_u16(3000)   # S0\n<br />pwm.duty_u16(12000) # S1\n<br />pwm.duty_u16(18000) # S2\n<br />pwm.duty_u16(21000) # S3\n<br />pwm.duty_u16(24000) # S4\n<br />\n<br />The duty cycle is how much time the pin is set to 1 versus how much time the pin is set to 0. A duty cycle of 65535 means 100% of time pin high. 0% means all the time low. All this, while preserving the set alternating frequency. So if we zoom like if we have an oscilloscope, we can see what happens during S2 and S3 sample generation:\n<br />\n<br />S2:\n<br />######################\n<br />#\n<br />#\n<br />#\n<br />#\n<br />######################\n<br />#\n<br />#\n<br />#\n<br />#\n<br />\n<br />While S3 will be like:\n<br />######################\n<br />######################\n<br />#\n<br />#\n<br />#\n<br />######################\n<br />######################\n<br />#\n<br />#\n<br />#\n<br />\n<br />The pin goes up and down with the same frequency, but in the case of S3 it stays up more. This will produce a higher average voltage. This allows us to approximate our wave.\n<br />\n<br />### Convert and play a WAV file\n<br />\n<br />In order to play a wav file, we have to convert it into a raw format that is easy to read using MicroPython. I downloaded a wav file saying “Oh no!” from SoundCloud. So my conversion will look like this:\n<br />\n<br />ffmpeg -i ohno.wav -ar 24000 -acodec pcm_u8 -f u8 output.raw\n<br />\n<br />Note that we converted the file to 8 bit audio (256 different output levels per sample). Anyway our PWM trick is not going to approximate the different levels so well, and we are resource constrained. You can try with 16 bit as well, but I got decent results like this.\n<br />\n<br />Then, upload the output.raw file on the device via mpremote:\n<br />\n<br />mpremote cp output.raw :\n<br />\n<br />Now write a file called “play.py” or as you wish, with this content:\n<br />\n<br />from machine import Pin, PWM\n<br />\n<br />pwm = PWM(Pin(1))\n<br />pwm.freq(100000)\n<br />\n<br />f = open(\"output.raw\",\"rb\")\n<br />buf = bytearray(4096)\n<br />while f.readinto(buf) > 0:\n<br />    for sample in buf:\n<br />        pwm.duty_u16(sample<<8)\n<br />        x=1\n<br />        x=1\n<br />        x=1\n<br />        x=1\n<br />        x=1\n<br />f.close()\n<br />\n<br />What we are doing here is just getting the file, 4096 samples per iteration, then “playing” it by setting different PWM duty cycles one after the other, according to the samples values. The problem is, in our PCM file we have 24000 samples per second (see ffmpeg command line). How can be sure that it matches the MicroPython speed? well, indeed it is not a perfect match, so I added “x=1” statements to delay it a bit to kinda match the pitch that looked correct.\n<br />\n<br />Oh, and if you are wondering what the sample<<8 thing is, this is just to rescale a 8 bit sample to the full 16 bit precision needed to set the PWM duty cycle.\n<br />\n<br />The downside of all this is that it will take your program busy while playing. I didn’t test it yet, but MicroPython supports threading, so to have a thread playing the audio could be the way to go.\n<br />\n<br />### Bonus point: sin wave sound generation\n<br />\n<br /># Sin wave\n<br />wave=[]\n<br />wave_samples = 40\n<br />pwm.freq(100000)\n<br />for i in range(wave_samples):\n<br />    x = i/wave_samples*3.14*2\n<br />    dc = int((1+math.sin(x))*65000)\n<br />    wave.append(dc)\n<br />print(wave)\n<br />\n<br />for i in range(1000):\n<br />    for dc in wave: pwm.duty_u16(dc)\n<a href=\"http://antirez.com/news/143\">Comments</a>",
  "id": "http://antirez.com/news/143"
}