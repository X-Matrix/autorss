{
  "title": "The absurdly complicated circuitry for the 386 processor's registers",
  "link": "http://www.righto.com/2025/05/intel-386-register-circuitry.html",
  "published": "2025-05-01T10:04:00.000-07:00",
  "summary": "<p>The groundbreaking Intel 386 processor (1985) was the first 32-bit processor in the x86 architecture.\nLike most processors, the 386 contains numerous registers; registers are a key part of a processor because\nthey provide storage that is much faster than main memory.\nThe register set of the 386 includes general-purpose registers, index registers, and segment selectors, as well\nas registers with special functions for memory management and operating system implementation.\nIn this blog post, I look at the silicon die of the 386 and explain how the processor implements its main registers.</p>\n<p>It turns out that the circuitry that implements the 386's registers is much more complicated than one would expect.\nFor the 30 registers that I examine, instead of using a standard circuit, the 386 uses <em>six</em> different circuits,\neach one optimized for the particular characteristics of the register.\nFor some registers, Intel squeezes register cells together to double the storage capacity.\nOther registers support accesses of 8, 16, or 32 bits at a time.\nMuch of the register file is \"triple-ported\", allowing two registers to be read simultaneously while a value is written\nto a third register.\nFinally, I was surprised to find that registers don't store bits in order: the lower 16 bits of each register are interleaved, while the upper 16 bits are stored linearly.</p>\n<p>The photo below shows the 386's shiny fingernail-sized silicon die under a special metallurgical microscope.\nI've labeled the main functional blocks. \nFor this post, the Data Unit in the lower left quadrant of the chip is the relevant component.\nIt consists of the 32-bit arithmetic logic unit (ALU) along\nwith the processor's main register bank (highlighted in red at the bottom).\nThe circuitry, called the datapath, can be viewed as the heart of the processor.</p>\n<p><a href=\"https://static.righto.com/images/386-regs2/386-die-labeled.jpg\"><img alt=\"This die photo of the 386 shows the location of the registers. Click this image (or any other) for a larger version.\" class=\"hilite\" height=\"534\" src=\"https://static.righto.com/images/386-regs2/386-die-labeled-w500.jpg\" title=\"This die photo of the 386 shows the location of the registers. Click this image (or any other) for a larger version.\" width=\"500\" /></a><div class=\"cite\">This die photo of the 386 shows the location of the registers. Click this image (or any other) for a larger version.</div></p>\n<p>The datapath is built with a regular structure: each register or ALU functional unit is a horizontal stripe of circuitry,\nforming the horizontal bands visible in the image.\nFor the most part, this circuitry consists of a carefully optimized circuit copied 32 times, once for each bit of the processor.\nEach circuit for one bit is exactly the same width&mdash;60 µm&mdash;so the functional blocks can be stacked together like microscopic\nLEGO bricks.\nTo link these circuits, \nmetal bus lines run vertically through the datapath in groups of 32, allowing data to flow up and down through the blocks.\nMeanwhile, control lines run horizontally, enabling ALU operations or register reads and writes; the irregular circuitry\non the right side of the Data Unit produces the signals for these control lines, activating the appropriate control\nlines for each instruction.</p>\n<p>The datapath is highly structured to maximize performance while minimizing its area on the die.\nBelow, I'll look at how the registers are implemented according to this structure.</p>\n<h2>The 386's registers</h2>\n<p>A processor's registers are one of the most visible features of the processor architecture.\nThe 386 processor contains 16 registers for use by application programmers, a small number by modern standards,\nbut large enough for the time.\nThe diagram below shows the eight 32-bit general-purpose registers.\nAt the top are four registers called EAX, EBX, ECX, and EDX.\nAlthough these registers are 32-bit registers, they can also be treated as 16 or 8-bit registers for backward\ncompatibility with earlier processors.\nFor instance, the lower half of EAX can be accessed as the 16-bit register AX, while the bottom byte of EAX can\nbe accessed as the 8-bit register AL.\nMoreover, bits 15-8 can also be accessed as an 8-bit register called AH.\nIn other words, there are four different ways to access the EAX register, and similarly for the other three registers.\nAs will be seen, these features complicate the implementation of the register set.</p>\n<p><a href=\"https://static.righto.com/images/386-regs2/gp-registers.jpg\"><img alt=\"The general purpose registers in the 386. From 80386 Programmer's Reference Manual, page 2-8.\" class=\"hilite\" height=\"317\" src=\"https://static.righto.com/images/386-regs2/gp-registers-w350.jpg\" title=\"The general purpose registers in the 386. From 80386 Programmer's Reference Manual, page 2-8.\" width=\"350\" /></a><div class=\"cite\">The general purpose registers in the 386. From <a href=\"http://www.bitsavers.org/components/intel/80386/230985-001_80386_Programmers_Reference_Manual_1986.pdf#page=44\">80386 Programmer's Reference Manual</a>, page 2-8.</div></p>\n<p>The bottom half of the diagram shows that the 32-bit EBP, ESI, EDI, and ESP registers can also be treated as 16-bit registers BP, SI, DI, and SP. Unlike the previous registers,\nthese ones cannot be treated as 8-bit registers.\nThe 386 also has six segment registers that define the \nstart of memory segments; these are 16-bit registers.\nThe 16 application registers are rounded out by the status flags and instruction pointer (EIP);\nthey are viewed as 32-bit registers, but their implementation is more complicated.\nThe 386 also has numerous registers for operating system programming, but I won't discuss them here, since they\nare likely in other parts of the chip.<span id=\"fnref:system-regs\"><a class=\"ref\" href=\"#fn:system-regs\">1</a></span>\nFinally, the 386 has numerous temporary registers that are not visible to the programmer but are used by the microcode\nto perform complex instructions.</p>\n<h2>The 6T and 8T static RAM cells</h2>\n<p>The 386's registers are implemented with static RAM cells, a circuit that can hold one bit.\nThese cells are arranged into a grid to provide multiple registers.\nStatic RAM can be contrasted with the dynamic RAM that computers use for their main memory:\ndynamic RAM holds each bit in a tiny capacitor, while static RAM uses a faster but larger and more complicated circuit.\nSince main memory holds gigabytes of data, it uses dynamic RAM to provide dense and inexpensive storage.\nBut the tradeoffs are different for registers: the storage capacity is small, but speed is of the essence.\nThus, registers use the static RAM circuit that I'll explain below.</p>\n<p>The concept behind a static RAM cell is to connect two inverters into a loop.\nIf an inverter has a \"0\" as input, it will output a \"1\", and vice versa.\nThus, the inverter loop will be stable,\nwith one inverter on and one inverter off, and each inverter supporting the other.\nDepending on which inverter is on, the circuit stores a 0 or a 1, as shown below.\nThus, the pair of inverters provides one bit of memory.</p>\n<p><a href=\"https://static.righto.com/images/386-regs2/inverter-loop.png\"><img alt=\"Two inverters in a loop can store a 0 or a 1.\" class=\"hilite\" height=\"121\" src=\"https://static.righto.com/images/386-regs2/inverter-loop-w250.png\" title=\"Two inverters in a loop can store a 0 or a 1.\" width=\"250\" /></a><div class=\"cite\">Two inverters in a loop can store a 0 or a 1.</div></p>\n<p>To be useful, however, the inverter loop needs a way to store a bit into it, as well as a way to read out the stored bit.\nTo write a new value into the circuit, two signals are fed in, forcing the inverters to the desired new values.\nOne inverter receives the new bit value, while the other inverter receives the complemented bit value.\nThis may seem like a brute-force way to update the bit, but it works.\nThe trick is that the inverters in the cell are small and weak, while the input signals are higher current,\nable to overpower the inverters.<span id=\"fnref:flip\"><a class=\"ref\" href=\"#fn:flip\">2</a></span>\nThese signals are fed in through wiring called \"bitlines\"; the bitlines can also be used to read the value\nstored in the cell.</p>\n<p><a href=\"https://static.righto.com/images/386-regs2/simple-cell.png\"><img alt=\"By adding two pass transistors to the circuit, the cell can be read and written.\" class=\"hilite\" height=\"125\" src=\"https://static.righto.com/images/386-regs2/simple-cell-w350.png\" title=\"By adding two pass transistors to the circuit, the cell can be read and written.\" width=\"350\" /></a><div class=\"cite\">By adding two pass transistors to the circuit, the cell can be read and written.</div></p>\n<p>To control access to the register, \nthe bitlines are connected to the inverters through pass transistors, which act as switches to\ncontrol access to the inverter loop.<span id=\"fnref:pass\"><a class=\"ref\" href=\"#fn:pass\">3</a></span>\nWhen the pass transistors are on, the\nsignals on the write lines can pass through to the inverters. But when the pass transistors are off, the\ninverters are isolated from the write lines.\nThe pass transistors are turned on by a control signal, called a \"wordline\" since it controls access to a word\nof storage in the register.\nSince each inverter is constructed from two transistors, the circuit above consists of six transistors&mdash;thus this circuit is called a \"6T\" cell.</p>\n<p>The 6T cell uses the same bitlines for reading and writing, so you can't read and write to registers simultaneously.\nBut adding two transistors creates an \"8T\" circuit that lets you read from one register\nand write to another register at the same time. (In technical terms, the register file is two-ported.)\nIn the 8T schematic below, the two additional transistors (G and H) are used for reading.\nTransistor G buffers the cell's value; it turns on if the inverter output is high, pulling the read output bitline low.<span id=\"fnref:precharge\"><a class=\"ref\" href=\"#fn:precharge\">4</a></span>\nTransistor H is a pass transistor that blocks this signal until a read is performed on this register;\nit is controlled by a read wordline.\nNote that there are two bitlines for writing (as before) along with one bitline for reading.</p>\n<p><a href=\"https://static.righto.com/images/386-regs2/cell-schematic.png\"><img alt=\"Schematic of a storage cell. Each transistor is labeled with a letter.\" class=\"hilite\" height=\"155\" src=\"https://static.righto.com/images/386-regs2/cell-schematic-w500.png\" title=\"Schematic of a storage cell. Each transistor is labeled with a letter.\" width=\"500\" /></a><div class=\"cite\">Schematic of a storage cell. Each transistor is labeled with a letter.</div></p>\n<p>To construct registers (or memory), a grid is constructed from these cells.\nEach row corresponds to a register, while each column corresponds to a bit position.\nThe horizontal lines are the wordlines, selecting which word to access, while the\nvertical lines are the bitlines, passing bits in or out of the registers.\nFor a write, the vertical bitlines provide the 32 bits (along with their complements).\nFor a read, the vertical bitlines receive the 32 bits from the register.\nA wordline is activated to read or write the selected register.\nTo summarize: each row is a register, data flows vertically, and control signals flow horizontally.</p>\n<p><a href=\"https://static.righto.com/images/386-regs2/grid.png\"><img alt=\"Static memory cells (8T) organized into a grid.\" class=\"hilite\" height=\"433\" src=\"https://static.righto.com/images/386-regs2/grid-w500.png\" title=\"Static memory cells (8T) organized into a grid.\" width=\"500\" /></a><div class=\"cite\">Static memory cells (8T) organized into a grid.</div></p>\n<h2>Six register circuits in the 386</h2>\n<p>The die photo below zooms in on the register circuitry in the lower left corner of the 386 processor.\nYou can see the arrangement of storage cells into a grid, but note that the pattern changes from row to row.\nThis circuitry implements 30 registers: 22 of the registers hold 32 bits, while the bottom ones are 16-bit registers.\nBy studying the die, I determined that there are six different register circuits,\nwhich I've arbitrarily labeled (<em>a</em>) to (<em>f</em>).\nIn this section, I'll describe these six types of registers.</p>\n<p><a href=\"https://static.righto.com/images/386-regs2/registers-labeled.jpg\"><img alt=\"The 386's main register bank, at the bottom of the datapath.  The numbers show how many bits of the register can be accessed.\" class=\"hilite\" height=\"185\" src=\"https://static.righto.com/images/386-regs2/registers-labeled-w600.jpg\" title=\"The 386's main register bank, at the bottom of the datapath.  The numbers show how many bits of the register can be accessed.\" width=\"600\" /></a><div class=\"cite\">The 386's main register bank, at the bottom of the datapath.  The numbers show how many bits of the register can be accessed.</div></p>\n<p>I'll start at the bottom with the simplest circuit: eight 16-bit registers that I'm calling type (<em>f</em>).\nYou can see a \"notch\" on the left side of the register file\nbecause these registers are half the width of the other registers (16 bits versus 32 bits).\nThese registers are implemented with the 8T circuit described earlier, making them dual ported:\none register can be read while another register is written.\nAs described earlier, three vertical bus lines pass through each bit: one bitline for reading and two bitlines\n(with opposite polarity)\nfor writing.\nEach register has two control lines (wordlines): one to select a register for reading and another to select a register for writing.</p>\n<p>The photo below shows how four cells of type (<em>f</em>) are implemented on the chip.\nIn this image, the chip's two metal layers have been removed along with most of the polysilicon wiring, showing the underlying silicon.\nThe dark outlines indicate regions of doped silicon, while the stripes across the doped region correspond to transistor\ngates. \nI've labeled each transistor with a letter corresponding to the earlier schematic.\nObserve that the layout of the bottom half is a mirrored copy of the upper half, saving a bit of space.\nThe left and right sides are approximately mirrored; the irregular shape allows separate read and wite wordlines \nto control the left and right halves without colliding.</p>\n<p><a href=\"https://static.righto.com/images/386-regs2/cell-f-labeled.jpg\"><img alt=\"Four memory cells of type (f), separated by dotted lines. The small irregular squares are remnants of polysilicon\nthat weren't fully removed.\" class=\"hilite\" height=\"323\" src=\"https://static.righto.com/images/386-regs2/cell-f-labeled-w300.jpg\" title=\"Four memory cells of type (f), separated by dotted lines. The small irregular squares are remnants of polysilicon\nthat weren't fully removed.\" width=\"300\" /></a><div class=\"cite\">Four memory cells of type (<i>f</i>), separated by dotted lines. The small irregular squares are remnants of polysilicon\nthat weren't fully removed.</div></p>\n<p>The 386's register file and datapath are designed with 60 µm of width assigned to each bit.\nHowever, the register circuit above is unusual:\nthe image above is 60 µm wide but there are two register cells side-by-side.\nThat is, the circuit crams <em>two</em> bits in 60 µm of width, rather than one.\nThus, this dense layout implements two registers per row (with interleaved bits), providing twice the density of the other register circuits.</p>\n<p>If you're curious to know how the transistors above are connected,\nthe schematic below shows how the physical arrangement of the transistors above corresponds to two of the 8T memory cells\ndescribed earlier.\nSince the 386 has two overlapping layers of metal, it is very hard to interpret a die photo with the metal layers.\nBut see my <a href=\"https://www.righto.com/2023/11/reverse-engineering-intel-386.html\">earlier article</a> if you want these photos.</p>\n<p><a href=\"https://static.righto.com/images/386-regs2/schematic-full.png\"><img alt=\"Schematic of two static cells in the 386, labeled &quot;R&quot; and &quot;L&quot; for &quot;right&quot; and &quot;left&quot;. The schematic approximately matches the physical layout.\" class=\"hilite\" height=\"253\" src=\"https://static.righto.com/images/386-regs2/schematic-full-w650.png\" title=\"Schematic of two static cells in the 386, labeled &quot;R&quot; and &quot;L&quot; for &quot;right&quot; and &quot;left&quot;. The schematic approximately matches the physical layout.\" width=\"650\" /></a><div class=\"cite\">Schematic of two static cells in the 386, labeled \"R\" and \"L\" for \"right\" and \"left\". The schematic approximately matches the physical layout.</div></p>\n<p>Above the type (<em>f</em>) registers are 10 registers of type (<em>e</em>), occupying five rows of cells.\nThese registers are the same 8T implementation as before, but these registers are 32 bits wide instead of 16.\nThus, the register takes up the full width of the datapath, unlike the previous registers.\nAs before, the double-density circuit implements two registers per row.\nThe silicon layout is identical (apart from being 32 bits wide instead of 16), so I'm not including a photo.</p>\n<p>Above those registers are four (<em>d</em>) registers, which are more complex.\nThey are triple-ported registers, so one register can be written while two other registers are read.\n(This is useful for ALU operations, for instance, since two values can be added and the result written back\nat the same time.)\nTo support reading a second register, another vertical bus line is added for each bit.\nEach cell has two more transistors to connect the cell to the new bitline.\nAnother wordline controls the additional read path.\nSince each cell has two more transistors, there are 10 transistors in total and the circuit is called 10T.</p>\n<p><a href=\"https://static.righto.com/images/386-regs2/cell-d-labeled.jpg\"><img alt=\"Four cells of type (d). The striped green regions are the remnants of oxide layers that weren't completely removed, and can be ignored.\" class=\"hilite\" height=\"296\" src=\"https://static.righto.com/images/386-regs2/cell-d-labeled-w500.jpg\" title=\"Four cells of type (d). The striped green regions are the remnants of oxide layers that weren't completely removed, and can be ignored.\" width=\"500\" /></a><div class=\"cite\">Four cells of type (<i>d</i>). The striped green regions are the remnants of oxide layers that weren't completely removed, and can be ignored.</div></p>\n<p>The diagram above shows four memory cells of type (<em>d</em>).\nEach of these cells takes the full 60 µm of width, unlike the previous double-density cells.\nThe cells are mirrored horizontally and vertically;\nthis increases the density slightly since power lines can be shared between cells.\nI've labeled the transistors <code>A</code> through <code>H</code> as before, as well as the two additional transistors <code>I</code> and <code>J</code> for the\nsecond read line.\nThe circuit is the same as before, except for the two additional transistors, but\nthe silicon layout is significantly different.</p>\n<p>Each of the (<em>d</em>) registers has five control lines. Two control lines select a register for reading, connecting the register\nto one of the two vertical read buses.\nThe three write lines allow parts of the register to be written independently: the top 16 bits, the next 8 bits, or the\nbottom 8 bits.\nThis is required by the x86 architecture, where a 32-bit register such as EAX can also be accessed as the 16-bit AX register,\nthe 8-bit AH register, or the 8-bit AL register.\nNote that reading part of a register doesn't require separate control lines: the register provides all 32 bits and\nthe reading circuit can ignore the bits it doesn't want.</p>\n<p>Proceeding upward, the three (<em>c</em>) registers have a similar 10T implementation.\nThese registers, however, do not support partial writes so all 32 bits must be written at once.\nAs a result, these registers only require three control lines (two for reads and one for writes).\nWith fewer control lines, the cells can be fit into less vertical space, so the layout is slightly more compact than\nthe previous type (<em>d</em>) cells. The diagram below shows four type (<em>c</em>) rows above two type (<em>d</em>) rows.\nAlthough the cells have the same ten transistors, they have been shifted around somewhat.</p>\n<p><a href=\"https://static.righto.com/images/386-regs2/cells-cd.jpg\"><img alt=\"Four rows of type (c) above two cells of type (d).\" class=\"hilite\" height=\"383\" src=\"https://static.righto.com/images/386-regs2/cells-cd-w500.jpg\" title=\"Four rows of type (c) above two cells of type (d).\" width=\"500\" /></a><div class=\"cite\">Four rows of type (<i>c</i>) above two cells of type (<i>d</i>).</div></p>\n<p>Next are the four (<em>b</em>) registers, which support 16-bit writes and 32-bit writes (but not 8-bit writes).\nThus, these registers have four control lines (two for reads and two for writes).\nThe cells take slightly more vertical space than the (<em>c</em>) cells due to the additional control line, but the layout is\nalmost identical.</p>\n<p>Finally, the (<em>a</em>) register at the top has an unusual feature: it can receive a copy of the value in the register just\nbelow it.\nThis value is copied directly between the registers, without using the read or write buses.\nThis register has 3 control lines: one for read, one for write, and one for copying.</p>\n<p><a href=\"https://static.righto.com/images/386-regs2/cells-ab-labeled.jpg\"><img alt=\"A cell of type (a), which can copy the value in the cell of type (b) below.\" class=\"hilite\" height=\"408\" src=\"https://static.righto.com/images/386-regs2/cells-ab-labeled-w300.jpg\" title=\"A cell of type (a), which can copy the value in the cell of type (b) below.\" width=\"300\" /></a><div class=\"cite\">A cell of type (<i>a</i>), which can copy the value in the cell of type (<i>b</i>) below.</div></p>\n<p>The diagram above shows a cell of type (<em>a</em>) above a cell of type (<em>b</em>).\nThe cell of type (<em>a</em>) is based on the standard 8T circuit,\nbut with six additional transistors to copy the value of the cell below.\nSpecifically, two inverters buffer the output from cell (<em>b</em>), one inverter for each side of the cell.\nThese inverters are implemented with transistors I1 through I4.<span id=\"fnref:inverters\"><a class=\"ref\" href=\"#fn:inverters\">5</a></span>\nTwo transistors, S1 and S2, act as a pass-transistor switches between these inverters and the memory cell.\nWhen activated by the control line, the switch transistors allow the inverters to overwrite the memory cell with\nthe contents of the cell below.\nNote that cell (<em>a</em>) takes considerably more vertical space because of the extra transistors.</p>\n<h2>Speculation on the physical layout of the registers</h2>\n<p>I haven't determined the mapping between the 386's registers and the 30 physical registers, but I can speculate.\nFirst, the 386 has four registers that can be accessed as 8, 16, or 32-bit registers: EAX, EBX, ECX, and EDX.\nThese must map onto the (<em>d</em>) registers, which support these access patterns.</p>\n<p>The four index registers (ESP, EBP, ESI, and EDI) can be used as 32-bit registers or 16-bit registers,\nmatching the four (<em>b</em>) registers with the same properties.\nWhich one of these registers can be copied to the type (<em>a</em>) register?\nMaybe the stack pointer (ESP) is copied as part of interrupt handling.</p>\n<p>The register file has eight 16-bit registers, type (<em>f</em>).\nSince there are six 16-bit segment registers in the 386, I suspect the 16-bit registers are the segment registers and two additional registers.\nThe <a href=\"https://web.archive.org/web/20210624172529/https://asm.inightmare.org/opcodelst/index.php?op=LOADALL\">LOADALL</a>\ninstruction gives some clues, suggesting that the two additional 16-bit registers are\nLDT (Local Descriptor Table register) and TR (Task Register).\nMoreover, <code>LOADALL</code> handles 10 temporary registers, matching the 10 registers of type (<em>e</em>) near the bottom\nof the register file.\nThe three 32-bit registers of type (<em>c</em>) may be the\nCR0 control register and the DR6 and DR7 debug registers.</p>\n<p><a href=\"https://static.righto.com/images/386-regs2/segregs.jpg\"><img alt=\"The six 16-bit segment registers in the 386.\" class=\"hilite\" height=\"233\" src=\"https://static.righto.com/images/386-regs2/segregs-w500.jpg\" title=\"The six 16-bit segment registers in the 386.\" width=\"500\" /></a><div class=\"cite\">The six 16-bit segment registers in the 386.</div></p>\n<p>In this article, I'm only looking at the main register file in the datapath.\nThe 386 presumably has other registers scattered around\nthe chip for various purposes.\nFor instance, the Segment Descriptor Cache contains multiple registers similar to type (<em>e</em>), probably holding cache entries.\nThe processor status flags and the instruction pointer (EIP) may not be implemented as discrete registers.<span id=\"fnref:flags-eip\"><a class=\"ref\" href=\"#fn:flags-eip\">6</a></span></p>\n<p>To the right of the register file, a complicated block of circuitry uses seven-bit values to select registers.\nTwo values select the registers (or constants) to read, while a third value selects the register to write.\nI'm currently analyzing this circuitry, which should provide more insight into how the physical registers\nare assigned.</p>\n<h2>The shuffle network</h2>\n<p>There's one additional complication in the register layout.\nAs mentioned earlier, the bottom 16 bits of the main registers can be treated as two 8-bit registers.<span id=\"fnref:datapoint\"><a class=\"ref\" href=\"#fn:datapoint\">7</a></span>\nFor example, the 8-bit AH and AL registers form the bottom 16 bits of the EAX register.\nI explained earlier how the registers use multiple write control lines to allow these different parts of the register\nto be updated separately.\nHowever, there is also a layout problem.</p>\n<p>To see the problem, suppose you perform an 8-bit ALU operation on the AH register, which is bits 15-8 of the EAX register.\nThese bits must be shifted down to positions 7-0 so they can take part in the ALU operation, and then must be shifted\nback to positions 15-8 when stored into AH.\nOn the other hand, if you perform an ALU operation on AL (bits 7-0 of EAX), the bits are already in position and\ndon't need to be shifted.</p>\n<p>To support the shifting required for 8-bit register operations, the 386's register file physically interleaves the bits of the two lower bytes (but not the high bytes).\nAs a result, bit 0 of AL is next to bit 0 of AH in the register file, and so forth.\nThis allows multiplexers to easily select bits from AH or AL as needed.\nIn other words, each bit of AH and AL is in almost the correct physical position, so an 8-bit shift is not required.\n(If the bits were in order, each multiplexer would need to be connected to bits that are separated by eight positions,\nrequiring inconvenient wiring.)<span id=\"fnref:8086\"><a class=\"ref\" href=\"#fn:8086\">8</a></span></p>\n<p><a href=\"https://static.righto.com/images/386-regs2/swap-network.jpg\"><img alt=\"The shuffle network above the register file interleaves the bottom 16 bits.\" class=\"hilite\" height=\"99\" src=\"https://static.righto.com/images/386-regs2/swap-network-w600.jpg\" title=\"The shuffle network above the register file interleaves the bottom 16 bits.\" width=\"600\" /></a><div class=\"cite\">The shuffle network above the register file interleaves the bottom 16 bits.</div></p>\n<p>The photo above shows the shuffle network.\nEach bit has three bus lines associated with it: two for reads and one for writes, and these all get shuffled.\nOn the left, the lines for the 16 bits pass straight through.\nOn the right, though, the two bytes are interleaved.\nThis shuffle network is located below the ALU and above the register file, so data words are shuffled when stored in the\nregister file and then unshuffled when read from the register file.<span id=\"fnref:constants\"><a class=\"ref\" href=\"#fn:constants\">9</a></span></p>\n<p>In the photo, the lines on the left aren't quite straight.\nThe reason is that the circuitry above is narrower than the circuitry below.\nFor the most part, each functional block in the datapath is constructed with the same width (60 µm) for each bit.\nThis makes the layout simpler since functional blocks can be stacked on top of each other and the vertical bus wiring\ncan pass straight through.\nHowever, the circuitry above the registers (for the barrel shifter) is about 10% narrower (54.5 µm), so the wiring\nneeds to squeeze in and then expand back out.<span id=\"fnref:width\"><a class=\"ref\" href=\"#fn:width\">10</a></span>\nThere's a tradeoff of requiring more space for this wiring versus the space saved by making the barrel shifter\nnarrower and Intel must have considered the tradeoff worthwhile.\n(My hypothesis is that since the shuffle network required additional wiring to shuffle the bits, it didn't take up\nmore space to squeeze the wiring together at the same time.)</p>\n<h2>Conclusions</h2>\n<p>If you look in a book on processor design, you'll find a description of how registers can be created from static memory cells.\nHowever, the 386 illustrates that the implementation in a real processor is considerably more complicated.\nInstead of using one circuit, Intel used six different circuits for the registers in the 386.</p>\n<p>The 386's register circuitry also shows the curse of backward compatibility.\nThe x86 architecture supports 8-bit register accesses for\ncompatibility with processors dating back to 1971.\nThis compatibility requires additional circuitry such as the shuffle network and interleaved registers.\nLooking at the circuitry of x86 processors makes me appreciate some of the advantages of RISC processors,\nwhich avoid much of the ad hoc circuitry of x86 processors.</p>\n<p>If you want more information about how the 386's memory cells were implemented, I wrote a <a href=\"https://www.righto.com/2023/11/reverse-engineering-intel-386.html\">lower-level article</a> earlier.\nI plan to write more about the 386, so\nfollow me on Bluesky (<a href=\"https://bsky.app/profile/righto.com\">@righto.com</a>) or <a href=\"https://www.righto.com/feeds/posts/default\">RSS</a> for updates.</p>\n<h2>Footnotes and references</h2>\n<div class=\"footnote\">\n<ol>\n<li id=\"fn:system-regs\">\n<p>The 386 has multiple registers that are only relevant to operating systems programmers\n(see Chapter 4 of the <a href=\"http://www.bitsavers.org/components/intel/80386/230985-003_386DX_Microprocessor_Programmers_Reference_Manual_1990.pdf\">386 Programmer's Reference Manual</a>).\nThese include the Global Descriptor Table Register (GDTR), Local Descriptor Table Register (LDTR), Interrupt Descriptor Table Register (IDTR), and Task Register (TR).\nThere are four Control Registers CR0-CR3; CR0 controls coprocessor usage, paging, and a few other things.\nThe six Debug Registers for hardware breakpoints are named DR0-DR3, DR6, and DR7.\nThe two Test Registers for TLB testing are named TR6 and TR7.\nI expect that these registers are in the 386's Segment Unit and Paging Unit, rather than part of the processing datapath.&#160;<a class=\"footnote-backref\" href=\"#fnref:system-regs\" title=\"Jump back to footnote 1 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:flip\">\n<p>Typically the write driver circuit generates a strong low on one of the bitlines,\n  flipping the corresponding inverter to a high output.\n  As soon as one inverter flips, it will force the other inverter into the right state.\n  To support this, the pullup transistors in the inverters are weaker than normal.&#160;<a class=\"footnote-backref\" href=\"#fnref:flip\" title=\"Jump back to footnote 2 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:pass\">\n<p>The pass transistor passes its signal through or blocks it.\nIn CMOS, this is usually implemented with a transmission gate with an NMOS and a PMOS transistor in parallel.\nThe cell uses only the NMOS transistor, which is much worse at passing a high signal than a low signal.\nBecause there is one NMOS pass transistor on each side of the inverters, one of the transistors will be passing\na low signal that will flip the state.&#160;<a class=\"footnote-backref\" href=\"#fnref:pass\" title=\"Jump back to footnote 3 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:precharge\">\n<p>The bitline is typically precharged to a high level for a read, and then the cell pulls the line low for\na 0.\nThis is more compact than including circuitry in each cell to pull the line high.&#160;<a class=\"footnote-backref\" href=\"#fnref:precharge\" title=\"Jump back to footnote 4 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:inverters\">\n<p>Note that buffering is needed so the (<em>b</em>) cell can write to the (<em>a</em>) cell. If the cells were connected\ndirectly, cell (<em>a</em>) could overwrite cell (<em>b</em>) as easily as cell (<em>b</em>) could overwrite cell (<em>a</em>).\nWith the inverters in between, cell (<em>b</em>) won't be affected by cell (<em>a</em>).&#160;<a class=\"footnote-backref\" href=\"#fnref:inverters\" title=\"Jump back to footnote 5 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:flags-eip\">\n<p>In the 8086, the processor status flags are not stored as a physical register, but instead consist of flip-flops scattered\nthroughout the chip (<a href=\"https://www.righto.com/2023/02/silicon-reverse-engineering-intel-8086.html\">details</a>).\nThe 386 probably has a similar implementation for the flags.</p>\n<p>In the 8086, the program counter (instruction pointer) does not exist as such.\nInstead, the instruction prefetch circuitry has a register holding the current prefetch address.\nIf the program counter address is required (to push a return address or to perform a relative branch, for instance),\nthe program counter value is derived from the prefetch address.\nIf the 386 is similar, the program counter won't have a physical register in the register file.&#160;<a class=\"footnote-backref\" href=\"#fnref:flags-eip\" title=\"Jump back to footnote 6 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:datapoint\">\n<p>The x86 architecture combines two 8-bit registers to form a 16-bit register for historical reasons.\nThe TTL-based <a href=\"https://www.righto.com/2023/08/datapoint-to-8086.html\">Datapoint 2200</a> (1971) system had 8-bit\nA, B, C, D, E, H, and L registers, with the H and L registers combined to form a 16-bit indexing register for\nmemory accesses. Intel created a microprocessor version of the Datapoint 2200's architecture, called the 8008.\nIntel's 8080 processor extended the register pairs so BC and DE could also be used as 16-bit registers.\nThe 8086 kept this register design, but changed the 16-bit register names to AX, BX, CX, and DX, with\nthe 8-bit parts called AH, AL, and so forth. \nThus, the unusual physical structure of the 386's register file is due to compatibility with a programmable terminal from 1971.&#160;<a class=\"footnote-backref\" href=\"#fnref:datapoint\" title=\"Jump back to footnote 7 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:8086\">\n<p>To support 8-bit and 16-bit operations,\n  the 8086 processor used a similar interleaving scheme with the two 8-bit halves of a register interleaved.\n  Since the 8086 was a 16-bit processor, though, its interleaving was simpler than the 32-bit 386. Specifically,\n  the 8086 didn't have the upper 16 bits to deal with.&#160;<a class=\"footnote-backref\" href=\"#fnref:8086\" title=\"Jump back to footnote 8 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:constants\">\n<p>The 386's constant ROM is located below the shuffle network.\nThus, constants are stored with the bits interleaved in order to produce the right results.\n(This made the ROM contents incomprehensible until I figured out the shuffling pattern, but that's\na topic for another article.)&#160;<a class=\"footnote-backref\" href=\"#fnref:constants\" title=\"Jump back to footnote 9 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:width\">\n<p>The main body of the datapath (ALU, etc.) has the same 60 µm cell width as the register file.\nHowever, the datapath is slightly wider than the register file overall.\nThe reason? The datapath has a small amount of circuitry between bits 7 and 8 and between bits 15 and 16, in\norder to handle 8-bit and 16-bit operations.\nAs a result, the logical structure of the registers is visible as stripes in the physical layout of the ALU below.\n(These stripes are also visible in the die photo at the beginning of this article.)</p>\n<p><a href=\"https://static.righto.com/images/386-regs2/alu-layout.jpg\"><img alt=\"Part of the ALU circuitry, displayed underneath the structure of the EAX register.\" class=\"hilite\" height=\"200\" src=\"https://static.righto.com/images/386-regs2/alu-layout-w500.jpg\" title=\"Part of the ALU circuitry, displayed underneath the structure of the EAX register.\" width=\"500\" /></a><div class=\"cite\">Part of the ALU circuitry, displayed underneath the structure of the EAX register.</div></p>\n<p><!-- -->&#160;<a class=\"footnote-backref\" href=\"#fnref:width\" title=\"Jump back to footnote 10 in the text\">&#8617;</a></p>\n</li>\n</ol>\n</div>",
  "id": "tag:blogger.com,1999:blog-6264947694886887540.post-8383886582076151029"
}