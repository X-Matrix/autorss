{
  "title": "A catalog of side effects",
  "link": "https://bernsteinbear.com/blog/compiler-effects/?utm_source=rss",
  "published": "Tue, 11 Nov 2025 00:00:00 +0000",
  "summary": "<p>Optimizing compilers like to keep track of each IR instruction’s <em>effects</em>. An\ninstruction’s effects vary wildly from having no effects at all, to writing a\nspecific variable, to completely unknown (writing all state).</p>\n\n<p>This post can be thought of as a continuation of <a href=\"/blog/irs/\">What I talk about when I talk\nabout IRs</a>, specifically the section talking about asking the right\nquestions. When we talk about effects, we should ask the right questions: not\n<em>what opcode is this?</em> but instead <em>what effects does this opcode have?</em></p>\n\n<p>Different compilers represent and track these effects differently. I’ve been\nthinking about how to represent these effects all year, so I have been doing\nsome reading. In this post I will give some summaries of the landscape of\napproaches. Please feel free to suggest more.</p>\n\n<h2 id=\"some-background\">Some background</h2>\n\n<p>Internal IR effect tracking is similar to the programming language notion of\nalgebraic effects in type systems, but internally, compilers keep track of\nfiner-grained effects. Effects such as “writes to a local variable”, “writes to\na list”, or “reads from the stack” indicate what instructions can be\nre-ordered, duplicated, or removed entirely.</p>\n\n<p>For example, consider the following pseodocode for some made-up language that\nstands in for a snippet of compiler IR:</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># ...\n</span><span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">some_var</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"n\">another_var</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>\n<span class=\"c1\"># ...\n</span></code></pre></div></div>\n\n<p>The goal of effects is to communicate to the compiler if, for example, these two IR\ninstructions can be re-ordered. The second instruction <em>might</em> write to a\nlocation that the first one reads. But it also might not! This is about knowing\nif <code class=\"language-plaintext highlighter-rouge\">some_var</code> and <code class=\"language-plaintext highlighter-rouge\">another_var</code> <em>alias</em>—if they are different names that\nrefer to the same object.</p>\n\n<p>We can sometimes answer that question directly, but often it’s cheaper to\ncompute an approximate answer: <em>could</em> they even alias? It’s possible that\n<code class=\"language-plaintext highlighter-rouge\">some_var</code> and <code class=\"language-plaintext highlighter-rouge\">another_var</code> have different types, meaning that (as long as you\nhave strict aliasing) the <code class=\"language-plaintext highlighter-rouge\">Load</code> and <code class=\"language-plaintext highlighter-rouge\">Store</code> operations that implement these\nreads and writes by definition touch different locations. And if they look\nat disjoint locations, there need not be any explicit order enforced.</p>\n\n<p>Different compilers keep track of this information differently. The null effect\nanalysis gives up and says “every instruction is maximally effectful” and\ntherefore “we can’t re-order or delete any instructions”. That’s probably fine\nfor a first stab at a compiler, where you will get a big speed up purely based\non strength reductions. Over-approximations of effects should always be\nvalid.</p>\n\n<p>But at some point you start wanting to do dead code elimination (DCE), or\ncommon subexpression elimination (CSE), or loads/store elimination, or move\ninstructions around, and you start wondering how to represent effects. That’s\nwhere I am right now. So here’s a catalog of different compilers I have looked\nat recently.</p>\n\n<p>There are two main ways I have seen to represent effects: bitsets and heap\nrange lists. We’ll look at one example compiler for each, talk a bit about\ntradeoffs, then give a bunch of references to other major compilers.</p>\n\n<p>We’ll start with <a href=\"https://github.com/facebookincubator/cinder\">Cinder</a>, a Python JIT, because that’s what I used to\nwork on.</p>\n\n<h2 id=\"cinder\">Cinder</h2>\n\n<p><a href=\"https://github.com/facebookincubator/cinder\">Cinder</a> tracks heap effects for its high-level IR (HIR) in\n<a href=\"https://github.com/facebookincubator/cinderx/blob/8bf5af94e2792d3fd386ab25b1aeedae27276d50/cinderx/Jit/hir/instr_effects.h\">instr_effects.h</a>. Pretty much everything happens in\nthe <code class=\"language-plaintext highlighter-rouge\">memoryEffects(const Instr&amp; instr)</code> function, which is expected to know\neverything about what effects the given instruction might have.</p>\n\n<p>The data representation is a bitset representation of a lattice called an\n<code class=\"language-plaintext highlighter-rouge\">AliasClass</code> and that is defined in <a href=\"https://github.com/facebookincubator/cinderx/blob/8bf5af94e2792d3fd386ab25b1aeedae27276d50/cinderx/Jit/hir/alias_class.h\">alias_class.h</a>. Each\nbit in the bitset represents a distinct location in the heap: reads from and\nwrites to each of these locations are guaranteed not to affect any of the other\nlocations.</p>\n\n<p>Here is the X-macro that defines it:</p>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cp\">#define HIR_BASIC_ACLS(X) \\\n  X(ArrayItem)            \\\n  X(CellItem)             \\\n  X(DictItem)             \\\n  X(FuncArgs)             \\\n  X(FuncAttr)             \\\n  X(Global)               \\\n  X(InObjectAttr)         \\\n  X(ListItem)             \\\n  X(Other)                \\\n  X(TupleItem)            \\\n  X(TypeAttrCache)        \\\n  X(TypeMethodCache)\n</span>\n<span class=\"k\">enum</span> <span class=\"n\">BitIndexes</span> <span class=\"p\">{</span>\n<span class=\"cp\">#define ACLS(name) k##name##Bit,\n</span>    <span class=\"n\">HIR_BASIC_ACLS</span><span class=\"p\">(</span><span class=\"n\">ACLS</span><span class=\"p\">)</span>\n<span class=\"cp\">#undef ACLS\n</span><span class=\"p\">};</span>\n</code></pre></div></div>\n\n<p>Note that each bit implicitly represents a set: <code class=\"language-plaintext highlighter-rouge\">ListItem</code> does not refer to a\n<em>specific</em> list index, but the infinite set of all possible list indices. It’s\n<em>any</em> list index. Still, every list index is completely disjoint from, say, every\nentry in a global variable table.</p>\n\n<p>(And, to be clear, an object in a list might be the same as an object in a\nglobal variable table. The objects themselves can alias. But the thing being\nwritten to or read from, the thing <em>being side effected</em>, is the container.)</p>\n\n<p>Like other bitset lattices, it’s possible to union the sets by or-ing the bits.\nIt’s possible to query for overlap by and-ing the bits.</p>\n\n<div class=\"language-c++ highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">AliasClass</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// The union of two AliasClass</span>\n  <span class=\"n\">AliasClass</span> <span class=\"k\">operator</span><span class=\"o\">|</span><span class=\"p\">(</span><span class=\"n\">AliasClass</span> <span class=\"n\">other</span><span class=\"p\">)</span> <span class=\"k\">const</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">AliasClass</span><span class=\"p\">{</span><span class=\"n\">bits_</span> <span class=\"o\">|</span> <span class=\"n\">other</span><span class=\"p\">.</span><span class=\"n\">bits_</span><span class=\"p\">};</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"c1\">// The intersection (overlap) of two AliasClass</span>\n  <span class=\"n\">AliasClass</span> <span class=\"k\">operator</span><span class=\"o\">&amp;</span><span class=\"p\">(</span><span class=\"n\">AliasClass</span> <span class=\"n\">other</span><span class=\"p\">)</span> <span class=\"k\">const</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">AliasClass</span><span class=\"p\">{</span><span class=\"n\">bits_</span> <span class=\"o\">&amp;</span> <span class=\"n\">other</span><span class=\"p\">.</span><span class=\"n\">bits_</span><span class=\"p\">};</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n\n<p>If this sounds familiar, it’s because (as the repo notes) it’s a similar idea\nto Cinder’s <a href=\"/blog/lattice-bitset/\">type lattice representation</a>.</p>\n\n<p>Like other lattices, there is both a bottom element (no effects) and a top\nelement (all possible effects):</p>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cp\">#define HIR_OR_BITS(name) | k##name\n</span>\n<span class=\"cp\">#define HIR_UNION_ACLS(X)                           \\\n  </span><span class=\"cm\">/* Bottom union */</span><span class=\"cp\">                                \\\n  X(Empty, 0)                                       \\\n  </span><span class=\"cm\">/* Top union */</span><span class=\"cp\">                                   \\\n  X(Any, 0 HIR_BASIC_ACLS(HIR_OR_BITS))             \\\n  </span><span class=\"cm\">/* Memory locations accessible by managed code */</span><span class=\"cp\"> \\\n  X(ManagedHeapAny, kAny &amp; ~kFuncArgs)\n</span></code></pre></div></div>\n\n<p>Union operations naturally hit a fixpoint at <code class=\"language-plaintext highlighter-rouge\">Any</code> and intersection operations\nnaturally hit a fixpoint at <code class=\"language-plaintext highlighter-rouge\">Empty</code>.</p>\n\n<p>All of this together lets the optimizer ask and answer questions such as:</p>\n\n<ul>\n  <li>where might this instruction write?</li>\n  <li>(because CPython is reference counted and incref implies ownership) where\ndoes this instruction borrow its input from?</li>\n  <li>do these two instructions’ write destinations overlap?</li>\n</ul>\n\n<p>and more.</p>\n\n<p>Let’s take a look at an (imaginary) IR version of the code snippet in the intro\nand see what analyzing it might look like in the optimizer. Here is the fake\nIR:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>v0: Tuple = ...\nv1: List = ...\nv2: Int[5] = ...\n# v = some_var[0]\nv3: Object = LoadTupleItem v0, 0\n# another_var[0] = 5\nStoreListItem v1, 0, v2\n</code></pre></div></div>\n\n<p>You can imagine that <code class=\"language-plaintext highlighter-rouge\">LoadTupleItem</code> declares that it reads from the\n<code class=\"language-plaintext highlighter-rouge\">TupleItem</code> heap and <code class=\"language-plaintext highlighter-rouge\">StoreListItem</code> declares that it writes to the <code class=\"language-plaintext highlighter-rouge\">ListItem</code>\nheap. Because tuple and list pointers cannot be casted into one another and\ntherefore cannot alias, these are\ndisjoint heaps in our bitset. Therefore <code class=\"language-plaintext highlighter-rouge\">ListItem &amp; TupleItem == 0</code>, therefore\nthese memory operations can never interfere! They can (for example) be\nre-ordered arbitrarily.</p>\n\n<p>In Cinder, these memory effects could in the future be used for instruction\nre-ordering, but they are today mostly used in two places: the refcount\ninsertion pass and DCE.</p>\n\n<p>DCE involves first finding the set of instructions that need to be kept around\nbecause they are useful/important/have effects. So here is what the Cinder DCE\n<code class=\"language-plaintext highlighter-rouge\">isUseful</code> looks like:</p>\n\n<div class=\"language-c++ highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">bool</span> <span class=\"nf\">isUseful</span><span class=\"p\">(</span><span class=\"n\">Instr</span><span class=\"o\">&amp;</span> <span class=\"n\">instr</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">return</span> <span class=\"n\">instr</span><span class=\"p\">.</span><span class=\"n\">IsTerminator</span><span class=\"p\">()</span> <span class=\"o\">||</span> <span class=\"n\">instr</span><span class=\"p\">.</span><span class=\"n\">IsSnapshot</span><span class=\"p\">()</span> <span class=\"o\">||</span>\n      <span class=\"p\">(</span><span class=\"n\">instr</span><span class=\"p\">.</span><span class=\"n\">asDeoptBase</span><span class=\"p\">()</span> <span class=\"o\">!=</span> <span class=\"nb\">nullptr</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">instr</span><span class=\"p\">.</span><span class=\"n\">IsPrimitiveBox</span><span class=\"p\">())</span> <span class=\"o\">||</span>\n      <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">instr</span><span class=\"p\">.</span><span class=\"n\">IsPhi</span><span class=\"p\">()</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">memoryEffects</span><span class=\"p\">(</span><span class=\"n\">instr</span><span class=\"p\">).</span><span class=\"n\">may_store</span> <span class=\"o\">!=</span> <span class=\"n\">AEmpty</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>There are some other checks in there but <code class=\"language-plaintext highlighter-rouge\">memoryEffects</code> is right there at the\ncore of it!</p>\n\n<p>Now that we have seen the bitset representation of effects and an\nimplementation in Cinder, let’s take a look at a different representation and\nand an implementation in JavaScriptCore.</p>\n\n<h2 id=\"javascriptcore\">JavaScriptCore</h2>\n\n<p>I keep coming back to <a href=\"https://gist.github.com/pizlonator/cf1e72b8600b1437dda8153ea3fdb963\">How I implement SSA form</a> by <a href=\"http://www.filpizlo.com/\">Fil\nPizlo</a>, one of the significant contributors to JavaScriptCore (JSC). In\nparticular, I keep coming back to the <a href=\"https://gist.github.com/pizlonator/cf1e72b8600b1437dda8153ea3fdb963#uniform-effect-representation\">Uniform Effect\nRepresentation</a> section. This notion of “abstract heaps” felt\nvery… well, abstract. Somehow more abstract than the bitset representation.\nThe pre-order and post-order integer pair as a way to represent nested heap\neffects just did not click.</p>\n\n<p>It didn’t make any sense until I actually went spelunking in JavaScriptCore and\nfound one of several implementations—because, you know, JSC is six compilers\nin a trenchcoat<sup>[<a href=\"https://en.wikipedia.org/wiki/Wikipedia:Citation_needed\"><i>citation needed</i></a>]</sup>.</p>\n\n<p>DFG, B3, DOMJIT, and probably others all have their own abstract heap\nimplementations. We’ll look at DOMJIT mostly because it’s a smaller example and\nalso illustrates something else that’s interesting: builtins. We’ll come back\nto builtins in a minute.</p>\n\n<p>Let’s take a lookat how DOMJIT structures its <a href=\"https://github.com/WebKit/WebKit/blob/989c9f9cd5b1f0c9606820e219ee51da32a34c6b/Source/WebCore/domjit/DOMJITAbstractHeapRepository.yaml\">abstract\nheaps</a>: a YAML file.</p>\n\n<div class=\"language-yaml highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"na\">DOM</span><span class=\"pi\">:</span>\n    <span class=\"na\">Tree</span><span class=\"pi\">:</span>\n        <span class=\"na\">Node</span><span class=\"pi\">:</span>\n            <span class=\"pi\">-</span> <span class=\"s\">Node_firstChild</span>\n            <span class=\"pi\">-</span> <span class=\"s\">Node_lastChild</span>\n            <span class=\"pi\">-</span> <span class=\"s\">Node_parentNode</span>\n            <span class=\"pi\">-</span> <span class=\"s\">Node_nextSibling</span>\n            <span class=\"pi\">-</span> <span class=\"s\">Node_previousSibling</span>\n            <span class=\"pi\">-</span> <span class=\"s\">Node_ownerDocument</span>\n        <span class=\"na\">Document</span><span class=\"pi\">:</span>\n            <span class=\"pi\">-</span> <span class=\"s\">Document_documentElement</span>\n            <span class=\"pi\">-</span> <span class=\"s\">Document_body</span>\n</code></pre></div></div>\n\n<p>It’s a hierarchy. <code class=\"language-plaintext highlighter-rouge\">Node_firstChild</code> is a subheap of <code class=\"language-plaintext highlighter-rouge\">Node</code> is a subheap of…\nand so on. A write to any <code class=\"language-plaintext highlighter-rouge\">Node_nextSibling</code> is a write to <code class=\"language-plaintext highlighter-rouge\">Node</code> is a write to\n… Sibling heaps are unrelated: <code class=\"language-plaintext highlighter-rouge\">Node_firstChild</code> and <code class=\"language-plaintext highlighter-rouge\">Node_lastChild</code>, for\nexample, are disjoint.</p>\n\n<p>To get a feel for this, I wired up a <a href=\"https://github.com/tekknolagi/tekknolagi.github.com/tree/main/assets/code/gen_bitset.rb\">simplified version</a> of\nZJIT’s bitset generator (for <em>types!</em>) to read a YAML document and generate a\nbitset. It generated the following Rust code:</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">mod</span> <span class=\"n\">bits</span> <span class=\"p\">{</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">Empty</span><span class=\"p\">:</span> <span class=\"nb\">u64</span> <span class=\"o\">=</span> <span class=\"mi\">0u64</span><span class=\"p\">;</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">Document_body</span><span class=\"p\">:</span> <span class=\"nb\">u64</span> <span class=\"o\">=</span> <span class=\"mi\">1u64</span> <span class=\"o\">&lt;&lt;</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">Document_documentElement</span><span class=\"p\">:</span> <span class=\"nb\">u64</span> <span class=\"o\">=</span> <span class=\"mi\">1u64</span> <span class=\"o\">&lt;&lt;</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">Document</span><span class=\"p\">:</span> <span class=\"nb\">u64</span> <span class=\"o\">=</span> <span class=\"n\">Document_body</span> <span class=\"p\">|</span> <span class=\"n\">Document_documentElement</span><span class=\"p\">;</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">Node_firstChild</span><span class=\"p\">:</span> <span class=\"nb\">u64</span> <span class=\"o\">=</span> <span class=\"mi\">1u64</span> <span class=\"o\">&lt;&lt;</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">Node_lastChild</span><span class=\"p\">:</span> <span class=\"nb\">u64</span> <span class=\"o\">=</span> <span class=\"mi\">1u64</span> <span class=\"o\">&lt;&lt;</span> <span class=\"mi\">3</span><span class=\"p\">;</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">Node_nextSibling</span><span class=\"p\">:</span> <span class=\"nb\">u64</span> <span class=\"o\">=</span> <span class=\"mi\">1u64</span> <span class=\"o\">&lt;&lt;</span> <span class=\"mi\">4</span><span class=\"p\">;</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">Node_ownerDocument</span><span class=\"p\">:</span> <span class=\"nb\">u64</span> <span class=\"o\">=</span> <span class=\"mi\">1u64</span> <span class=\"o\">&lt;&lt;</span> <span class=\"mi\">5</span><span class=\"p\">;</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">Node_parentNode</span><span class=\"p\">:</span> <span class=\"nb\">u64</span> <span class=\"o\">=</span> <span class=\"mi\">1u64</span> <span class=\"o\">&lt;&lt;</span> <span class=\"mi\">6</span><span class=\"p\">;</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">Node_previousSibling</span><span class=\"p\">:</span> <span class=\"nb\">u64</span> <span class=\"o\">=</span> <span class=\"mi\">1u64</span> <span class=\"o\">&lt;&lt;</span> <span class=\"mi\">7</span><span class=\"p\">;</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">Node</span><span class=\"p\">:</span> <span class=\"nb\">u64</span> <span class=\"o\">=</span> <span class=\"n\">Node_firstChild</span> <span class=\"p\">|</span> <span class=\"n\">Node_lastChild</span> <span class=\"p\">|</span> <span class=\"n\">Node_nextSibling</span> <span class=\"p\">|</span> <span class=\"n\">Node_ownerDocument</span> <span class=\"p\">|</span> <span class=\"n\">Node_parentNode</span> <span class=\"p\">|</span> <span class=\"n\">Node_previousSibling</span><span class=\"p\">;</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">Tree</span><span class=\"p\">:</span> <span class=\"nb\">u64</span> <span class=\"o\">=</span> <span class=\"n\">Document</span> <span class=\"p\">|</span> <span class=\"n\">Node</span><span class=\"p\">;</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">DOM</span><span class=\"p\">:</span> <span class=\"nb\">u64</span> <span class=\"o\">=</span> <span class=\"n\">Tree</span><span class=\"p\">;</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">NumTypeBits</span><span class=\"p\">:</span> <span class=\"nb\">u64</span> <span class=\"o\">=</span> <span class=\"mi\">8</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>It’s not a fancy X-macro, but it’s a short and flexible Ruby script.</p>\n\n<p>Then I took the <a href=\"https://github.com/WebKit/WebKit/blob/989c9f9cd5b1f0c9606820e219ee51da32a34c6b/Source/WebCore/domjit/generate-abstract-heap.rb\">DOMJIT abstract heap\ngenerator</a>—also funnily enough a short Ruby\nscript—modified the output format slightly, and had it generate its int\npairs:</p>\n\n<div class=\"language-rust highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">mod</span> <span class=\"n\">bits</span> <span class=\"p\">{</span>\n  <span class=\"cm\">/* DOMJIT Abstract Heap Tree.\n  DOM&lt;0,8&gt;:\n      Tree&lt;0,8&gt;:\n          Node&lt;0,6&gt;:\n              Node_firstChild&lt;0,1&gt;\n              Node_lastChild&lt;1,2&gt;\n              Node_parentNode&lt;2,3&gt;\n              Node_nextSibling&lt;3,4&gt;\n              Node_previousSibling&lt;4,5&gt;\n              Node_ownerDocument&lt;5,6&gt;\n          Document&lt;6,8&gt;:\n              Document_documentElement&lt;6,7&gt;\n              Document_body&lt;7,8&gt;\n  */</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">DOM</span><span class=\"p\">:</span> <span class=\"n\">HeapRange</span> <span class=\"o\">=</span> <span class=\"n\">HeapRange</span> <span class=\"p\">{</span> <span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">:</span> <span class=\"mi\">8</span> <span class=\"p\">};</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">Tree</span><span class=\"p\">:</span> <span class=\"n\">HeapRange</span> <span class=\"o\">=</span> <span class=\"n\">HeapRange</span> <span class=\"p\">{</span> <span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">:</span> <span class=\"mi\">8</span> <span class=\"p\">};</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">Node</span><span class=\"p\">:</span> <span class=\"n\">HeapRange</span> <span class=\"o\">=</span> <span class=\"n\">HeapRange</span> <span class=\"p\">{</span> <span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">:</span> <span class=\"mi\">6</span> <span class=\"p\">};</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">Node_firstChild</span><span class=\"p\">:</span> <span class=\"n\">HeapRange</span> <span class=\"o\">=</span> <span class=\"n\">HeapRange</span> <span class=\"p\">{</span> <span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">:</span> <span class=\"mi\">1</span> <span class=\"p\">};</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">Node_lastChild</span><span class=\"p\">:</span> <span class=\"n\">HeapRange</span> <span class=\"o\">=</span> <span class=\"n\">HeapRange</span> <span class=\"p\">{</span> <span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">:</span> <span class=\"mi\">2</span> <span class=\"p\">};</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">Node_parentNode</span><span class=\"p\">:</span> <span class=\"n\">HeapRange</span> <span class=\"o\">=</span> <span class=\"n\">HeapRange</span> <span class=\"p\">{</span> <span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">:</span> <span class=\"mi\">3</span> <span class=\"p\">};</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">Node_nextSibling</span><span class=\"p\">:</span> <span class=\"n\">HeapRange</span> <span class=\"o\">=</span> <span class=\"n\">HeapRange</span> <span class=\"p\">{</span> <span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">:</span> <span class=\"mi\">4</span> <span class=\"p\">};</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">Node_previousSibling</span><span class=\"p\">:</span> <span class=\"n\">HeapRange</span> <span class=\"o\">=</span> <span class=\"n\">HeapRange</span> <span class=\"p\">{</span> <span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">:</span> <span class=\"mi\">5</span> <span class=\"p\">};</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">Node_ownerDocument</span><span class=\"p\">:</span> <span class=\"n\">HeapRange</span> <span class=\"o\">=</span> <span class=\"n\">HeapRange</span> <span class=\"p\">{</span> <span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">:</span> <span class=\"mi\">6</span> <span class=\"p\">};</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">Document</span><span class=\"p\">:</span> <span class=\"n\">HeapRange</span> <span class=\"o\">=</span> <span class=\"n\">HeapRange</span> <span class=\"p\">{</span> <span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">:</span> <span class=\"mi\">8</span> <span class=\"p\">};</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">Document_documentElement</span><span class=\"p\">:</span> <span class=\"n\">HeapRange</span> <span class=\"o\">=</span> <span class=\"n\">HeapRange</span> <span class=\"p\">{</span> <span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">:</span> <span class=\"mi\">7</span> <span class=\"p\">};</span>\n  <span class=\"k\">pub</span> <span class=\"k\">const</span> <span class=\"n\">Document_body</span><span class=\"p\">:</span> <span class=\"n\">HeapRange</span> <span class=\"o\">=</span> <span class=\"n\">HeapRange</span> <span class=\"p\">{</span> <span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">:</span> <span class=\"mi\">8</span> <span class=\"p\">};</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>It already comes with a little diagram, which is super helpful for readability.</p>\n\n<p>Any empty range(s) represent empty heap effects: if the start and end are the\nsame number, there are no effects. There is no one <code class=\"language-plaintext highlighter-rouge\">Empty</code> value, but any empty\nrange could be normalized to <code class=\"language-plaintext highlighter-rouge\">HeapRange { start: 0, end: 0 }</code>.</p>\n\n<p>Maybe this was obvious to you, dear reader, but this pre-order/post-order thing\nis about nested ranges! Seeing the output of the generator laid out clearly\nlike this made it make a lot more sense for me.</p>\n\n<!--\nSo how do we compute subtyping relationships with `HeapRange`s? We check range\noverlap! Here is [DOMJIT's C++ implementation][domjit-is-subtype-of]:\n\n[domjit-is-subtype-of]: https://github.com/WebKit/WebKit/blob/989c9f9cd5b1f0c9606820e219ee51da32a34c6b/Source/JavaScriptCore/domjit/DOMJITHeapRange.h#L99\n\n```c++\nclass HeapRange {\n    constexpr explicit operator bool() const {\n        return m_begin != m_end;\n    }\n\n    bool isStrictSubtypeOf(const HeapRange& other) const {\n        if (!*this || !other)\n            return false;\n        if (*this == other)\n            return false;\n        return other.m_begin <= m_begin && m_end <= other.m_end;\n    }\n\n    bool isSubtypeOf(const HeapRange& other) const {\n        if (!*this || !other)\n            return false;\n        if (*this == other)\n            return true;\n        return isStrictSubtypeOf(other);\n    }\n```\n\nThis is represented by the `operator bool()`\nand implicit boolean conversions. To reinforce the whole nested heap ranges\nthing, `isSubtypeOf` is asking if one `HeapRange` contains another.\n-->\n\n<p>What about checking overlap? Here is the <a href=\"https://github.com/WebKit/WebKit/blob/989c9f9cd5b1f0c9606820e219ee51da32a34c6b/Source/JavaScriptCore/domjit/DOMJITHeapRange.h#L108\">implementation in\nJSC</a>:</p>\n\n<div class=\"language-c++ highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">namespace</span> <span class=\"n\">WTF</span> <span class=\"p\">{</span>\n<span class=\"c1\">// Check if two ranges overlap assuming that neither range is empty.</span>\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"nc\">T</span><span class=\"p\">&gt;</span>\n<span class=\"k\">constexpr</span> <span class=\"kt\">bool</span> <span class=\"n\">nonEmptyRangesOverlap</span><span class=\"p\">(</span><span class=\"n\">T</span> <span class=\"n\">leftMin</span><span class=\"p\">,</span> <span class=\"n\">T</span> <span class=\"n\">leftMax</span><span class=\"p\">,</span> <span class=\"n\">T</span> <span class=\"n\">rightMin</span><span class=\"p\">,</span> <span class=\"n\">T</span> <span class=\"n\">rightMax</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">ASSERT_UNDER_CONSTEXPR_CONTEXT</span><span class=\"p\">(</span><span class=\"n\">leftMin</span> <span class=\"o\">&lt;</span> <span class=\"n\">leftMax</span><span class=\"p\">);</span>\n    <span class=\"n\">ASSERT_UNDER_CONSTEXPR_CONTEXT</span><span class=\"p\">(</span><span class=\"n\">rightMin</span> <span class=\"o\">&lt;</span> <span class=\"n\">rightMax</span><span class=\"p\">);</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">leftMax</span> <span class=\"o\">&gt;</span> <span class=\"n\">rightMin</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">rightMax</span> <span class=\"o\">&gt;</span> <span class=\"n\">leftMin</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// Pass ranges with the min being inclusive and the max being exclusive.</span>\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"nc\">T</span><span class=\"p\">&gt;</span>\n<span class=\"k\">constexpr</span> <span class=\"kt\">bool</span> <span class=\"n\">rangesOverlap</span><span class=\"p\">(</span><span class=\"n\">T</span> <span class=\"n\">leftMin</span><span class=\"p\">,</span> <span class=\"n\">T</span> <span class=\"n\">leftMax</span><span class=\"p\">,</span> <span class=\"n\">T</span> <span class=\"n\">rightMin</span><span class=\"p\">,</span> <span class=\"n\">T</span> <span class=\"n\">rightMax</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">ASSERT_UNDER_CONSTEXPR_CONTEXT</span><span class=\"p\">(</span><span class=\"n\">leftMin</span> <span class=\"o\">&lt;=</span> <span class=\"n\">leftMax</span><span class=\"p\">);</span>\n    <span class=\"n\">ASSERT_UNDER_CONSTEXPR_CONTEXT</span><span class=\"p\">(</span><span class=\"n\">rightMin</span> <span class=\"o\">&lt;=</span> <span class=\"n\">rightMax</span><span class=\"p\">);</span>\n\n    <span class=\"c1\">// Empty ranges interfere with nothing.</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">leftMin</span> <span class=\"o\">==</span> <span class=\"n\">leftMax</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">rightMin</span> <span class=\"o\">==</span> <span class=\"n\">rightMax</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">nonEmptyRangesOverlap</span><span class=\"p\">(</span><span class=\"n\">leftMin</span><span class=\"p\">,</span> <span class=\"n\">leftMax</span><span class=\"p\">,</span> <span class=\"n\">rightMin</span><span class=\"p\">,</span> <span class=\"n\">rightMax</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">HeapRange</span> <span class=\"p\">{</span>\n    <span class=\"kt\">bool</span> <span class=\"n\">overlaps</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">HeapRange</span><span class=\"o\">&amp;</span> <span class=\"n\">other</span><span class=\"p\">)</span> <span class=\"k\">const</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">WTF</span><span class=\"o\">::</span><span class=\"n\">rangesOverlap</span><span class=\"p\">(</span><span class=\"n\">m_begin</span><span class=\"p\">,</span> <span class=\"n\">m_end</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">.</span><span class=\"n\">m_begin</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">.</span><span class=\"n\">m_end</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>(See also <a href=\"https://zayenz.se/blog/post/how-to-check-for-overlapping-intervals/\">How to check for overlapping intervals</a> and\n<a href=\"https://nedbatchelder.com/blog/201310/range_overlap_in_two_compares.html\">Range overlap in two compares</a> for more fun.)</p>\n\n<p>While bitsets are a dense representation (you have to hold every bit), they are\nvery compact and they are very precise. You can hold any number of combinations\nof 64 or 128 bits in a single register. The union and intersection operations\nare very cheap.</p>\n\n<p>With int ranges, it’s a little more complicated. An imprecise union of <code class=\"language-plaintext highlighter-rouge\">a</code> and\n<code class=\"language-plaintext highlighter-rouge\">b</code> can take the maximal range that covers both <code class=\"language-plaintext highlighter-rouge\">a</code> and <code class=\"language-plaintext highlighter-rouge\">b</code>. To get a more\nprecise union, you have to keep track of both. In the worst case, if you want\nefficient arbitrary queries, you need to store your int ranges in an interval\ntree. So what gives?</p>\n\n<p>I asked Fil if both bitsets and int ranges answer the same question, why use\nint ranges? He said that it’s more flexible long-term: bitsets get expensive as\nsoon as you need over 128 bits (you might need to heap allocate them!) whereas\nranges have no such ceiling. But doesn’t holding sequences of ranges require\nheap allocation? Well, despite Fil writing this in his SSA post:</p>\n\n<blockquote>\n  <p>The purpose of the effect representation baked into the IR is to provide a\nprecise always-available baseline for alias information that is super easy to\nwork with. […] you can have instructions report that they read/write\nmultiple heaps […] you can have a utility function that produces such lists\non demand.</p>\n</blockquote>\n\n<p>It’s important to note that this doesn’t actually involve any allocation of\nlists. JSC does this very clever thing where they have “functors” that they\npass in as arguments that compress/summarize what they want to out of an\ninstruction’s effects.</p>\n\n<p>Let’s take a look at how the DFG (for example) uses these heap ranges in\nanalysis. The DFG is structured in such a way that it can make use of the\nDOMJIT heap ranges directly, which is neat.</p>\n\n<p>Note that <code class=\"language-plaintext highlighter-rouge\">AbstractHeap</code> in the example below is a thin wrapper over the DFG\ncompiler’s own <code class=\"language-plaintext highlighter-rouge\">DOMJIT::HeapRange</code> equivalent:</p>\n\n<div class=\"language-c++ highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">AbstractHeapOverlaps</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"n\">AbstractHeapOverlaps</span><span class=\"p\">(</span><span class=\"n\">AbstractHeap</span> <span class=\"n\">heap</span><span class=\"p\">)</span>\n        <span class=\"o\">:</span> <span class=\"n\">m_heap</span><span class=\"p\">(</span><span class=\"n\">heap</span><span class=\"p\">)</span>\n        <span class=\"p\">,</span> <span class=\"n\">m_result</span><span class=\"p\">(</span><span class=\"nb\">false</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"kt\">void</span> <span class=\"k\">operator</span><span class=\"p\">()(</span><span class=\"n\">AbstractHeap</span> <span class=\"n\">otherHeap</span><span class=\"p\">)</span> <span class=\"k\">const</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">m_result</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span><span class=\"p\">;</span>\n        <span class=\"n\">m_result</span> <span class=\"o\">=</span> <span class=\"n\">m_heap</span><span class=\"p\">.</span><span class=\"n\">overlaps</span><span class=\"p\">(</span><span class=\"n\">otherHeap</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"kt\">bool</span> <span class=\"n\">result</span><span class=\"p\">()</span> <span class=\"k\">const</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"n\">m_result</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n\n<span class=\"nl\">private:</span>\n    <span class=\"n\">AbstractHeap</span> <span class=\"n\">m_heap</span><span class=\"p\">;</span>\n    <span class=\"k\">mutable</span> <span class=\"kt\">bool</span> <span class=\"n\">m_result</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">bool</span> <span class=\"n\">writesOverlap</span><span class=\"p\">(</span><span class=\"n\">Graph</span><span class=\"o\">&amp;</span> <span class=\"n\">graph</span><span class=\"p\">,</span> <span class=\"n\">Node</span><span class=\"o\">*</span> <span class=\"n\">node</span><span class=\"p\">,</span> <span class=\"n\">AbstractHeap</span> <span class=\"n\">heap</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">NoOpClobberize</span> <span class=\"n\">noOp</span><span class=\"p\">;</span>\n    <span class=\"n\">AbstractHeapOverlaps</span> <span class=\"n\">addWrite</span><span class=\"p\">(</span><span class=\"n\">heap</span><span class=\"p\">);</span>\n    <span class=\"n\">clobberize</span><span class=\"p\">(</span><span class=\"n\">graph</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">,</span> <span class=\"n\">noOp</span><span class=\"p\">,</span> <span class=\"n\">addWrite</span><span class=\"p\">,</span> <span class=\"n\">noOp</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">addWrite</span><span class=\"p\">.</span><span class=\"n\">result</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p><code class=\"language-plaintext highlighter-rouge\">clobberize</code> is the function that calls these functors (<code class=\"language-plaintext highlighter-rouge\">noOp</code> or <code class=\"language-plaintext highlighter-rouge\">addWrite</code> in\nthis case) for each effect that the given IR instruction <code class=\"language-plaintext highlighter-rouge\">node</code> declares.</p>\n\n<p>I’ve pulled some relevant snippets of <code class=\"language-plaintext highlighter-rouge\">clobberize</code>, which is quite long, that I\nthink are interesting.</p>\n\n<p>First, some instructions (constants, here) have no effects. There’s some\nutility in the <code class=\"language-plaintext highlighter-rouge\">def(PureValue(...))</code> call but I didn’t understand fully.</p>\n\n<p>Then there are some instructions that conditionally have effects depending on\nthe use types of their operands.<sup id=\"fnref:dfg-use-type\"><a class=\"footnote\" href=\"#fn:dfg-use-type\" rel=\"footnote\">1</a></sup> Taking the absolute value of an\nInt32 or a Double is effect-free but otherwise looks like it can run arbitrary\ncode.</p>\n\n<p>Some run-time IR guards that might cause side exits are annotated as\nsuch—they write to the <code class=\"language-plaintext highlighter-rouge\">SideState</code> heap.</p>\n\n<p>Local variable instructions read <em>specific</em> heaps indexed by what looks like\nthe local index but I’m not sure. This means accessing two different locals\nwon’t alias!</p>\n\n<p>Instructions that allocate can’t be re-ordered, it looks like; they both read\nand write the <code class=\"language-plaintext highlighter-rouge\">HeapObjectCount</code>. This probably limits the amount of allocation\nsinking that can be done.</p>\n\n<p>Then there’s <code class=\"language-plaintext highlighter-rouge\">CallDOM</code>, which is the builtins stuff I was talking about. We’ll\ncome back to that after the code block.</p>\n\n<div class=\"language-c++ highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"nc\">ReadFunctor</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"nc\">WriteFunctor</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"nc\">DefFunctor</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"nc\">ClobberTopFunctor</span><span class=\"p\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"nf\">clobberize</span><span class=\"p\">(</span><span class=\"n\">Graph</span><span class=\"o\">&amp;</span> <span class=\"n\">graph</span><span class=\"p\">,</span> <span class=\"n\">Node</span><span class=\"o\">*</span> <span class=\"n\">node</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">ReadFunctor</span><span class=\"o\">&amp;</span> <span class=\"n\">read</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">WriteFunctor</span><span class=\"o\">&amp;</span> <span class=\"n\">write</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">DefFunctor</span><span class=\"o\">&amp;</span> <span class=\"n\">def</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"c1\">// ...</span>\n\n    <span class=\"k\">switch</span> <span class=\"p\">(</span><span class=\"n\">node</span><span class=\"o\">-&gt;</span><span class=\"n\">op</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n    <span class=\"k\">case</span> <span class=\"n\">JSConstant</span><span class=\"p\">:</span>\n    <span class=\"k\">case</span> <span class=\"n\">DoubleConstant</span><span class=\"p\">:</span>\n    <span class=\"k\">case</span> <span class=\"n\">Int52Constant</span><span class=\"p\">:</span>\n        <span class=\"n\">def</span><span class=\"p\">(</span><span class=\"n\">PureValue</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"o\">-&gt;</span><span class=\"n\">constant</span><span class=\"p\">()));</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n\n    <span class=\"k\">case</span> <span class=\"n\">ArithAbs</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">node</span><span class=\"o\">-&gt;</span><span class=\"n\">child1</span><span class=\"p\">().</span><span class=\"n\">useKind</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"n\">Int32Use</span> <span class=\"o\">||</span> <span class=\"n\">node</span><span class=\"o\">-&gt;</span><span class=\"n\">child1</span><span class=\"p\">().</span><span class=\"n\">useKind</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"n\">DoubleRepUse</span><span class=\"p\">)</span>\n            <span class=\"n\">def</span><span class=\"p\">(</span><span class=\"n\">PureValue</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"o\">-&gt;</span><span class=\"n\">arithMode</span><span class=\"p\">()));</span>\n        <span class=\"k\">else</span>\n            <span class=\"n\">clobberTop</span><span class=\"p\">();</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n\n    <span class=\"k\">case</span> <span class=\"n\">AssertInBounds</span><span class=\"p\">:</span>\n    <span class=\"k\">case</span> <span class=\"n\">AssertNotEmpty</span><span class=\"p\">:</span>\n        <span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">SideState</span><span class=\"p\">);</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n\n    <span class=\"k\">case</span> <span class=\"n\">GetLocal</span><span class=\"p\">:</span>\n        <span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">AbstractHeap</span><span class=\"p\">(</span><span class=\"n\">Stack</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"o\">-&gt;</span><span class=\"n\">operand</span><span class=\"p\">()));</span>\n        <span class=\"n\">def</span><span class=\"p\">(</span><span class=\"n\">HeapLocation</span><span class=\"p\">(</span><span class=\"n\">StackLoc</span><span class=\"p\">,</span> <span class=\"n\">AbstractHeap</span><span class=\"p\">(</span><span class=\"n\">Stack</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"o\">-&gt;</span><span class=\"n\">operand</span><span class=\"p\">())),</span> <span class=\"n\">LazyNode</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"p\">));</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n\n    <span class=\"k\">case</span> <span class=\"n\">NewArrayWithSize</span><span class=\"p\">:</span>\n    <span class=\"k\">case</span> <span class=\"n\">NewArrayWithSizeAndStructure</span><span class=\"p\">:</span>\n        <span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">HeapObjectCount</span><span class=\"p\">);</span>\n        <span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">HeapObjectCount</span><span class=\"p\">);</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n\n    <span class=\"k\">case</span> <span class=\"n\">CallDOM</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"k\">const</span> <span class=\"n\">DOMJIT</span><span class=\"o\">::</span><span class=\"n\">Signature</span><span class=\"o\">*</span> <span class=\"n\">signature</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">-&gt;</span><span class=\"n\">signature</span><span class=\"p\">();</span>\n        <span class=\"n\">DOMJIT</span><span class=\"o\">::</span><span class=\"n\">Effect</span> <span class=\"n\">effect</span> <span class=\"o\">=</span> <span class=\"n\">signature</span><span class=\"o\">-&gt;</span><span class=\"n\">effect</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">effect</span><span class=\"p\">.</span><span class=\"n\">reads</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">effect</span><span class=\"p\">.</span><span class=\"n\">reads</span> <span class=\"o\">==</span> <span class=\"n\">DOMJIT</span><span class=\"o\">::</span><span class=\"n\">HeapRange</span><span class=\"o\">::</span><span class=\"n\">top</span><span class=\"p\">())</span>\n                <span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">World</span><span class=\"p\">);</span>\n            <span class=\"k\">else</span>\n                <span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">AbstractHeap</span><span class=\"p\">(</span><span class=\"n\">DOMState</span><span class=\"p\">,</span> <span class=\"n\">effect</span><span class=\"p\">.</span><span class=\"n\">reads</span><span class=\"p\">.</span><span class=\"n\">rawRepresentation</span><span class=\"p\">()));</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">effect</span><span class=\"p\">.</span><span class=\"n\">writes</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">effect</span><span class=\"p\">.</span><span class=\"n\">writes</span> <span class=\"o\">==</span> <span class=\"n\">DOMJIT</span><span class=\"o\">::</span><span class=\"n\">HeapRange</span><span class=\"o\">::</span><span class=\"n\">top</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n                <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">Options</span><span class=\"o\">::</span><span class=\"n\">validateDFGClobberize</span><span class=\"p\">())</span>\n                    <span class=\"n\">clobberTopFunctor</span><span class=\"p\">();</span>\n                <span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">Heap</span><span class=\"p\">);</span>\n            <span class=\"p\">}</span> <span class=\"k\">else</span>\n                <span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">AbstractHeap</span><span class=\"p\">(</span><span class=\"n\">DOMState</span><span class=\"p\">,</span> <span class=\"n\">effect</span><span class=\"p\">.</span><span class=\"n\">writes</span><span class=\"p\">.</span><span class=\"n\">rawRepresentation</span><span class=\"p\">()));</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">ASSERT_WITH_MESSAGE</span><span class=\"p\">(</span><span class=\"n\">effect</span><span class=\"p\">.</span><span class=\"n\">def</span> <span class=\"o\">==</span> <span class=\"n\">DOMJIT</span><span class=\"o\">::</span><span class=\"n\">HeapRange</span><span class=\"o\">::</span><span class=\"n\">top</span><span class=\"p\">(),</span> <span class=\"s\">\"Currently, we do not accept any def for CallDOM.\"</span><span class=\"p\">);</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>(Remember that these <code class=\"language-plaintext highlighter-rouge\">AbstractHeap</code> operations are very similar to DOMJIT’s\n<code class=\"language-plaintext highlighter-rouge\">HeapRange</code> with a couple more details—and in some cases even contain DOMJIT\n<code class=\"language-plaintext highlighter-rouge\">HeapRange</code>s!)</p>\n\n<p>This <code class=\"language-plaintext highlighter-rouge\">CallDOM</code> node is the way for the DOM APIs in the browser—a significant\nchunk of the builtins, which are written in C++—to communicate what they do\nto the optimizing compiler. Without any annotations, the JIT has to assume that\na call into C++ could do anything to the JIT state. Bummer!</p>\n\n<p>But because, for example, <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Node/firstChild\"><code class=\"language-plaintext highlighter-rouge\">Node.firstChild</code></a> <a href=\"https://github.com/WebKit/WebKit/blob/32bda1b1d73527ba1d05ccba0aa8e463ddeac56d/Source/WebCore/domjit/JSNodeDOMJIT.cpp#L86\">annotates what\nmemory it reads from</a> and what it <em>doesn’t</em> write to,\nthe JIT can optimize around it better—or even remove the access completely.\nIt means the JIT can reason about calls to known builtins <em>the same way</em> that\nit reasons about normal JIT opcodes.</p>\n\n<p>(Incidentally it looks like it doesn’t even make a C call, but instead is\ninlined as a little memory read snippet using a JIT builder API. Neat.)</p>\n\n<!-- TODO tie it back to the original example -->\n\n<!--\nB3 from JSC\nhttps://github.com/WebKit/WebKit/blob/main/Source/JavaScriptCore/b3/B3Effects.h\nhttps://github.com/WebKit/WebKit/blob/5811a5ad27100acab51f1d5ba4518eed86bbf00b/Source/JavaScriptCore/b3/B3AbstractHeapRepository.h\n\nDOMJIT from JSC\nhttps://github.com/WebKit/WebKit/blob/main/Source/WebCore/domjit/generate-abstract-heap.rb\ngenerates from https://github.com/WebKit/WebKit/blob/b99cb96a7a3e5978b475d2365b72196e15a1a326/Source/WebCore/domjit/DOMJITAbstractHeapRepository.yaml#L4\n\nDFG from JSC\nhttps://github.com/WebKit/WebKit/blob/b99cb96a7a3e5978b475d2365b72196e15a1a326/Source/JavaScriptCore/dfg/DFGAbstractHeap.h\nhttps://github.com/WebKit/WebKit/blob/b99cb96a7a3e5978b475d2365b72196e15a1a326/Source/JavaScriptCore/dfg/DFGClobberize.h\nhttps://github.com/WebKit/WebKit/blob/b99cb96a7a3e5978b475d2365b72196e15a1a326/Source/JavaScriptCore/dfg/DFGClobberize.cpp\nhttps://github.com/WebKit/WebKit/blob/b99cb96a7a3e5978b475d2365b72196e15a1a326/Source/JavaScriptCore/dfg/DFGClobberize.h\nhttps://github.com/WebKit/WebKit/blob/b99cb96a7a3e5978b475d2365b72196e15a1a326/Source/JavaScriptCore/dfg/DFGStructureAbstractValue.cpp\nhttps://github.com/WebKit/WebKit/blob/b99cb96a7a3e5978b475d2365b72196e15a1a326/Source/JavaScriptCore/dfg/DFGStructureAbstractValue.h\nhttps://github.com/WebKit/WebKit/blob/b99cb96a7a3e5978b475d2365b72196e15a1a326/Source/JavaScriptCore/dfg/DFGClobberSet.h\nhttps://github.com/WebKit/WebKit/blob/b99cb96a7a3e5978b475d2365b72196e15a1a326/Source/JavaScriptCore/dfg/DFGStructureAbstractValue.h\n-->\n\n<p>Last, we’ll look at Simple, which has a slightly different take on all of this.</p>\n\n<h2 id=\"simple\">Simple</h2>\n\n<p><a href=\"https://github.com/seaofnodes/simple\">Simple</a> is Cliff Click’s pet Sea of\nNodes (SoN) project to try and showcase the idea to the world—outside of a\nHotSpot C2 context.</p>\n\n<p>This one is a little harder for me to understand but it looks like each\ntranslation unit has a <a href=\"https://github.com/SeaOfNodes/Simple/blob/1426384fc7d0e9947e38ad6d523a5e53c324d710/chapter10/src/main/java/com/seaofnodes/simple/node/StartNode.java#L33\"><code class=\"language-plaintext highlighter-rouge\">StartNode</code></a> that doles out\ndifferent classes of memory nodes for each alias class. Each IR node then takes\ndata dependencies on whatever effect nodes it might uses.</p>\n\n<p>Alias classes are split up based on the paper <a href=\"/assets/img/tbaa.pdf\">Type-Based Alias Analysis</a>\n(PDF): “Our approach is a form of TBAA similar to the ‘FieldTypeDecl’ algorithm\ndescribed in the paper.”</p>\n\n<!--\n\nCliff Click says:\n\nAll effects are represented as edges in the graph, the same edges as normal value flows, and all edges in Simple/C2 are simple pointers (and hence are unlabeled).\n\nStartNode produces all effects and StopNode consumes them; same for Call and CallEnd.\nEffects, being just another form of value, can be merged in PhiNodes.\nEffects are generally split into smaller disjoint pieces, and recombined before Stop/Call.  Splitting into disjoint pieces allows more precision in the IR, and so more optimizations.\nThe common first split is the Memory effect from all other effects.  Other effects are generally some form of abstract i/o (all file system operations, reading/writing device controller memory, all external calls to disjoint address spaces, etc), or control.  Control is Just Another Edge denoting normal control flow, and e.g. data ops that depend on a prior control op use it to guard for safety.  Things like div-by-0, or null-ptr-check, or array-index-OOB are all done with a control edge to the guarding test.\n\nMemory effects are further split into disjoint aliases; operations in one alias class can never overlap with another (this is a Y/N choice, not a may/must choice).  These aliases are equivalence classes; all mem ops belong in exactly one class, and the set of classes exactly partitions all of memory.  Common splits are fields in a struct (no 'f' field ever overlaps with any 'g' field), or kinds of arrays (no int[] overlaps with a flt[]).\n\nIn this example a = l[0]; l[0] = 5, we might have as IR:\n\na = Load(ctrl-for-AIOOB, mem-for-int[], offset);\nmem-for-int[] = Store(ctrl-for-AIOOB, mem-for-int[], offset, 5)\n\n\n\nNote that the Load and Store are not ordered here.  This Store IS ordered against all other int[] Stores.\nThe serializing algo Global Code Motion will add an anti-dep as needed, and then order the Load & Store.\n\nSplitting is basically by having a \"narrow\" user read from a \"fat memory\".  Narrow, because its using a single alias and is one of the memops (e.g. Loads and Stores).  A \"fat memory\" always comes from Start & CallEnd.  A MemMerge can merge a bunch of narrow aliases (and one fat) and make a fat memory.  Basically its all done lazily by \"doing nothing\", and requiring the graph builder not produce a junk graph.\n\nSplitting happens when the Parser decides you are manipulating a slice.\nTHere are some peephole's for widening the split region over a larger area, allowing more memory optimizations in the larger wider area.\nLoad & Stores have a peep to move \"up past\" a MemMerge on the correct alias edge.\n-->\n\n<p>The Simple project is structured into sequential implementation stages and\nalias classes come into the picture in <a href=\"https://github.com/SeaOfNodes/Simple/tree/main/chapter10\">Chapter 10</a>.</p>\n\n<p>Because I spent a while spelunking through other implementations to see how\nother projects did this, here is a list of the projects I looked at. Mostly,\nthey use bitsets.</p>\n\n<h2 id=\"other-implementations\">Other implementations</h2>\n\n<h3 id=\"hhvm\">HHVM</h3>\n\n<p><a href=\"https://github.com/facebook/hhvm\">HHVM</a>, a JIT for the\n<a href=\"https://hacklang.org/\">Hack</a> language, also uses a bitset for its memory\neffects. See for example: <a href=\"https://github.com/facebook/hhvm/blob/0395507623c2c08afc1d54c0c2e72bc8a3bd87f1/hphp/runtime/vm/jit/alias-class.h\">alias-class.h</a> and\n<a href=\"https://github.com/facebook/hhvm/blob/0395507623c2c08afc1d54c0c2e72bc8a3bd87f1/hphp/runtime/vm/jit/memory-effects.h\">memory-effects.h</a>.</p>\n\n<p>HHVM has a couple places that use this information, such as <a href=\"https://github.com/facebook/hhvm/blob/4cdb85bf737450bf6cb837d3167718993f9170d7/hphp/runtime/vm/jit/def-sink.cpp\">a\ndefinition-sinking pass</a>, <a href=\"https://github.com/facebook/hhvm/blob/0395507623c2c08afc1d54c0c2e72bc8a3bd87f1/hphp/runtime/vm/jit/alias-analysis.h\">alias\nanalysis</a>, <a href=\"https://github.com/facebook/hhvm/blob/4cdb85bf737450bf6cb837d3167718993f9170d7/hphp/runtime/vm/jit/dce.cpp\">DCE</a>, <a href=\"https://github.com/facebook/hhvm/blob/4cdb85bf737450bf6cb837d3167718993f9170d7/hphp/runtime/vm/jit/store-elim.cpp\">store\nelimination</a>, <a href=\"https://github.com/facebook/hhvm/blob/1f9eda80656b79634b6956084481ed5a43d8bc2e/hphp/runtime/vm/jit/refcount-opts.cpp\">refcount opts</a>, and\nmore.</p>\n\n<p>If you are wondering why the HHVM representation looks similar to the Cinder\nrepresentation, it’s because some former HHVM engineers such as Brett Simmers\nalso worked on Cinder!</p>\n\n<h3 id=\"android-art\">Android ART</h3>\n\n<p>(note that I am linking an ART fork on GitHub as a reference, but the upstream\ncode is <a href=\"https://android.googlesource.com/platform/art/+/refs/heads/main/compiler/optimizing/nodes.h\">hosted on googlesource</a>)</p>\n\n<p>Android’s <a href=\"https://source.android.com/docs/core/runtime\">ART Java runtime</a> also\nuses a bitset for its effect representation. It’s a very compact class called\n<code class=\"language-plaintext highlighter-rouge\">SideEffects</code> in <a href=\"https://github.com/LineageOS/android_art/blob/c09a5c724799afdc5f89071b682b181c0bd23099/compiler/optimizing/nodes.h#L1602\">nodes.h</a>.</p>\n\n<p>The side effects are used in <a href=\"https://github.com/LineageOS/android_art/blob/c09a5c724799afdc5f89071b682b181c0bd23099/compiler/optimizing/licm.cc#L104\">loop-invariant code motion</a>, <a href=\"https://github.com/LineageOS/android_art/blob/c09a5c724799afdc5f89071b682b181c0bd23099/compiler/optimizing/gvn.cc#L204\">global\nvalue numbering</a>, <a href=\"https://github.com/LineageOS/android_art/blob/c09a5c724799afdc5f89071b682b181c0bd23099/compiler/optimizing/write_barrier_elimination.cc#L45\">write barrier\nelimination</a>, <a href=\"https://github.com/LineageOS/android_art/blob/c09a5c724799afdc5f89071b682b181c0bd23099/compiler/optimizing/scheduler.cc#L55\">scheduling</a>,\nand more.</p>\n\n<h3 id=\"netcoreclr\">.NET/CoreCLR</h3>\n\n<p>CoreCLR mostly <a href=\"https://github.com/dotnet/runtime/blob/a0878687d02b42034f4ea433ddd7a72b741510b8/src/coreclr/jit/sideeffects.h#L169\">uses a bitset</a> for its <code class=\"language-plaintext highlighter-rouge\">SideEffectSet</code>\nclass. This one is interesting though because it also splits out effects\nspecifically to include sets of local variables (<code class=\"language-plaintext highlighter-rouge\">LclVarSet</code>).</p>\n\n<h3 id=\"v8\">V8</h3>\n\n<p>V8 is also about six completely different compilers in a trenchcoat.</p>\n\n<p>Turboshaft uses a struct in <a href=\"https://github.com/v8/v8/blob/e817fdf31a2947b2105bd665067d92282e4b4d59/src/compiler/turboshaft/operations.h#L577\">operations.h</a> called\n<code class=\"language-plaintext highlighter-rouge\">OpEffects</code> which is two bitsets for reads/writes of effects. This is used in\n<a href=\"https://github.com/v8/v8/blob/42f5ff65d12f0ef9294fa7d3875feba938a81904/src/compiler/turboshaft/value-numbering-reducer.h#L164\">value numbering</a> as well a bunch of\nother small optimization passes they call “reducers”.</p>\n\n<p>Maglev also has this thing called <code class=\"language-plaintext highlighter-rouge\">NodeT::kProperties</code> in <a href=\"https://github.com/v8/v8/blob/42f5ff65d12f0ef9294fa7d3875feba938a81904/src/maglev/maglev-ir.h\">their IR\nnodes</a> that also looks like a bitset and is used in their various\nreducers. It has effect query methods on it such as <code class=\"language-plaintext highlighter-rouge\">can_eager_deopt</code> and\n<code class=\"language-plaintext highlighter-rouge\">can_write</code>.</p>\n\n<p>Until recently, V8 also used Sea of Nodes as its IR representation, which also\ntracks side effects more explicitly in the structure of the IR itself.</p>\n\n<h2 id=\"guile\">Guile</h2>\n\n<p><a href=\"https://www.gnu.org/software/guile/\">Guile Scheme</a> looks like it has a <a href=\"https://wingolog.org/archives/2014/05/18/effects-analysis-in-guile\">custom tagging\nscheme</a> type thing.</p>\n\n<h2 id=\"conclusion\">Conclusion</h2>\n\n<p>Both bitsets and int ranges are perfectly cromulent ways of representing heap\neffects for your IR. The Sea of Nodes approach is also probably okay since it\npowers HotSpot C2 and (for a time) V8.</p>\n\n<p>Remember to ask <em>the right questions</em> of your IR when doing analysis.</p>\n\n<h2 id=\"thank-you\">Thank you</h2>\n\n<p>Thank you to <a href=\"http://www.filpizlo.com/\">Fil Pizlo</a> for writing his initial\nGitHub Gist and sending me on this journey and thank you to <a href=\"https://www.chrisgregory.me/\">Chris\nGregory</a>, Brett Simmers, and <a href=\"https://ufuk.dev/\">Ufuk\nKayserilioglu</a> for feedback on making some of the\nexplanations more helpful.</p>\n\n<!--\n\nTODO Dart\nhttps://github.com/dart-lang/sdk/blob/59905c43f1a0394394ad5545ee439bcba63dea55/runtime/vm/constants_riscv.h#L968\nhttps://github.com/dart-lang/sdk/blob/59905c43f1a0394394ad5545ee439bcba63dea55/runtime/vm/compiler/backend/redundancy_elimination.cc#L758\nhttps://github.com/dart-lang/sdk/blob/59905c43f1a0394394ad5545ee439bcba63dea55/runtime/vm/compiler/backend/redundancy_elimination.cc#L1096\n\nChakraCore\nhttps://github.com/chakra-core/ChakraCore/blob/2dba810c925eb366e44a1f7d7a5b2e289e2f8510/lib/Runtime/Types/RecyclableObject.h#L172\n\nSpiderMonkey\nhttps://github.com/servo/mozjs/blob/77645ed41f588297fd8d7edaee71500f4c83d070/mozjs-sys/mozjs/js/src/jit/MIR.h#L935\nhttps://github.com/servo/mozjs/blob/77645ed41f588297fd8d7edaee71500f4c83d070/mozjs-sys/mozjs/js/src/jit/MIR.h#L9658\n\nCinder LIR\nhttps://github.com/facebookincubator/cinderx/blob/main/cinderx/Jit/lir/instruction.h\n\nHotSpot C1\n\nHotSpot C2\n\nPyPy\nhttps://github.com/pypy/pypy/blob/main/rpython/jit/codewriter/effectinfo.py\nhttps://github.com/pypy/pypy/blob/main/rpython/jit/metainterp/optimizeopt/heap.py#L59\n\nLLVM\nhttps://llvm.org/docs/LangRef.html#tbaa-metadata\n\nLLVM MemorySSA\nhttps://llvm.org/docs/MemorySSA.html\n\nMLIR\nhttps://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/\n\nMEMOIR\nhttps://conf.researchr.org/details/cgo-2024/cgo-2024-main-conference/31/Representing-Data-Collections-in-an-SSA-Form\n\nScala LMS graph IR\nhttps://2023.splashcon.org/details/splash-2023-oopsla/46/Graph-IRs-for-Impure-Higher-Order-Languages-Making-Aggressive-Optimizations-Affordab\n\nMIR and borrow checker\nhttps://rustc-dev-guide.rust-lang.org/part-3-intro.html#source-code-representation\n\n> \"Fabrice Rastello, Florent Bouchez Tichadou (2022) SSA-based Compiler Design\"--most (all?) chapters in Part III, Extensions, are pretty much motivated by doing alias analysis in some way\n\nIntermediate Representations in Imperative Compilers: A Survey\nhttp://kameken.clique.jp/Lectures/Lectures2013/Compiler2013/a26-stanier.pdf\n\nPartitioned Lattice per Variable (PLV) -- that's in Chapter 13 on SSI\n\nTODO maybe lattice in ascent\n\n-->\n<div class=\"footnotes\">\n  <ol>\n    <li id=\"fn:dfg-use-type\">\n      <p>This is because the DFG compiler does this interesting thing\nwhere they track and guard the input types on <em>use</em> vs having types\nattached to the input’s own <em>def</em>. It might be a clean way to handle shapes\ninside the type system while also allowing the type+shape of an object to\nchange over time (which it can do in many dynamic language runtimes). <a class=\"reversefootnote\" href=\"#fnref:dfg-use-type\">&#8617;</a></p>\n    </li>\n  </ol>\n</div>",
  "id": "https://bernsteinbear.com/blog/compiler-effects/"
}