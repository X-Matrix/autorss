{
  "title": "Reverse-engineering a carry-lookahead adder in the Pentium",
  "link": "http://www.righto.com/2025/01/pentium-carry-lookahead-reverse-engineered.html",
  "published": "2025-01-18T10:19:00.000-08:00",
  "summary": "<p>Addition is harder than you'd expect, at least for a computer.\nComputers use multiple types of adder circuits with different tradeoffs of size versus speed.\nIn this article, I reverse-engineer an 8-bit adder in the Pentium's floating point unit.\nThis adder turns out to be a carry-lookahead adder,\nin particular, a type known as \"Kogge-Stone.\"<span id=\"fnref:kogge-stone\"><a class=\"ref\" href=\"#fn:kogge-stone\">1</a></span>\nIn this article, I'll explain how a carry-lookahead adder works and I'll show how the Pentium implemented it.\nWarning: lots of Boolean logic ahead.</p>\n<p><a href=\"https://static.righto.com/images/pentium-adder/pentium-labeled.jpg\"><img alt=\"The Pentium die, showing the adder. Click this image (or any other) for a larger version.\" class=\"hilite\" height=\"627\" src=\"https://static.righto.com/images/pentium-adder/pentium-labeled-w600.jpg\" title=\"The Pentium die, showing the adder. Click this image (or any other) for a larger version.\" width=\"600\" /></a><div class=\"cite\">The Pentium die, showing the adder. Click this image (or any other) for a larger version.</div></p>\n<p>The die photo above shows the main functional units of the Pentium.\nThe adder, in the lower right, is a small component of the floating point unit.\nIt is not a general-purpose adder, but is used only for determining quotient digits during division.\nIt played a role in the famous\nPentium FDIV division bug, which I wrote about <a href=\"https://www.righto.com/2024/12/this-die-photo-of-pentium-shows.html\">here</a>.</p>\n<h2>The hardware implementation</h2>\n<p>The photo below shows the carry-lookahead adder used by the divider.\nThe adder itself consists of the circuitry highlighted in red.\nAt the top, logic gates compute signals in parallel for each of the 8 pairs of inputs: partial sum, carry generate, and carry propagate.\nNext, the complex carry-lookahead logic determines in parallel if there will be a carry at each position.\nFinally, XOR gates apply the carry to each bit.\nNote that the sum/generate/propagate circuitry consists of 8 repeated blocks, and the same with the carry XOR\ncircuitry.\nThe carry lookahead circuitry, however, doesn't have any visible structure since it is different for each bit.<span id=\"fnref:8bit\"><a class=\"ref\" href=\"#fn:8bit\">2</a></span></p>\n<p><a href=\"https://static.righto.com/images/pentium-adder/adder-silicon.jpg\"><img alt=\"The carry-lookahead adder that feeds the lookup table. This block of circuitry is just above the PLA on the die. I removed the metal layers, so this photo shows the doped silicon (dark) and the polysilicon (faint gray).\" class=\"hilite\" height=\"787\" src=\"https://static.righto.com/images/pentium-adder/adder-silicon-w550.jpg\" title=\"The carry-lookahead adder that feeds the lookup table. This block of circuitry is just above the PLA on the die. I removed the metal layers, so this photo shows the doped silicon (dark) and the polysilicon (faint gray).\" width=\"550\" /></a><div class=\"cite\">The carry-lookahead adder that feeds the lookup table. This block of circuitry is just above the PLA on the die. I removed the metal layers, so this photo shows the doped silicon (dark) and the polysilicon (faint gray).</div></p>\n<p>The large amount of circuitry in the middle is used for testing; see the footnote.<span id=\"fnref:testing\"><a class=\"ref\" href=\"#fn:testing\">3</a></span>\nAt the bottom, the drivers amplify control signals for various parts of the circuit.</p>\n<h2>The carry-lookahead adder concept</h2>\n<p>The problem with addition is that carries make addition slow.\nConsider calculating 99999+1 by hand.\nYou'll start with 9+1=10, then carry the one, generating another carry, which generates another carry, and so forth, until you go through all the digits.\nComputer addition has the same problem:\nIf you're adding two numbers, the low-order bits can generate a carry that then propagates through all the bits.\nAn adder that works this way&mdash;known as a ripple carry adder&mdash;will be slow because the carry has to ripple through\nall the bits.\nAs a result, CPUs use special circuits to make addition faster.</p>\n<p>One solution is the carry-lookahead adder. In this adder, all the carry bits are computed in parallel, before computing\nthe sums. Then, the sum bits can be computed in parallel, using the carry bits.\nAs a result, the addition can be completed quickly, without waiting for the carries to ripple through\nthe entire sum.</p>\n<p>It may seem impossible to compute the carries without computing the sum first, but there's a way to do it.\nFor each bit position, you determine signals called \"carry generate\" and \"carry propagate\".\nThese signals can then be used to determine all the carries in parallel.\nThe <em>generate</em> signal indicates that the position generates a carry. For instance, if you add binary\n<code>1xx</code> and <code>1xx</code> (where <code>x</code> is an arbitrary bit), a carry will be generated from the top bit,\nregardless of the unspecified bits.\nOn the other hand, adding <code>0xx</code> and <code>0xx</code> will never produce a carry.\nThus, the <em>generate</em> signal is produced for the first case but not the second.</p>\n<p>But what about <code>1xx</code> plus <code>0xx</code>? We might get a carry, for instance, <code>111+001</code>, but we might not get a carry,\nfor instance, <code>101+001</code>. In this \"maybe\" case, we set the <em>carry propagate</em> signal, indicating that a carry into the\nposition will get propagated out of the position. For example, if there is a carry out of\nthe middle position, <code>1xx+0xx</code> will have a carry from the top bit. But if there is no carry out of the middle position, then\nthere will not be a carry from the top bit. In other words, the <em>propagate</em> signal indicates that a carry into the top bit will be propagated out of the top\nbit.</p>\n<p>To summarize, adding <code>1+1</code> will generate a carry. Adding <code>0+1</code> or <code>1+0</code> will propagate a\ncarry.\nThus, the <em>generate</em> signal is formed at each position by <em>G<sub>n</sub> = A<sub>n</sub>·B<sub>n</sub></em>, where <em>A</em> and <em>B</em> are the inputs.\nThe <em>propagate</em> signal is <em>P<sub>n</sub> = A<sub>n</sub>+B<sub>n</sub></em>,\nthe logical-OR of the inputs.<span id=\"fnref:propagate\"><a class=\"ref\" href=\"#fn:propagate\">4</a></span></p>\n<p>Now that the <em>propagate</em> and <em>generate</em> signals are defined, they can be used to compute the carry <em>C<sub>n</sub></em> at\neach bit position:\n<br /><em>C<sub>1</sub> = G<sub>0</sub></em>: a carry into bit 1 occurs if a carry is generated from bit 0.\n<br /><em>C<sub>2</sub> = G<sub>1</sub> + G<sub>0</sub>P<sub>1</sub></em>: A carry into bit 2 occur if bit 1 generates a carry or bit 1 propagates a carry from bit 0.\n<br /><em>C<sub>3</sub> = G<sub>2</sub> + G<sub>1</sub>P<sub>2</sub> + G<sub>0</sub>P<sub>1</sub>P<sub>2</sub></em>: A carry into bit 3 occurs if bit 2 generates a carry, or bit 2 propagates a carry generated from bit 1, or bits 2 and 1 propagate a carry generated from bit 0.\n<br /><em>C<sub>4</sub> = G<sub>3</sub> + G<sub>2</sub>P<sub>3</sub> + G<sub>1</sub>P<sub>2</sub>P<sub>3</sub> + G<sub>0</sub>P<sub>1</sub>P<sub>2</sub>P<sub>3</sub></em>: A carry into bit 4 occurs if a carry is generated from bit 3, 2, 1, or 0 along with the necessary propagate signals.\n<br />... and so forth, getting more complicated with each bit ...</p>\n<p>The important thing about these equations is that they can be computed in parallel, without waiting for a\ncarry to ripple through each position.\nOnce each carry is computed, the sum bits can be computed in parallel: <em>S<sub>n</sub> = A<sub>n</sub> ⊕ B<sub>n</sub> ⊕ C<sub>n</sub></em>. In other words, the two input bits and the computed carry are combined with exclusive-or.</p>\n<h2>Implementing carry lookahead with a parallel prefix adder</h2>\n<p>The straightforward way to implement carry lookahead is to directly implement the equations above.\nHowever, this approach requires a lot of circuitry due to the complicated equations.\nMoreover, it needs gates with many inputs, which are slow for electrical reasons.<span id=\"fnref:74181\"><a class=\"ref\" href=\"#fn:74181\">5</a></span></p>\n<p>The Pentium's adder implements the carry lookahead in a different way, called the \"parallel prefix adder.\"<span id=\"fnref:parallel-prefix\"><a class=\"ref\" href=\"#fn:parallel-prefix\">7</a></span>\nThe idea is to produce the propagate and generate signals across ranges of bits, not just single bits as before.\nFor instance, the <em>propagate</em> signal <em>P<sub>32</sub></em> indicates that a carry in to bit 2 would be propagated out of bit 3.\nAnd <em>G<sub>30</sub></em> indicates that bits 3 to 0 generate a carry out of bit 3.</p>\n<p>Using some mathematical tricks,<span id=\"fnref:pg\"><a class=\"ref\" href=\"#fn:pg\">6</a></span> you can take the <em>P</em> and <em>G</em> values for two smaller ranges and merge them into\nthe <em>P</em> and <em>G</em> values for the combined range.\nFor instance, you can start with the <em>P</em> and <em>G</em> values for bits 0 and 1, and produce <em>P<sub>10</sub></em> and <em>G<sub>10</sub></em>.\nThese could be merged with <em>P<sub>32</sub></em> and <em>G<sub>32</sub></em> to produce <em>P<sub>30</sub></em> and <em>G<sub>30</sub></em>,\nindicating if a carry is propagated across bits 3-0 or generated by bits 3-0.\nNote that <em>G<sub>n0</sub></em> is the carry-lookahead value we need for bit <em>n</em>, so producing these <em>G</em> values gives \nthe results that we need from the carry-lookahead implementation.</p>\n<p>This merging process is more efficient than the \"brute force\" implementation of the carry-lookahead logic since\nlogic subexpressions can be reused.\nThis merging process can be implemented in many ways, including \n<a href=\"https://en.wikipedia.org/wiki/Kogge%E2%80%93Stone_adder\">Kogge-Stone</a>, <a href=\"https://en.wikipedia.org/wiki/Brent%E2%80%93Kung_adder\">Brent-Kung</a>, and Ladner-Fischer.\nThe different algorithms have different tradeoffs of performance versus circuit area.\nIn the next section, I'll show how the Pentium implements the Kogge-Stone algorithm.</p>\n<h2>The Pentium's implementation of the carry-lookahead adder</h2>\n<p>The Pentium's adder is implemented with four layers of circuitry.\nThe first layer produces the <em>propagate</em> and <em>generate</em> signals (<em>P</em> and <em>G</em>) for each bit, along with a partial sum (the sum\nwithout any carries).\nThe second layer merges pairs of neighboring <em>P</em> and <em>G</em> values, producing, for instance <em>G<sub>65</sub></em> and <em>P<sub>21</sub></em>.\nThe third layer generates the carry-lookahead bits by merging previous <em>P</em> and <em>G</em> values. \nThis layer is complicated because it has different circuitry for each bit.\nFinally, the fourth layer applies the carry bits to the partial sum, producing the final arithmetic sum.</p>\n<p>Here is the schematic of the adder, from my reverse engineering.\nThe circuit in the upper left is repeated 8 times to produce the propagate, generate, and partial sum for\neach bit. This corresponds to the first layer of logic.\nAt the left are the circuits to merge the <em>generate</em> and <em>propagate</em> signals across pairs of bits. These circuits\nare the second layer of logic.</p>\n<p><a href=\"https://static.righto.com/images/pentium-adder/adder-schematic.jpg\"><img alt=\"Schematic of the Pentium's 8-bit carry-lookahead adder. Click for a larger version.\" class=\"hilite\" height=\"522\" src=\"https://static.righto.com/images/pentium-adder/adder-schematic-w500.jpg\" title=\"Schematic of the Pentium's 8-bit carry-lookahead adder. Click for a larger version.\" width=\"500\" /></a><div class=\"cite\">Schematic of the Pentium's 8-bit carry-lookahead adder. Click for a larger version.</div></p>\n<p>The circuitry at the right is the interesting part&mdash;it computes the carries in parallel and then computes the\nfinal sum bits using XOR. This corresponds to the third and fourth layers of circuitry respectively.\nThe circuitry gets more complicated going from bottom to top as the bit position increases.</p>\n<p>The diagram below is the standard diagram that illustrates how a\n<a href=\"https://en.wikipedia.org/wiki/Kogge%E2%80%93Stone_adder\">Kogge-Stone</a> adder works.\nIt's rather abstract, but I'll try to explain it.\nThe diagram shows how the <em>P</em> and <em>G</em> signals are merged to produce each output at the bottom. \nEach line coresponds to both the <em>P</em> and the <em>G</em> signal.\nEach square box generates the <em>P</em> and <em>G</em> signals for that bit.\n(Confusingly, the vertical and diagonal lines have the same meaning, indicating inputs going into a diamond\nand outputs coming out of a diamond.)\nEach diamond combines two ranges of <em>P</em> and <em>G</em> signals to generate new <em>P</em> and <em>G</em> signals for the combined\nrange.\nThus, the signals cover wider ranges as they progress downward, ending with the <em>G<sub>n0</sub></em> signals that\nare the outputs.</p>\n<p><a href=\"https://static.righto.com/images/pentium-adder/kogge-stone7.png\"><img alt=\"A diagram of an 8-bit Kogge-Stone adder highlighting the carry out of bit 6 (green) and out of bit 2 (purple). Modification of the diagram by Robey Pointer, Wikimedia Commons.\" class=\"hilite\" height=\"276\" src=\"https://static.righto.com/images/pentium-adder/kogge-stone7-w350.png\" title=\"A diagram of an 8-bit Kogge-Stone adder highlighting the carry out of bit 6 (green) and out of bit 2 (purple). Modification of the diagram by Robey Pointer, Wikimedia Commons.\" width=\"350\" /></a><div class=\"cite\">A diagram of an 8-bit Kogge-Stone adder highlighting the carry out of bit 6 (green) and out of bit 2 (purple). Modification of the diagram by Robey Pointer, <a href=\"https://commons.wikimedia.org/wiki/File:Kogge-stone-8-bit.png\">Wikimedia Commons</a>.</div></p>\n<p>It may be easier to understand the diagram by starting with the outputs.\nI've highlighted two circuits: The purple circuit computes the carry into bit 3 (out of bit 2),\nwhile the green circuit computes the carry into bit 7 (out of bit 6).\nFollowing the purple output upward, note that it forms a tree reaching bits 2, 1, and 0, so it generates the\ncarry based on these bits, as desired.\nIn more detail, the upper purple diamond combines the <em>P</em> and <em>G</em> signals for bits 2 and 1, generating <em>P<sub>21</sub></em> and <em>G<sub>21</sub></em>.\nThe lower purple diamond merges in <em>P<sub>0</sub></em> and <em>G<sub>0</sub></em> to create <em>P<sub>20</sub></em> and <em>G<sub>20</sub></em>.\nSignal <em>G<sub>20</sub></em> indicates of bits 2 through 0 generate a carry; this is the desired carry value into bit 3.</p>\n<p>Now, look at the green output and see how it forms a tree going upward, combining bits 6 through 0.\nNotice how it takes advantage of the purple carry output, reducing the circuitry required.\nIt also uses <em>P<sub>65</sub></em>, <em>P<sub>43</sub></em>, and the corresponding <em>G</em> signals.\nComparing with the earlier schematic shows how the diagram corresponds to the schematic, but abstracts out\nthe details of the gates.</p>\n<p>Comparing the diagram to the schematic, each square box corresponds to\nto the circuit in the upper left of the schematic that generates <em>P</em> and <em>G</em>, the first layer of circuitry.\nThe first row of diamonds corresponds to the pairwise combination circuitry on the left of the schematic, the\nsecond layer of circuitry.\nThe remaining diamonds correspond to the circuitry on the right of the schematic, with each column\ncorresponding to a bit, the third layer of circuitry. (The diagram ignores the final XOR step, the fourth layer of circuitry.)</p>\n<p>Next, I'll show how the diagram above, the logic equations, and the schematic are related.\nThe diagram below shows the logic equation for <em>C<sub>7</sub></em> and how it is implemented with gates; this\ncorresponds to the green diamonds above.\nThe gates on the left below computes <em>G<sub>63</sub></em>; this corresponds to the middle green diamond on the left.\nThe next gate below computes <em>P<sub>63</sub></em> from <em>P<sub>65</sub></em> and <em>P<sub>43</sub></em>; this corresponds to\nthe same green diamond.\nThe last gates mix in <em>C<sub>3</sub></em> (the purple line above); this corresponds to the bottom green diamond.\nAs you can see, the diamonds abstract away the complexity of the gates.\nFinally, the colored boxes below show how the gate inputs map onto the logic equation. Each input corresponds to multiple\nterms in the equation (6 inputs replace 28 terms), showing how this approach reduces the circuitry required.</p>\n<p><a href=\"https://static.righto.com/images/pentium-adder/term7.jpg\"><img alt=\"This diagram shows how the carry into bit 7 is computed, comparing the equations to the logic circuit.\" class=\"hilite\" height=\"300\" src=\"https://static.righto.com/images/pentium-adder/term7-w450.jpg\" title=\"This diagram shows how the carry into bit 7 is computed, comparing the equations to the logic circuit.\" width=\"450\" /></a><div class=\"cite\">This diagram shows how the carry into bit 7 is computed, comparing the equations to the logic circuit.</div></p>\n<p>There are alternatives to the Kogge-Stone adder. For example, a <a href=\"https://en.wikipedia.org/wiki/Brent%E2%80%93Kung_adder\">Brent-Kung adder</a> (below) uses a different arrangement with fewer diamonds but more layers. Thus, a Brent-Kung adder uses less circuitry but is slower.\n(You can follow each output upward to verify that the tree reaches the correct inputs.)</p>\n<p><a href=\"https://static.righto.com/images/pentium-adder/brent-kung.png\"><img alt=\"A diagram of an 8-bit Brent-Kung adder. Diagram by Robey Pointer, Wikimedia Commons.\" class=\"hilite\" height=\"300\" src=\"https://static.righto.com/images/pentium-adder/brent-kung-w300.png\" title=\"A diagram of an 8-bit Brent-Kung adder. Diagram by Robey Pointer, Wikimedia Commons.\" width=\"300\" /></a><div class=\"cite\">A diagram of an 8-bit Brent-Kung adder. Diagram by Robey Pointer, <a href=\"https://commons.wikimedia.org/wiki/File:Brent-kung-8-bit.png\">Wikimedia Commons</a>.</div></p>\n<h2>Conclusions</h2>\n<p>The photo below shows the adder circuitry. I've removed the top two layers of metal, leaving the bottom layer\nof metal. Underneath the metal, polysilicon wiring and doped silicon regions are barely visible; they form\nthe transistors. At the top are eight blocks of gates to generate the partial sum, generate, and propagate signals\nfor each bit.\n(This corresponds to the first layer of circuitry as described earlier.)\nIn the middle is the carry lookahead circuitry. It is irregular since each bit has different circuitry.\n(This corresponds to the second and third layers of circuitry, jumbled together.)\nAt the bottom, eight XOR gates combine the carry lookahead output with the partial sum to produce the adder's output.\n(This corresponds to the fourth layer of circuitry.)</p>\n<p><a href=\"https://static.righto.com/images/pentium-adder/adder-m1.jpg\"><img alt=\"The Pentium's adder circuitry with the top two layers of metal removed.\" class=\"hilite\" height=\"362\" src=\"https://static.righto.com/images/pentium-adder/adder-m1-w700.jpg\" title=\"The Pentium's adder circuitry with the top two layers of metal removed.\" width=\"700\" /></a><div class=\"cite\">The Pentium's adder circuitry with the top two layers of metal removed.</div></p>\n<p>The Pentium uses many adders for different purposes: in the integer unit, in the floating point unit, and for\naddress calculation, among others.\nFloating-point division is known to use a carry-save adder to hold the partial remainder at each step;\nsee my post on the <a href=\"https://www.righto.com/2024/12/this-die-photo-of-pentium-shows.html\">Pentium FDIV division bug</a> for details.\nI don't know what types of adders are used in other parts of the chip, but maybe I'll reverse-engineer some of them.\nFollow me on Bluesky (<a href=\"https://bsky.app/profile/righto.com\">@righto.com</a>) or <a href=\"https://www.righto.com/feeds/posts/default\">RSS</a> for updates. (I'm no longer on Twitter.)</p>\n<h1>Footnotes and references</h1>\n<div class=\"footnote\">\n<ol>\n<li id=\"fn:kogge-stone\">\n<p>Strangely, the original paper by Kogge and Stone had nothing to do with addition and carries. Their 1973 <a href=\"https://doi.org/10.1109/TC.1973.5009159\">paper</a> was titled, \n\"A Parallel Algorithm for the Efficient Solution of a General Class of Recurrence Equations.\"\nIt described how to solve recurrence problems on parallel computers, in particular the massively parallel\nILLIAC IV.\nAs far as I can tell, it wasn't until 1987 that their algorithm was applied to carry lookahead, in\n<a href=\"https://www.acsel-lab.com/Projects/fast_adder/references/papers/Han-Carlson-ARITH8.pdf\">Fast Area-Efficient VLSI Adders</a>.&#160;<a class=\"footnote-backref\" href=\"#fnref:kogge-stone\" title=\"Jump back to footnote 1 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:8bit\">\n<p>I'm a bit puzzled why the circuit uses an 8-bit carry-lookahead adder since only 7 bits are used.\nMoreover, the carry-out is unused.\nHowever, the adder's bottom output bit is not connected to anything.\nPerhaps the 8-bit adder was a standard logic block at Intel and was used as-is.&#160;<a class=\"footnote-backref\" href=\"#fnref:8bit\" title=\"Jump back to footnote 2 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:testing\">\n<p>I probably won't make a separate blog post on the testing circuitry, so I'll put details in this footnote.\nHalf of the circuitry in the adder block is used to test the lookup table.\nThe reason is that\na chip such as the Pentium is very difficult to test: if one out of 3.1 million transistors goes bad, how do you detect it?  For a simple processor like the 8080, you can run through the instruction set and be fairly confident that any problem would turn up.\nBut with a complex chip, it\nis almost impossible to come up with an instruction sequence that would test every bit of the microcode ROM, every bit of the cache, and so forth.\nStarting with the 386, Intel added circuitry to the processor solely to make testing easier; about 2.7% of the transistors in the 386 were for testing.</p>\n<p>To test a ROM inside the processor, Intel added circuitry to scan the entire ROM and checksum its contents.\nSpecifically, a pseudo-random number generator runs through each address, while another circuit computes a checksum of the ROM output, forming a \"signature\" word.\nAt the end, if the signature word has the right value, the ROM is almost certainly correct.\nBut if there is even a single bit error, the checksum will be wrong and the chip will be rejected.\nThe pseudo-random numbers and the checksum are both implemented with linear feedback shift registers (LFSR), a shift register along with a few XOR gates to feed the output back to the input.\nFor more information on testing circuitry in the 386, see <a href=\"https://doi.org/10.1109/MDT.1987.295165\">Design and Test of the 80386</a>,\nwritten by Pat Gelsinger, who became Intel's CEO years later.\nEven with the test circuitry, 48% of the transistor sites in the 386 were untested.\nThe instruction-level test suite to test the remaining circuitry took almost 800,000 clock cycles to run.\nThe overhead of the test circuitry was about 10% more transistors in the blocks that were tested.</p>\n<p>In the Pentium, the circuitry to test the lookup table PLA is just below the 7-bit adder.\nAn 11-bit LFSR creates the 11-bit input value to the lookup table.\nA 13-bit LFSR hashes the two-bit quotient result from the PLA, forming a 13-bit checksum.\nThe checksum is fed serially to test circuitry elsewhere in the chip, where it is merged with\nother test data and written to a register. If the register is 0 at the end, all the tests pass.\nIn particular, if the checksum is correct, you can be 99.99% sure that the lookup table\nis operating as expected.\nThe ironic thing is that this test circuit was useless for the FDIV bug: it ensured that the lookup table held the intended values, but the intended values were wrong.</p>\n<p>Why did Intel generate test addresses with a pseudo-random sequence instead of a sequential\ncounter?\nIt turns out that a linear feedback shift register (LFSR) is slightly more compact than a\ncounter.\nThis LFSR trick was also used in a <a href=\"https://www.righto.com/2017/08/inside-fake-ram-chip-i-found-something.html\">touch-tone chip</a> and the program counter of the Texas Instruments TMS 1000 microcontroller (1974).\nIn the TMS 1000, the program counter steps through the\nprogram pseudo-randomly rather than sequentially.\nThe program is shuffled appropriately in the ROM to counteract the\nsequence, so the program executes as expected and a few transistors are saved.</p>\n<p><a class=\"footnote-backref\" href=\"#fnref:testing\" title=\"Jump back to footnote 3 in the text\">&#8617;</a><a href=\"https://static.righto.com/images/pentium-adder/overall-schematic.jpg\"><img alt=\"Block diagram of the testing circuitry.\" class=\"hilite\" height=\"437\" src=\"https://static.righto.com/images/pentium-adder/overall-schematic-w600.jpg\" title=\"Block diagram of the testing circuitry.\" width=\"600\" /></a><div class=\"cite\">Block diagram of the testing circuitry.</div></p>\n</li>\n<li id=\"fn:propagate\">\n<p>The bits <code>1+1</code> will set <em>generate</em>, but should <em>propagate</em> be set too?\nIt doesn't make a difference as far as the equations. This adder sets <em>propagate</em> for <code>1+1</code> but some\nother adders do not.\nThe answer depends on if you use an inclusive-or or exclusive-or gate\nto produce the propagate signal.&#160;<a class=\"footnote-backref\" href=\"#fnref:propagate\" title=\"Jump back to footnote 4 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:74181\">\n<p>One solution is to implement the carry-lookahead circuit in blocks of four.\nThis can be scaled up with \na second level of carry-lookahead to provide the carry lookahead across each group of four blocks.\nA third level can provide carry lookahead for groups of four second-level blocks, and so forth.\nThis approach requires <em>O(log(N))</em> levels for N-bit addition.\nThis approach is used by the venerable 74181 ALU, a chip used by many minicomputers in the 1970s;\nI reverse-engineered the 74181 <a href=\"https://www.righto.com/2017/03/inside-vintage-74181-alu-chip-how-it.html\">here</a>.\nThe 74182 chip provides carry lookahead for the higher levels.&#160;<a class=\"footnote-backref\" href=\"#fnref:74181\" title=\"Jump back to footnote 5 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:pg\">\n<p>I won't go into the mathematics of merging <em>P</em> and <em>G</em> signals; see, for example, <a href=\"https://bpb-us-w2.wpmucdn.com/sites.coecis.cornell.edu/dist/4/81/files/2019/06/4740_lecture21-adder-circuits.pdf#page=14\">Adder Circuits</a>, <a href=\"https://pages.hmc.edu/harris/cmosvlsi/4e/lect/lect17.pdf\">Adders</a>, or\n<a href=\"https://personal.utdallas.edu/~ivor/ce6305/m4.pdf\">Carry Lookahead Adders</a> for additional details.\nThe important factor is that the carry merge operator is associative (actually a monoid),\nso the sub-ranges can be merged in any order. This flexibility is what allows different algorithms with\ndifferent tradeoffs.&#160;<a class=\"footnote-backref\" href=\"#fnref:pg\" title=\"Jump back to footnote 6 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:parallel-prefix\">\n<p>The idea behind a prefix adder is that we want to see if there is a carry out of bit 0, bits 0-1, bits 0-2, bits 0-3, 0-4, and so forth. These are all the prefixes of the word. Since the prefixes are computed in parallel,\nit's called a parallel prefix adder.&#160;<a class=\"footnote-backref\" href=\"#fnref:parallel-prefix\" title=\"Jump back to footnote 7 in the text\">&#8617;</a></p>\n</li>\n</ol>\n</div>",
  "id": "tag:blogger.com,1999:blog-6264947694886887540.post-256338700959855937"
}