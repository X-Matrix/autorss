{
  "title": "A tricky Commodore PET repair: tracking down 6 1/2 bad chips",
  "link": "http://www.righto.com/2025/04/commodore-pet-repair.html",
  "published": "2025-04-13T08:45:00.000-07:00",
  "summary": "<p>mult3</p>\n<p>In 1977, Commodore released the PET computer, a quirky home computer that combined the processor,\na tiny keyboard, a cassette drive for storage, and a trapezoidal screen in a metal unit.\nThe Commodore PET, the Apple II, and Radio Shack's TRS-80 started the home computer market with ready-to-run computers,\nsystems that were called in retrospect the\n<a href=\"https://web.archive.org/web/20080618072507/http://www.byte.com/art/9509/sec7/art15.htm\">1977 Trinity</a>.\nI did much of my early programming on the PET, so when someone offered me a non-working PET a few years\nago, I took it for nostalgic reasons.</p>\n<p>You'd think that a home computer would be easy to repair, but it turned out to be a challenge.\nThe chips in early PETs are notorious for failures and, sure enough, we found multiple bad chips.\nMoreover, these RAM and ROM chips were special designs that are mostly unobtainable now.\nIn this post, I'll summarize how we repaired the system, in case it helps anyone else.</p>\n<p>When I first powered up the computer, I was greeted with a display full of random characters.\nThis was actually reassuring since it showed that most of the computer was working: not just the monitor,\nbut the video RAM, character ROM, system clock, and power supply were all operational.</p>\n<p><a href=\"https://static.righto.com/images/pet/garbage-screen.jpg\"><img alt=\"The Commodore PET started up, but the screen was full of garbage.\" class=\"hilite\" height=\"489\" src=\"https://static.righto.com/images/pet/garbage-screen-w500.jpg\" title=\"The Commodore PET started up, but the screen was full of garbage.\" width=\"500\" /></a><div class=\"cite\">The Commodore PET started up, but the screen was full of garbage.</div></p>\n<p>With an oscilloscope, I examined signals on the system bus and found that the clock, address, and data lines were full of activity,\nso the 6502 CPU seemed to be operating.\nHowever, some of the data lines had three voltage levels, as shown below.\nThis was clearly not good, and suggested that a chip on the bus was messing up the data signals.</p>\n<p><a href=\"https://static.righto.com/images/pet/scope.jpg\"><img alt=\"The scope shows three voltage levels on the data bus.\" class=\"hilite\" height=\"286\" src=\"https://static.righto.com/images/pet/scope-w500.jpg\" title=\"The scope shows three voltage levels on the data bus.\" width=\"500\" /></a><div class=\"cite\">The scope shows three voltage levels on the data bus.</div></p>\n<p>Some helpful sites online<span id=\"fnref:troubleshooting\"><a class=\"ref\" href=\"#fn:troubleshooting\">7</a></span> suggested that if a PET gets stuck before clearing the screen, the most likely cause is\na failure of a system ROM chip.\nFortunately, Marc has a <a href=\"https://americanretro.shop/rctp\">Retro Chip Tester</a>, a cool device designed to\ntest vintage ICs: not just 7400-series logic, but vintage RAMs and ROMs.\nMoreover, the tester knows the correct ROM contents for a ton of old computers, so it can tell if a PET ROM has\nthe right contents.</p>\n<p>The Retro Chip Tester showed that two of the PET's seven ROM chips had failed.\nThese chips are MOS Technologies MPS6540, a 2K&times;8 ROM with a weird design that is incompatible with standard ROMs.\nFortunately, several people make adapter boards that let you substitute a standard 2716 EPROM, so I ordered\ntwo adapter boards, assembled them, and Marc programmed the 2716 EPROMs from online data files.\nThe 2716 EPROM requires a bit more voltage to program than Marc's programmer supported, but the chips seemed to\nhave the right contents (foreshadowing).</p>\n<p><a href=\"https://static.righto.com/images/pet/pet-opened.jpg\"><img alt=\"The PET opened, showing the motherboard.\" class=\"hilite\" height=\"556\" src=\"https://static.righto.com/images/pet/pet-opened-w500.jpg\" title=\"The PET opened, showing the motherboard.\" width=\"500\" /></a><div class=\"cite\">The PET opened, showing the motherboard.</div></p>\n<p>The PET's case swings open with an arm at the left to hold it open like a car hood.\nThe first two rows of chips at the front of the motherboard are the RAM chips.\nBehind the RAM are the seven ROM chips; two have been\nreplaced by the ROM adapter boards.\nThe 6502 processor is the large black chip behind the ROMs, toward the right.</p>\n<p>With the adapter boards in place, I powered on the PET with great expectations of success, but it failed in precisely\nthe same way as before, failing to clear the garbage off the screen.\nMarc decided it was time to use his Agilent 1670G logic analyzer to find out what was going on;\n(Dating back to 1999, this logic analyzer is modern by Marc's standards.)\nHe wired up the logic analyzer to the 6502 chip, as shown below, so we could track the address bus, data bus,\nand the read/write signal.\nMeanwhile, I disassembled the ROM contents using Ghidra, so I could interpret the logic analyzer against the assembly code.\n(<a href=\"https://ghidra-sre.org/\">Ghidra</a> is a program for reverse-engineering software that was developed by the NSA, strangely enough.)</p>\n<p><a href=\"https://static.righto.com/images/pet/logic-analyzer.jpg\"><img alt=\"Marc wired up the logic analyzer to the 6502 chip.\" class=\"hilite\" height=\"375\" src=\"https://static.righto.com/images/pet/logic-analyzer-w500.jpg\" title=\"Marc wired up the logic analyzer to the 6502 chip.\" width=\"500\" /></a><div class=\"cite\">Marc wired up the logic analyzer to the 6502 chip.</div></p>\n<p>The logic analyzer provided a trace of every memory access from the 6502 processor, showing what it was executing.\nEverything went well for a while after the system was turned on:\nthe processor\njumped to the reset vector location, did a bit of initialization, tested the memory, but then everything went haywire.\nI noticed that the memory test failed on the first byte.\nThen the software tried to get more storage by garbage collecting the BASIC program and variables.\nSince there wasn't any storage at all, this didn't go well and the system hung before reaching the code that\nclears the screen.</p>\n<p>We tested the memory chips, using the Retro Chip Tester again, and found three bad chips.\nLike the ROM chips, the RAM chips are unusual: MOS Technology <a href=\"http://blog.tynemouthsoftware.co.uk/2024/06/mos-6550-ram-chips.html\">6550</a> static RAM chip, 1K&times;4.\nBy removing the bad chips and shuffling the good chips around, we reduced the 8K PET to a 6K PET.\nThis time, the system booted, although there was a mysterious 2&times;2 checkerboard symbol near the middle of the screen (foreshadowing).\nI typed in a simple program to print \"HELLO\", but the results were very strange: four floating-point numbers, followed\nby a hang.</p>\n<p><a href=\"https://static.righto.com/images/pet/floats.jpg\"><img alt=\"This program didn't work the way I expected.\" class=\"hilite\" height=\"351\" src=\"https://static.righto.com/images/pet/floats-w500.jpg\" title=\"This program didn't work the way I expected.\" width=\"500\" /></a><div class=\"cite\">This program didn't work the way I expected.</div></p>\n<p>This behavior was very puzzling.\nI could successfully enter a program into the computer, which exercises a lot of the system code.\n(It's not like a terminal, where echoing text is trivial; the PET does a lot of processing behind the scenes to parse\na BASIC program as it is entered.)\nHowever, the output of the program was completely wrong, printing floating-point numbers instead of a string.</p>\n<p>We also encountered an intermittent problem that after turning the computer on,\nthe boot message would be complete gibberish, as shown below.\nInstead of the \"*** COMMODORE BASIC ***\" banner, random characters and graphics would appear.</p>\n<p><a href=\"https://static.righto.com/images/pet/bad-boot.jpg\"><img alt=\"The garbled boot message.\" class=\"hilite\" height=\"111\" src=\"https://static.righto.com/images/pet/bad-boot-w500.jpg\" title=\"The garbled boot message.\" width=\"500\" /></a><div class=\"cite\">The garbled boot message.</div></p>\n<p>How could the computer be operating well for the most part, yet also completely wrong?\nWe went back to the logic analyzer to find out.</p>\n<p>I figured that the gibberish boot message would probably be the easiest thing to track down, since that happens\nearly in the boot process. \nLooking at the code, I discovered that after the software tests the memory, it converts the memory size to an ASCII string using a moderately complicated\nalgorithm.<span id=\"fnref:conversion\"><a class=\"ref\" href=\"#fn:conversion\">1</a></span>\nThen it writes the system boot message and the memory size to the screen. </p>\n<p>The PET uses a subroutine to write text to the screen.\nA pointer to the text message is held in memory locations 0071 and 0072.\nThe assembly code below stores the pointer (in the X and Y registers) into these memory locations.\n(This Ghidra output\nshows the address, the instruction bytes, and the symbolic assembler instructions.)</p>\n<pre>\nd5ae 86 71   STX 71\nd5b0 84 72   STY 72           \nd5b2 60      RTS\n</pre>\n<p>For the code above, you'd expect the processor to read the instruction bytes 86 and 71, and then write to address 0071.\nNext it should read the bytes 84 and 72 and write to address 0072.\nHowever, the logic analyzer output below showed that something slightly different happened.\nThe processor fetched instruction bytes 86 and 71 from addresses D5AE and D5AF,\nthen wrote 00 to address 0071, as expected.\nNext, it fetched instruction bytes 84 and 72 as expected, but wrote 01 to address 007A, not 0072!</p>\n<pre>\n step   address byte  read/write'\n112235   D5AE   86      1\n112236   D5AF   71      1\n112237   0071   00      0\n112238   D5B0   84      1\n112239   D5B1   72      1\n112240   <span style=\"background-color: yellow;\">007A</span>   01      0\n</pre>\n\n<p>This was a smoking gun. The processor had messed up and there was a one-bit error in the address.\nMaybe the 6502 processor issued a bad signal or maybe something else was causing problems on the bus.\nThe consequence of this error was that the string pointer referenced random memory rather than the desired boot\nmessage, so random characters were written to the screen.</p>\n<p>Next, I investigated why the screen had a mysterious checkerboard character.\nI wrote a program to scan the logic analyzer output to extract all the writes to screen memory.\nMost of the screen operations made sense&mdash;clearing the screen at startup and then writing the boot message&mdash;but I found one\nunexpected write to the screen.\nIn the assembly code below, the Y register should be written to zero-page address 5e, and the X register should\nbe written to the address 66, some locations used by the BASIC interpreter.</p>\n<pre>\nd3c8 84 5e   STY 5e\nd3ca 86 66   STX 66\n</pre>\n<p>However, the logic analyzer output below showed a problem.\nThe first line should fetch the opcode 84 from address d3c8, but the processor received the opcode 8c from the ROM,\nthe instruction to write to a 16-bit address.\nThe result was that instead of writing to a zero-page address, the 6502 fetched another byte to write to a 16-bit\naddress.\nSpecifically, it grabbed the STX instruction (86) and used that as part of the address, writing FF (a checkerboard character) to screen memory at\n865E<span id=\"fnref:screen\"><a class=\"ref\" href=\"#fn:screen\">2</a></span> instead of to the BASIC data structure at 005E.\nMoreover, the STX instruction wasn't executed, since it was consumed as an address.\nThus, not only did a stray character get written to the screen, but data structures in memory didn't get updated.\nIt's not surprising that the BASIC interpreter went out of control when it tried to run the program.</p>\n<pre>\n step   address byte read/write'\n186600   D3C8   <span style=\"background-color: yellow;\">8C</span>      1\n186601   D3C9   <span style=\"background-color: cyan;\">5E</span>      1\n186602   D3CA   <span style=\"background-color: cyan;\">86</span>      1\n186603   <span style=\"background-color: cyan;\">865E</span>   FF      0\n</pre>\n\n<p>We concluded that a ROM was providing the wrong byte (8C) at address D3C8.\nThis ROM turned out to be one of our replacements; the under-powered EPROM programmer had resulted in a flaky byte.\nMarc re-programmed the EPROM with a more powerful programmer.\nThe system booted, but with much less RAM than expected.\nIt turned out that <em>another</em> RAM chip had failed.</p>\n<p>Finally, we got the PET to run. I typed in a simple program to generate an animated graphical pattern, a program\nI remembered from when I was about 13<span id=\"fnref:listing\"><a class=\"ref\" href=\"#fn:listing\">3</a></span>, and generated this output:</p>\n<p><a href=\"https://static.righto.com/images/pet/pet-working.jpg\"><img alt=\"Finally, the PET worked and displayed some graphics. Imagine this pattern constantly changing.\" class=\"hilite\" height=\"442\" src=\"https://static.righto.com/images/pet/pet-working-w500.jpg\" title=\"Finally, the PET worked and displayed some graphics. Imagine this pattern constantly changing.\" width=\"500\" /></a><div class=\"cite\">Finally, the PET worked and displayed some graphics. Imagine this pattern constantly changing.</div></p>\n<p>In retrospect, I should have tested all the RAM and ROM chips at the start, and we probably could have found the faults\nwithout the logic analyzer.\nHowever, the logic analyzer gave me an excuse to learn more about Ghidra and the PET's assembly code, so it\nall worked out in the end.<span id=\"fnref:why\"><a class=\"ref\" href=\"#fn:why\">4</a></span></p>\n<p><a href=\"https://static.righto.com/images/pet/bad-chips.jpg\"><img alt=\"The bad chips sitting on top of the keyboard.\" class=\"hilite\" height=\"367\" src=\"https://static.righto.com/images/pet/bad-chips-w500.jpg\" title=\"The bad chips sitting on top of the keyboard.\" width=\"500\" /></a><div class=\"cite\">The bad chips sitting on top of the keyboard.</div></p>\n<p>In the end, the PET had 6 bad chips: two ROMs and four RAMs.\nThe 6502 processor itself turned out to be fine.<span id=\"fnref:6502\"><a class=\"ref\" href=\"#fn:6502\">5</a></span>\nThe photo below shows the 6 bad chips on top of the PET's tiny keyboard.\nOn the top of each key, you can see the quirky graphical character set known as PETSCII.<span id=\"fnref:petscii\"><a class=\"ref\" href=\"#fn:petscii\">6</a></span>\nAs for the title, I'm counting the badly-programmed ROM as half a bad chip since\nthe chip itself wasn't bad but it was functioning erratically.</p>\n<p>CuriousMarc created a video of the PET restoration, if you want more:</p>\n\n\n<p>Follow me on Bluesky (<a href=\"https://bsky.app/profile/righto.com\">@righto.com</a>) or <a href=\"https://www.righto.com/feeds/posts/default\">RSS</a> for updates. (I'm no longer on Twitter.)\nThanks to Mike Naberezny for providing the PET.\nThanks to <a href=\"https://bsky.app/profile/tubetime.bsky.social\">TubeTime</a>, Mike Stewart, and especially\n<a href=\"https://www.youtube.com/CuriousMarc\">CuriousMarc</a> for help with the repairs.\nSome useful PET troubleshooting links are in the footnotes.<span id=\"fnref2:troubleshooting\"><a class=\"ref\" href=\"#fn:troubleshooting\">7</a></span></p>\n<h2>Footnotes and references</h2>\n<div class=\"footnote\">\n<ol>\n<li id=\"fn:conversion\">\n<p>Converting a number to an ASCII string is somewhat complicated on the 6502. You can't quickly divide by 10 for\nthe decimal conversion, since the processor doesn't have a divide instruction.\nInstead, the PET's conversion routine has hard-coded four-byte constants: -100000000, 10000000, -100000, 100000, -10000, 1000, -100, 10,  and -1.\nThe routine repeatedly adds the first constant (i.e. subtracting 100000000) until the result is negative.\nThen it repeatedly adds the second constant until the result is positive, and so forth.\nThe number of steps gives each decimal digit (after adjustment).</p>\n<p>The same algorithm is used with the base-60 constants: -2160000, 216000, -36000, 3600, -600,  and 60.\nThis converts the uptime count into hours, minutes, and seconds for the <code>TIME$</code> variable. (The PET's basic time count is the \"jiffy\",\n1/60th of a second.)&#160;<a class=\"footnote-backref\" href=\"#fnref:conversion\" title=\"Jump back to footnote 1 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:screen\">\n<p>Technically, the address 865E is not part of screen memory, which is 1000 characters starting at address 0x8000.\nHowever, the PET's address uses some shortcuts in address decoding, so 865E ends up the same as 825e, referencing\nthe 7th character of the 16th line.&#160;<a class=\"footnote-backref\" href=\"#fnref:screen\" title=\"Jump back to footnote 2 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:listing\">\n<p>Here's the source code for my demo program, which I remembered from my teenage programming.\nIt simply displays blocks (black, white, or gray) with 8-fold symmetry,\nwriting directly to screen memory with <code>POKE</code> statements.\n(It turns out that almost anything looks good with 8-fold symmetry.)\nThe cryptic heart in the first <code>PRINT</code> statement is the clear-screen character.</p>\n<p><a href=\"https://static.righto.com/images/pet/listing.jpg\"><img alt=\"My program to display some graphics.\" class=\"hilite\" height=\"284\" src=\"https://static.righto.com/images/pet/listing-w400.jpg\" title=\"My program to display some graphics.\" width=\"400\" /></a><div class=\"cite\">My program to display some graphics.</div></p>\n<p><!-- -->&#160;<a class=\"footnote-backref\" href=\"#fnref:listing\" title=\"Jump back to footnote 3 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:why\">\n<p>So why did I suddenly decide to restore a PET that had been sitting in my garage since 2017?\nWell, CNN was filming an interview with Bill Gates\nand they wanted background footage of the 1970s-era computers that ran the Microsoft BASIC that Bill Gates\nwrote.\nSpoiler: I didn't get my computer working in time for CNN, but Marc found some other computers.</p>\n<p></p>\n<p><!-- -->&#160;<a class=\"footnote-backref\" href=\"#fnref:why\" title=\"Jump back to footnote 4 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:6502\">\n<p>I suspected a problem with the 6502 processor because the logic analyzer showed that the 6502 read an instruction correctly\nbut then accessed the wrong address.\nEric provided a replacement 6502 chip but\nswapping the processor had no effect.\nHowever, reprogramming the ROM fixed both problems.\nOur theory is that the signal on the bus either had a timing problem or a voltage problem, causing the logic analyzer\nto show the correct value but the 6502 to read the wrong value.\nProbably the ROM had a weakly-programmed bit, causing the ROM's output for that bit to either be at an intermediate\nvoltage or causing the output to take too long to settle to the correct voltage.\nThe moral is that you can't always trust the logic analyzer if there are analog faults.&#160;<a class=\"footnote-backref\" href=\"#fnref:6502\" title=\"Jump back to footnote 5 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:petscii\">\n<p>The PETSCII graphics characters are now in Unicode in the <a href=\"https://en.wikipedia.org/wiki/Symbols_for_Legacy_Computing\">Symbols for Legacy Computing</a> block.&#160;<a class=\"footnote-backref\" href=\"#fnref:petscii\" title=\"Jump back to footnote 6 in the text\">&#8617;</a></p>\n</li>\n<li id=\"fn:troubleshooting\">\n<p>The <a href=\"http://www.dasarodesigns.com/projects/troubleshooting-common-problems-with-the-commodore-pet-2001/\">PET troubleshooting site</a> was very helpful.\nThe Commodore PET's Microsoft BASIC source code is <a href=\"https://www.pagetable.com/?p=46\">here</a>, mostly uncommented.\nI mapped many of the labels in the source code to the assembly code produced by Ghidra to understand the logic analyzer traces.\nThe ROM images are <a href=\"https://www.zimmers.net/anonftp/pub/cbm/firmware/computers/pet/\">here</a>.\nSchematics of the PET are <a href=\"https://www.zimmers.net/anonftp/pub/cbm/schematics/computers/pet/2001/index.html\">here</a>.&#160;<a class=\"footnote-backref\" href=\"#fnref:troubleshooting\" title=\"Jump back to footnote 7 in the text\">&#8617;</a><a class=\"footnote-backref\" href=\"#fnref2:troubleshooting\" title=\"Jump back to footnote 7 in the text\">&#8617;</a></p>\n</li>\n</ol>\n</div>",
  "id": "tag:blogger.com,1999:blog-6264947694886887540.post-8423043954026949924"
}